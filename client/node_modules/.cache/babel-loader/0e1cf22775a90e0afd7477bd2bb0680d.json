{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst blakejs = __importStar(require(\"blakejs\"));\n\nconst KeyStore_1 = require(\"../../types/wallet/KeyStore\");\n\nconst TezosTypes = __importStar(require(\"../../types/tezos/TezosChainTypes\"));\n\nconst TezosConstants_1 = require(\"../../types/tezos/TezosConstants\");\n\nconst TezosNodeReader_1 = require(\"./TezosNodeReader\");\n\nconst TezosMessageCodec_1 = require(\"./TezosMessageCodec\");\n\nconst TezosMessageUtil_1 = require(\"./TezosMessageUtil\");\n\nconst TezosLanguageUtil_1 = require(\"./TezosLanguageUtil\");\n\nconst TezosOperationQueue_1 = require(\"./TezosOperationQueue\");\n\nconst CryptoUtils_1 = require(\"../../utils/CryptoUtils\");\n\nconst FetchSelector_1 = __importDefault(require(\"../../utils/FetchSelector\"));\n\nconst fetch = FetchSelector_1.default.getFetch();\n\nconst DeviceSelector_1 = __importDefault(require(\"../../utils/DeviceSelector\"));\n\nlet LedgerUtils = DeviceSelector_1.default.getLedgerUtils();\n\nconst LoggerSelector_1 = __importDefault(require(\"../../utils/LoggerSelector\"));\n\nconst log = LoggerSelector_1.default.getLogger();\nlet operationQueues = {};\nvar TezosNodeWriter;\n\n(function (TezosNodeWriter) {\n  function performPostRequest(server, command, payload = {}) {\n    const url = `${server}/${command}`;\n    const payloadStr = JSON.stringify(payload);\n    log.debug(`TezosNodeWriter.performPostRequest sending ${payloadStr}\\n->\\n${url}`);\n    return fetch(url, {\n      method: 'post',\n      body: payloadStr,\n      headers: {\n        'content-type': 'application/json'\n      }\n    });\n  }\n\n  function signOperationGroup(forgedOperation, keyStore, derivationPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const watermarkedForgedOperationBytesHex = TezosConstants_1.TezosConstants.OperationGroupWatermark + forgedOperation;\n      let opSignature;\n\n      switch (keyStore.storeType) {\n        case KeyStore_1.StoreType.Hardware:\n          try {\n            opSignature = yield LedgerUtils.signTezosOperation(derivationPath, watermarkedForgedOperationBytesHex);\n          } catch (err) {\n            log.error(`TezosNodeWriter.signOperationGroup could not communicate with device: ${JSON.stringify(err)}`);\n            throw new Error(\"Failed to connect to the Ledger device\");\n          }\n\n          break;\n\n        default:\n          const hashedWatermarkedOpBytes = CryptoUtils_1.CryptoUtils.simpleHash(Buffer.from(watermarkedForgedOperationBytesHex, 'hex'), 32);\n          const privateKeyBytes = TezosMessageUtil_1.TezosMessageUtils.writeKeyWithHint(keyStore.privateKey, 'edsk');\n          opSignature = yield CryptoUtils_1.CryptoUtils.signDetached(hashedWatermarkedOpBytes, privateKeyBytes);\n      }\n\n      const hexSignature = TezosMessageUtil_1.TezosMessageUtils.readSignatureWithHint(opSignature, 'edsig').toString();\n      const signedOpBytes = Buffer.concat([Buffer.from(forgedOperation, 'hex'), Buffer.from(opSignature)]);\n      return {\n        bytes: signedOpBytes,\n        signature: hexSignature.toString()\n      };\n    });\n  }\n\n  TezosNodeWriter.signOperationGroup = signOperationGroup;\n\n  function forgeOperations(branch, operations) {\n    log.debug('TezosNodeWriter.forgeOperations:');\n    log.debug(JSON.stringify(operations));\n    let encoded = TezosMessageUtil_1.TezosMessageUtils.writeBranch(branch);\n    operations.forEach(m => encoded += TezosMessageCodec_1.TezosMessageCodec.encodeOperation(m));\n    return encoded;\n  }\n\n  TezosNodeWriter.forgeOperations = forgeOperations;\n\n  function forgeOperationsRemotely(server, blockHead, operations, chainid = 'main') {\n    return __awaiter(this, void 0, void 0, function* () {\n      log.debug('TezosNodeWriter.forgeOperations:');\n      log.debug(JSON.stringify(operations));\n      log.warn('forgeOperationsRemotely() is not intrinsically trustless');\n      const response = yield performPostRequest(server, `chains/${chainid}/blocks/head/helpers/forge/operations`, {\n        branch: blockHead.hash,\n        contents: operations\n      });\n      const forgedOperation = yield response.text();\n      const ops = forgedOperation.replace(/\\n/g, '').replace(/['\"]+/g, '');\n      let optypes = Array.from(operations.map(o => o[\"kind\"]));\n      let validate = false;\n\n      for (let t in optypes) {\n        validate = ['reveal', 'transaction', 'delegation', 'origination'].includes(t);\n\n        if (validate) {\n          break;\n        }\n      }\n\n      if (validate) {\n        const decoded = TezosMessageCodec_1.TezosMessageCodec.parseOperationGroup(ops);\n\n        for (let i = 0; i < operations.length; i++) {\n          const clientop = operations[i];\n          const serverop = decoded[i];\n\n          if (clientop['kind'] === 'transaction') {\n            if (serverop.kind !== clientop['kind'] || serverop.fee !== clientop['fee'] || serverop.amount !== clientop['amount'] || serverop.destination !== clientop['destination']) {\n              throw new Error('Forged transaction failed validation.');\n            }\n          } else if (clientop['kind'] === 'delegation') {\n            if (serverop.kind !== clientop['kind'] || serverop.fee !== clientop['fee'] || serverop.delegate !== clientop['delegate']) {\n              throw new Error('Forged delegation failed validation.');\n            }\n          } else if (clientop['kind'] === 'origination') {\n            if (serverop.kind !== clientop['kind'] || serverop.fee !== clientop['fee'] || serverop.balance !== clientop['balance'] || serverop.spendable !== clientop['spendable'] || serverop.delegatable !== clientop['delegatable'] || serverop.delegate !== clientop['delegate'] || serverop.script !== undefined) {\n              throw new Error('Forged origination failed validation.');\n            }\n          }\n        }\n      }\n\n      return ops;\n    });\n  }\n\n  TezosNodeWriter.forgeOperationsRemotely = forgeOperationsRemotely;\n\n  function preapplyOperation(server, branch, protocol, operations, signedOpGroup, chainid = 'main') {\n    return __awaiter(this, void 0, void 0, function* () {\n      const payload = [{\n        protocol: protocol,\n        branch: branch,\n        contents: operations,\n        signature: signedOpGroup.signature\n      }];\n      const response = yield performPostRequest(server, `chains/${chainid}/blocks/head/helpers/preapply/operations`, payload);\n      const text = yield response.text();\n      let json;\n\n      try {\n        log.debug(`TezosNodeWriter.preapplyOperation received ${text}`);\n        json = JSON.parse(text);\n      } catch (err) {\n        log.error(`TezosNodeWriter.preapplyOperation failed to parse response`);\n        throw new Error(`Could not parse JSON from response of chains/${chainid}/blocks/head/helpers/preapply/operation: '${text}' for ${payload}`);\n      }\n\n      parseRPCError(text);\n      return json;\n    });\n  }\n\n  TezosNodeWriter.preapplyOperation = preapplyOperation;\n\n  function injectOperation(server, signedOpGroup, chainid = 'main') {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield performPostRequest(server, `injection/operation?chain=${chainid}`, signedOpGroup.bytes.toString('hex'));\n      const text = yield response.text();\n      parseRPCError(text);\n      return text;\n    });\n  }\n\n  TezosNodeWriter.injectOperation = injectOperation;\n\n  function sendOperation(server, operations, keyStore, derivationPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const blockHead = yield TezosNodeReader_1.TezosNodeReader.getBlockHead(server);\n      const forgedOperationGroup = forgeOperations(blockHead.hash, operations);\n      const signedOpGroup = yield signOperationGroup(forgedOperationGroup, keyStore, derivationPath);\n      const appliedOp = yield preapplyOperation(server, blockHead.hash, blockHead.protocol, operations, signedOpGroup);\n      const injectedOperation = yield injectOperation(server, signedOpGroup);\n      return {\n        results: appliedOp[0],\n        operationGroupID: injectedOperation\n      };\n    });\n  }\n\n  TezosNodeWriter.sendOperation = sendOperation;\n\n  function queueOperation(server, operations, keyStore, derivationPath = '', batchDelay = 25) {\n    const k = blakejs.blake2s(`${server}${keyStore.publicKeyHash}${derivationPath}`, null, 16);\n\n    if (!!!operationQueues[k]) {\n      operationQueues[k] = TezosOperationQueue_1.TezosOperationQueue.createQueue(server, derivationPath, keyStore, batchDelay);\n    }\n\n    operationQueues[k].addOperations(...operations);\n  }\n\n  TezosNodeWriter.queueOperation = queueOperation;\n\n  function getQueueStatus(server, keyStore, derivationPath = '') {\n    const k = blakejs.blake2s(`${server}${keyStore.publicKeyHash}${derivationPath}`, null, 16);\n\n    if (operationQueues[k]) {\n      return operationQueues[k].getStatus();\n    }\n\n    return -1;\n  }\n\n  TezosNodeWriter.getQueueStatus = getQueueStatus;\n\n  function appendRevealOperation(server, keyStore, accountHash, accountOperationIndex, operations) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const isKeyRevealed = yield TezosNodeReader_1.TezosNodeReader.isManagerKeyRevealedForAccount(server, accountHash);\n      const counter = accountOperationIndex + 1;\n\n      if (!isKeyRevealed) {\n        const revealOp = {\n          kind: 'reveal',\n          source: accountHash,\n          fee: '0',\n          counter: counter.toString(),\n          gas_limit: '10600',\n          storage_limit: '0',\n          public_key: keyStore.publicKey\n        };\n        operations.forEach((operation, index) => {\n          const c = accountOperationIndex + 2 + index;\n          operation.counter = c.toString();\n        });\n        return [revealOp, ...operations];\n      }\n\n      return operations;\n    });\n  }\n\n  TezosNodeWriter.appendRevealOperation = appendRevealOperation;\n\n  function sendTransactionOperation(server, keyStore, to, amount, fee, derivationPath = '') {\n    return __awaiter(this, void 0, void 0, function* () {\n      const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n      const transaction = {\n        destination: to,\n        amount: amount.toString(),\n        storage_limit: TezosConstants_1.TezosConstants.DefaultTransactionStorageLimit + '',\n        gas_limit: TezosConstants_1.TezosConstants.DefaultTransactionGasLimit + '',\n        counter: counter.toString(),\n        fee: fee.toString(),\n        source: keyStore.publicKeyHash,\n        kind: 'transaction'\n      };\n      const operations = yield appendRevealOperation(server, keyStore, keyStore.publicKeyHash, counter - 1, [transaction]);\n      return sendOperation(server, operations, keyStore, derivationPath);\n    });\n  }\n\n  TezosNodeWriter.sendTransactionOperation = sendTransactionOperation;\n\n  function sendDelegationOperation(server, keyStore, delegate, fee = TezosConstants_1.TezosConstants.DefaultDelegationFee, derivationPath = '') {\n    return __awaiter(this, void 0, void 0, function* () {\n      const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n      const delegation = {\n        kind: 'delegation',\n        source: keyStore.publicKeyHash,\n        fee: fee.toString(),\n        counter: counter.toString(),\n        storage_limit: TezosConstants_1.TezosConstants.DefaultDelegationStorageLimit + '',\n        gas_limit: TezosConstants_1.TezosConstants.DefaultDelegationGasLimit + '',\n        delegate: delegate\n      };\n      const operations = yield appendRevealOperation(server, keyStore, keyStore.publicKeyHash, counter - 1, [delegation]);\n      return sendOperation(server, operations, keyStore, derivationPath);\n    });\n  }\n\n  TezosNodeWriter.sendDelegationOperation = sendDelegationOperation;\n\n  function sendUndelegationOperation(server, keyStore, fee = TezosConstants_1.TezosConstants.DefaultDelegationFee, derivationPath = '') {\n    return __awaiter(this, void 0, void 0, function* () {\n      return sendDelegationOperation(server, keyStore, undefined, fee, derivationPath);\n    });\n  }\n\n  TezosNodeWriter.sendUndelegationOperation = sendUndelegationOperation;\n\n  function sendContractOriginationOperation(server, keyStore, amount, delegate, fee, derivationPath, storageLimit, gasLimit, code, storage, codeFormat = TezosTypes.TezosParameterFormat.Micheline) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n      const operation = constructContractOriginationOperation(keyStore, amount, delegate, fee, storageLimit, gasLimit, code, storage, codeFormat, counter);\n      const operations = yield appendRevealOperation(server, keyStore, keyStore.publicKeyHash, counter - 1, [operation]);\n      return sendOperation(server, operations, keyStore, derivationPath);\n    });\n  }\n\n  TezosNodeWriter.sendContractOriginationOperation = sendContractOriginationOperation;\n\n  function constructContractOriginationOperation(keyStore, amount, delegate, fee, storageLimit, gasLimit, code, storage, codeFormat, counter) {\n    let parsedCode = undefined;\n    let parsedStorage = undefined;\n\n    if (codeFormat === TezosTypes.TezosParameterFormat.Michelson) {\n      parsedCode = JSON.parse(TezosLanguageUtil_1.TezosLanguageUtil.translateMichelsonToMicheline(code));\n      log.debug(`TezosNodeWriter.sendOriginationOperation code translation:\\n${code}\\n->\\n${JSON.stringify(parsedCode)}`);\n      parsedStorage = JSON.parse(TezosLanguageUtil_1.TezosLanguageUtil.translateMichelsonToMicheline(storage));\n      log.debug(`TezosNodeWriter.sendOriginationOperation storage translation:\\n${storage}\\n->\\n${JSON.stringify(parsedStorage)}`);\n    } else if (codeFormat === TezosTypes.TezosParameterFormat.Micheline) {\n      parsedCode = JSON.parse(code);\n      parsedStorage = JSON.parse(storage);\n    }\n\n    return {\n      kind: 'origination',\n      source: keyStore.publicKeyHash,\n      fee: fee.toString(),\n      counter: counter.toString(),\n      gas_limit: gasLimit.toString(),\n      storage_limit: storageLimit.toString(),\n      balance: amount.toString(),\n      delegate: delegate,\n      script: {\n        code: parsedCode,\n        storage: parsedStorage\n      }\n    };\n  }\n\n  TezosNodeWriter.constructContractOriginationOperation = constructContractOriginationOperation;\n\n  function sendContractInvocationOperation(server, keyStore, contract, amount, fee, derivationPath, storageLimit, gasLimit, entrypoint, parameters, parameterFormat = TezosTypes.TezosParameterFormat.Micheline) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n      const transaction = constructContractInvocationOperation(keyStore.publicKeyHash, counter, contract, amount, fee, storageLimit, gasLimit, entrypoint, parameters, parameterFormat);\n      const operations = yield appendRevealOperation(server, keyStore, keyStore.publicKeyHash, counter - 1, [transaction]);\n      return sendOperation(server, operations, keyStore, derivationPath);\n    });\n  }\n\n  TezosNodeWriter.sendContractInvocationOperation = sendContractInvocationOperation;\n\n  function constructContractInvocationOperation(publicKeyHash, counter, to, amount, fee, storageLimit, gasLimit, entrypoint, parameters, parameterFormat = TezosTypes.TezosParameterFormat.Micheline) {\n    let transaction = {\n      destination: to,\n      amount: amount.toString(),\n      storage_limit: storageLimit.toString(),\n      gas_limit: gasLimit.toString(),\n      counter: counter.toString(),\n      fee: fee.toString(),\n      source: publicKeyHash,\n      kind: 'transaction'\n    };\n\n    if (parameters !== undefined) {\n      if (parameterFormat === TezosTypes.TezosParameterFormat.Michelson) {\n        const michelineParams = TezosLanguageUtil_1.TezosLanguageUtil.translateParameterMichelsonToMicheline(parameters);\n        transaction.parameters = {\n          entrypoint: entrypoint || 'default',\n          value: JSON.parse(michelineParams)\n        };\n      } else if (parameterFormat === TezosTypes.TezosParameterFormat.Micheline) {\n        transaction.parameters = {\n          entrypoint: entrypoint || 'default',\n          value: JSON.parse(parameters)\n        };\n      } else if (parameterFormat === TezosTypes.TezosParameterFormat.MichelsonLambda) {\n        const michelineLambda = TezosLanguageUtil_1.TezosLanguageUtil.translateMichelsonToMicheline(`code ${parameters}`);\n        transaction.parameters = {\n          entrypoint: entrypoint || 'default',\n          value: JSON.parse(michelineLambda)\n        };\n      }\n    } else if (entrypoint !== undefined) {\n      transaction.parameters = {\n        entrypoint: entrypoint,\n        value: []\n      };\n    }\n\n    return transaction;\n  }\n\n  TezosNodeWriter.constructContractInvocationOperation = constructContractInvocationOperation;\n\n  function sendContractPing(server, keyStore, to, fee, derivationPath, storageLimit, gasLimit, entrypoint) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return sendContractInvocationOperation(server, keyStore, to, 0, fee, derivationPath, storageLimit, gasLimit, entrypoint, undefined);\n    });\n  }\n\n  TezosNodeWriter.sendContractPing = sendContractPing;\n\n  function sendKeyRevealOperation(server, keyStore, fee = TezosConstants_1.TezosConstants.DefaultKeyRevealFee, derivationPath = '') {\n    return __awaiter(this, void 0, void 0, function* () {\n      const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n      const revealOp = {\n        kind: 'reveal',\n        source: keyStore.publicKeyHash,\n        fee: fee + '',\n        counter: counter.toString(),\n        gas_limit: '10000',\n        storage_limit: '0',\n        public_key: keyStore.publicKey\n      };\n      const operations = [revealOp];\n      return sendOperation(server, operations, keyStore, derivationPath);\n    });\n  }\n\n  TezosNodeWriter.sendKeyRevealOperation = sendKeyRevealOperation;\n\n  function sendIdentityActivationOperation(server, keyStore, activationCode) {\n    const activation = {\n      kind: 'activate_account',\n      pkh: keyStore.publicKeyHash,\n      secret: activationCode\n    };\n    return sendOperation(server, [activation], keyStore, '');\n  }\n\n  TezosNodeWriter.sendIdentityActivationOperation = sendIdentityActivationOperation;\n\n  function testContractInvocationOperation(server, chainid, keyStore, contract, amount, fee, storageLimit, gasLimit, entrypoint, parameters, parameterFormat = TezosTypes.TezosParameterFormat.Micheline) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n      const transaction = constructContractInvocationOperation(keyStore.publicKeyHash, counter, contract, amount, fee, storageLimit, gasLimit, entrypoint, parameters, parameterFormat);\n      return estimateOperation(server, chainid, transaction);\n    });\n  }\n\n  TezosNodeWriter.testContractInvocationOperation = testContractInvocationOperation;\n\n  function testContractDeployOperation(server, chainid, keyStore, amount, delegate, fee, storageLimit, gasLimit, code, storage, codeFormat = TezosTypes.TezosParameterFormat.Micheline) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n      const transaction = constructContractOriginationOperation(keyStore, amount, delegate, fee, storageLimit, gasLimit, code, storage, codeFormat, counter);\n      const resources = yield estimateOperation(server, chainid, transaction);\n      const fixedOriginationStorageCost = 257;\n      return {\n        gas: resources.gas,\n        storageCost: resources.storageCost + fixedOriginationStorageCost\n      };\n    });\n  }\n\n  TezosNodeWriter.testContractDeployOperation = testContractDeployOperation;\n\n  function estimateOperation(server, chainid, operation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const fake_signature = 'edsigu6xFLH2NpJ1VcYshpjW99Yc1TAL1m2XBqJyXrxcZQgBMo8sszw2zm626yjpA3pWMhjpsahLrWdmvX9cqhd4ZEUchuBuFYy';\n      const fake_chainid = 'NetXdQprcVkpaWU';\n      const fake_branch = 'BL94i2ShahPx3BoNs6tJdXDdGeoJ9ukwujUA2P8WJwULYNdimmq';\n      const response = yield performPostRequest(server, `chains/${chainid}/blocks/head/helpers/scripts/run_operation`, {\n        chain_id: fake_chainid,\n        operation: {\n          branch: fake_branch,\n          contents: [operation],\n          signature: fake_signature\n        }\n      });\n      const responseText = yield response.text();\n      parseRPCError(responseText);\n      const responseJSON = JSON.parse(responseText);\n      let gas = 0;\n      let storageCost = 0;\n\n      for (let c of responseJSON['contents']) {\n        try {\n          gas += parseInt(c['metadata']['operation_result']['consumed_gas']) || 0;\n          storageCost += parseInt(c['metadata']['operation_result']['paid_storage_size_diff']) || 0;\n        } catch (_a) {}\n\n        const internalOperations = c['metadata']['internal_operation_results'];\n\n        if (internalOperations === undefined) {\n          continue;\n        }\n\n        for (const internalOperation of internalOperations) {\n          const result = internalOperation['result'];\n          gas += parseInt(result['consumed_gas']) || 0;\n          storageCost += parseInt(result['paid_storage_size_diff']) || 0;\n        }\n      }\n\n      return {\n        gas,\n        storageCost\n      };\n    });\n  }\n\n  TezosNodeWriter.estimateOperation = estimateOperation;\n\n  function parseRPCError(response) {\n    let errors = '';\n\n    try {\n      const json = JSON.parse(response);\n      const arr = Array.isArray(json) ? json : [json];\n\n      if ('kind' in arr[0]) {\n        errors = arr.map(e => `(${e.kind}: ${e.id})`).join('');\n      } else if (arr.length === 1 && arr[0].contents.length === 1 && arr[0].contents[0].kind === 'activate_account') {} else {\n        errors = arr.map(r => r.contents).map(o => o.map(c => c.metadata.operation_result).filter(r => r.status !== 'applied').map(r => `${r.status}: ${r.errors.map(e => `(${e.kind}: ${e.id})`).join(', ')}\\n`)).join('');\n      }\n    } catch (err) {\n      if (response.startsWith('Failed to parse the request body: ')) {\n        errors = response.slice(34);\n      } else {\n        const hash = response.replace(/\\\"/g, '').replace(/\\n/, '');\n\n        if (hash.length === 51 && hash.charAt(0) === 'o') {} else {\n          log.error(`failed to parse errors: '${err}' from '${response}'\\n, PLEASE report this to the maintainers`);\n        }\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new Error(errors);\n    }\n  }\n})(TezosNodeWriter = exports.TezosNodeWriter || (exports.TezosNodeWriter = {}));","map":{"version":3,"sources":["../../../src/chain/tezos/TezosNodeWriter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst blakejs = __importStar(require(\"blakejs\"));\nconst KeyStore_1 = require(\"../../types/wallet/KeyStore\");\nconst TezosTypes = __importStar(require(\"../../types/tezos/TezosChainTypes\"));\nconst TezosConstants_1 = require(\"../../types/tezos/TezosConstants\");\nconst TezosNodeReader_1 = require(\"./TezosNodeReader\");\nconst TezosMessageCodec_1 = require(\"./TezosMessageCodec\");\nconst TezosMessageUtil_1 = require(\"./TezosMessageUtil\");\nconst TezosLanguageUtil_1 = require(\"./TezosLanguageUtil\");\nconst TezosOperationQueue_1 = require(\"./TezosOperationQueue\");\nconst CryptoUtils_1 = require(\"../../utils/CryptoUtils\");\nconst FetchSelector_1 = __importDefault(require(\"../../utils/FetchSelector\"));\nconst fetch = FetchSelector_1.default.getFetch();\nconst DeviceSelector_1 = __importDefault(require(\"../../utils/DeviceSelector\"));\nlet LedgerUtils = DeviceSelector_1.default.getLedgerUtils();\nconst LoggerSelector_1 = __importDefault(require(\"../../utils/LoggerSelector\"));\nconst log = LoggerSelector_1.default.getLogger();\nlet operationQueues = {};\nvar TezosNodeWriter;\n(function (TezosNodeWriter) {\n    function performPostRequest(server, command, payload = {}) {\n        const url = `${server}/${command}`;\n        const payloadStr = JSON.stringify(payload);\n        log.debug(`TezosNodeWriter.performPostRequest sending ${payloadStr}\\n->\\n${url}`);\n        return fetch(url, { method: 'post', body: payloadStr, headers: { 'content-type': 'application/json' } });\n    }\n    function signOperationGroup(forgedOperation, keyStore, derivationPath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const watermarkedForgedOperationBytesHex = TezosConstants_1.TezosConstants.OperationGroupWatermark + forgedOperation;\n            let opSignature;\n            switch (keyStore.storeType) {\n                case KeyStore_1.StoreType.Hardware:\n                    try {\n                        opSignature = yield LedgerUtils.signTezosOperation(derivationPath, watermarkedForgedOperationBytesHex);\n                    }\n                    catch (err) {\n                        log.error(`TezosNodeWriter.signOperationGroup could not communicate with device: ${JSON.stringify(err)}`);\n                        throw new Error(\"Failed to connect to the Ledger device\");\n                    }\n                    break;\n                default:\n                    const hashedWatermarkedOpBytes = CryptoUtils_1.CryptoUtils.simpleHash(Buffer.from(watermarkedForgedOperationBytesHex, 'hex'), 32);\n                    const privateKeyBytes = TezosMessageUtil_1.TezosMessageUtils.writeKeyWithHint(keyStore.privateKey, 'edsk');\n                    opSignature = yield CryptoUtils_1.CryptoUtils.signDetached(hashedWatermarkedOpBytes, privateKeyBytes);\n            }\n            const hexSignature = TezosMessageUtil_1.TezosMessageUtils.readSignatureWithHint(opSignature, 'edsig').toString();\n            const signedOpBytes = Buffer.concat([Buffer.from(forgedOperation, 'hex'), Buffer.from(opSignature)]);\n            return { bytes: signedOpBytes, signature: hexSignature.toString() };\n        });\n    }\n    TezosNodeWriter.signOperationGroup = signOperationGroup;\n    function forgeOperations(branch, operations) {\n        log.debug('TezosNodeWriter.forgeOperations:');\n        log.debug(JSON.stringify(operations));\n        let encoded = TezosMessageUtil_1.TezosMessageUtils.writeBranch(branch);\n        operations.forEach(m => encoded += TezosMessageCodec_1.TezosMessageCodec.encodeOperation(m));\n        return encoded;\n    }\n    TezosNodeWriter.forgeOperations = forgeOperations;\n    function forgeOperationsRemotely(server, blockHead, operations, chainid = 'main') {\n        return __awaiter(this, void 0, void 0, function* () {\n            log.debug('TezosNodeWriter.forgeOperations:');\n            log.debug(JSON.stringify(operations));\n            log.warn('forgeOperationsRemotely() is not intrinsically trustless');\n            const response = yield performPostRequest(server, `chains/${chainid}/blocks/head/helpers/forge/operations`, { branch: blockHead.hash, contents: operations });\n            const forgedOperation = yield response.text();\n            const ops = forgedOperation.replace(/\\n/g, '').replace(/['\"]+/g, '');\n            let optypes = Array.from(operations.map(o => o[\"kind\"]));\n            let validate = false;\n            for (let t in optypes) {\n                validate = ['reveal', 'transaction', 'delegation', 'origination'].includes(t);\n                if (validate) {\n                    break;\n                }\n            }\n            if (validate) {\n                const decoded = TezosMessageCodec_1.TezosMessageCodec.parseOperationGroup(ops);\n                for (let i = 0; i < operations.length; i++) {\n                    const clientop = operations[i];\n                    const serverop = decoded[i];\n                    if (clientop['kind'] === 'transaction') {\n                        if (serverop.kind !== clientop['kind'] || serverop.fee !== clientop['fee'] || serverop.amount !== clientop['amount'] || serverop.destination !== clientop['destination']) {\n                            throw new Error('Forged transaction failed validation.');\n                        }\n                    }\n                    else if (clientop['kind'] === 'delegation') {\n                        if (serverop.kind !== clientop['kind'] || serverop.fee !== clientop['fee'] || serverop.delegate !== clientop['delegate']) {\n                            throw new Error('Forged delegation failed validation.');\n                        }\n                    }\n                    else if (clientop['kind'] === 'origination') {\n                        if (serverop.kind !== clientop['kind'] || serverop.fee !== clientop['fee'] || serverop.balance !== clientop['balance'] || serverop.spendable !== clientop['spendable'] || serverop.delegatable !== clientop['delegatable'] || serverop.delegate !== clientop['delegate'] || serverop.script !== undefined) {\n                            throw new Error('Forged origination failed validation.');\n                        }\n                    }\n                }\n            }\n            return ops;\n        });\n    }\n    TezosNodeWriter.forgeOperationsRemotely = forgeOperationsRemotely;\n    function preapplyOperation(server, branch, protocol, operations, signedOpGroup, chainid = 'main') {\n        return __awaiter(this, void 0, void 0, function* () {\n            const payload = [{\n                    protocol: protocol,\n                    branch: branch,\n                    contents: operations,\n                    signature: signedOpGroup.signature\n                }];\n            const response = yield performPostRequest(server, `chains/${chainid}/blocks/head/helpers/preapply/operations`, payload);\n            const text = yield response.text();\n            let json;\n            try {\n                log.debug(`TezosNodeWriter.preapplyOperation received ${text}`);\n                json = JSON.parse(text);\n            }\n            catch (err) {\n                log.error(`TezosNodeWriter.preapplyOperation failed to parse response`);\n                throw new Error(`Could not parse JSON from response of chains/${chainid}/blocks/head/helpers/preapply/operation: '${text}' for ${payload}`);\n            }\n            parseRPCError(text);\n            return json;\n        });\n    }\n    TezosNodeWriter.preapplyOperation = preapplyOperation;\n    function injectOperation(server, signedOpGroup, chainid = 'main') {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield performPostRequest(server, `injection/operation?chain=${chainid}`, signedOpGroup.bytes.toString('hex'));\n            const text = yield response.text();\n            parseRPCError(text);\n            return text;\n        });\n    }\n    TezosNodeWriter.injectOperation = injectOperation;\n    function sendOperation(server, operations, keyStore, derivationPath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const blockHead = yield TezosNodeReader_1.TezosNodeReader.getBlockHead(server);\n            const forgedOperationGroup = forgeOperations(blockHead.hash, operations);\n            const signedOpGroup = yield signOperationGroup(forgedOperationGroup, keyStore, derivationPath);\n            const appliedOp = yield preapplyOperation(server, blockHead.hash, blockHead.protocol, operations, signedOpGroup);\n            const injectedOperation = yield injectOperation(server, signedOpGroup);\n            return { results: appliedOp[0], operationGroupID: injectedOperation };\n        });\n    }\n    TezosNodeWriter.sendOperation = sendOperation;\n    function queueOperation(server, operations, keyStore, derivationPath = '', batchDelay = 25) {\n        const k = blakejs.blake2s(`${server}${keyStore.publicKeyHash}${derivationPath}`, null, 16);\n        if (!!!operationQueues[k]) {\n            operationQueues[k] = TezosOperationQueue_1.TezosOperationQueue.createQueue(server, derivationPath, keyStore, batchDelay);\n        }\n        operationQueues[k].addOperations(...operations);\n    }\n    TezosNodeWriter.queueOperation = queueOperation;\n    function getQueueStatus(server, keyStore, derivationPath = '') {\n        const k = blakejs.blake2s(`${server}${keyStore.publicKeyHash}${derivationPath}`, null, 16);\n        if (operationQueues[k]) {\n            return operationQueues[k].getStatus();\n        }\n        return -1;\n    }\n    TezosNodeWriter.getQueueStatus = getQueueStatus;\n    function appendRevealOperation(server, keyStore, accountHash, accountOperationIndex, operations) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const isKeyRevealed = yield TezosNodeReader_1.TezosNodeReader.isManagerKeyRevealedForAccount(server, accountHash);\n            const counter = accountOperationIndex + 1;\n            if (!isKeyRevealed) {\n                const revealOp = {\n                    kind: 'reveal',\n                    source: accountHash,\n                    fee: '0',\n                    counter: counter.toString(),\n                    gas_limit: '10600',\n                    storage_limit: '0',\n                    public_key: keyStore.publicKey\n                };\n                operations.forEach((operation, index) => {\n                    const c = accountOperationIndex + 2 + index;\n                    operation.counter = c.toString();\n                });\n                return [revealOp, ...operations];\n            }\n            return operations;\n        });\n    }\n    TezosNodeWriter.appendRevealOperation = appendRevealOperation;\n    function sendTransactionOperation(server, keyStore, to, amount, fee, derivationPath = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n            const transaction = {\n                destination: to,\n                amount: amount.toString(),\n                storage_limit: TezosConstants_1.TezosConstants.DefaultTransactionStorageLimit + '',\n                gas_limit: TezosConstants_1.TezosConstants.DefaultTransactionGasLimit + '',\n                counter: counter.toString(),\n                fee: fee.toString(),\n                source: keyStore.publicKeyHash,\n                kind: 'transaction'\n            };\n            const operations = yield appendRevealOperation(server, keyStore, keyStore.publicKeyHash, counter - 1, [transaction]);\n            return sendOperation(server, operations, keyStore, derivationPath);\n        });\n    }\n    TezosNodeWriter.sendTransactionOperation = sendTransactionOperation;\n    function sendDelegationOperation(server, keyStore, delegate, fee = TezosConstants_1.TezosConstants.DefaultDelegationFee, derivationPath = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n            const delegation = {\n                kind: 'delegation',\n                source: keyStore.publicKeyHash,\n                fee: fee.toString(),\n                counter: counter.toString(),\n                storage_limit: TezosConstants_1.TezosConstants.DefaultDelegationStorageLimit + '',\n                gas_limit: TezosConstants_1.TezosConstants.DefaultDelegationGasLimit + '',\n                delegate: delegate\n            };\n            const operations = yield appendRevealOperation(server, keyStore, keyStore.publicKeyHash, counter - 1, [delegation]);\n            return sendOperation(server, operations, keyStore, derivationPath);\n        });\n    }\n    TezosNodeWriter.sendDelegationOperation = sendDelegationOperation;\n    function sendUndelegationOperation(server, keyStore, fee = TezosConstants_1.TezosConstants.DefaultDelegationFee, derivationPath = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            return sendDelegationOperation(server, keyStore, undefined, fee, derivationPath);\n        });\n    }\n    TezosNodeWriter.sendUndelegationOperation = sendUndelegationOperation;\n    function sendContractOriginationOperation(server, keyStore, amount, delegate, fee, derivationPath, storageLimit, gasLimit, code, storage, codeFormat = TezosTypes.TezosParameterFormat.Micheline) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n            const operation = constructContractOriginationOperation(keyStore, amount, delegate, fee, storageLimit, gasLimit, code, storage, codeFormat, counter);\n            const operations = yield appendRevealOperation(server, keyStore, keyStore.publicKeyHash, counter - 1, [operation]);\n            return sendOperation(server, operations, keyStore, derivationPath);\n        });\n    }\n    TezosNodeWriter.sendContractOriginationOperation = sendContractOriginationOperation;\n    function constructContractOriginationOperation(keyStore, amount, delegate, fee, storageLimit, gasLimit, code, storage, codeFormat, counter) {\n        let parsedCode = undefined;\n        let parsedStorage = undefined;\n        if (codeFormat === TezosTypes.TezosParameterFormat.Michelson) {\n            parsedCode = JSON.parse(TezosLanguageUtil_1.TezosLanguageUtil.translateMichelsonToMicheline(code));\n            log.debug(`TezosNodeWriter.sendOriginationOperation code translation:\\n${code}\\n->\\n${JSON.stringify(parsedCode)}`);\n            parsedStorage = JSON.parse(TezosLanguageUtil_1.TezosLanguageUtil.translateMichelsonToMicheline(storage));\n            log.debug(`TezosNodeWriter.sendOriginationOperation storage translation:\\n${storage}\\n->\\n${JSON.stringify(parsedStorage)}`);\n        }\n        else if (codeFormat === TezosTypes.TezosParameterFormat.Micheline) {\n            parsedCode = JSON.parse(code);\n            parsedStorage = JSON.parse(storage);\n        }\n        return {\n            kind: 'origination',\n            source: keyStore.publicKeyHash,\n            fee: fee.toString(),\n            counter: counter.toString(),\n            gas_limit: gasLimit.toString(),\n            storage_limit: storageLimit.toString(),\n            balance: amount.toString(),\n            delegate: delegate,\n            script: { code: parsedCode, storage: parsedStorage }\n        };\n    }\n    TezosNodeWriter.constructContractOriginationOperation = constructContractOriginationOperation;\n    function sendContractInvocationOperation(server, keyStore, contract, amount, fee, derivationPath, storageLimit, gasLimit, entrypoint, parameters, parameterFormat = TezosTypes.TezosParameterFormat.Micheline) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n            const transaction = constructContractInvocationOperation(keyStore.publicKeyHash, counter, contract, amount, fee, storageLimit, gasLimit, entrypoint, parameters, parameterFormat);\n            const operations = yield appendRevealOperation(server, keyStore, keyStore.publicKeyHash, counter - 1, [transaction]);\n            return sendOperation(server, operations, keyStore, derivationPath);\n        });\n    }\n    TezosNodeWriter.sendContractInvocationOperation = sendContractInvocationOperation;\n    function constructContractInvocationOperation(publicKeyHash, counter, to, amount, fee, storageLimit, gasLimit, entrypoint, parameters, parameterFormat = TezosTypes.TezosParameterFormat.Micheline) {\n        let transaction = {\n            destination: to,\n            amount: amount.toString(),\n            storage_limit: storageLimit.toString(),\n            gas_limit: gasLimit.toString(),\n            counter: counter.toString(),\n            fee: fee.toString(),\n            source: publicKeyHash,\n            kind: 'transaction'\n        };\n        if (parameters !== undefined) {\n            if (parameterFormat === TezosTypes.TezosParameterFormat.Michelson) {\n                const michelineParams = TezosLanguageUtil_1.TezosLanguageUtil.translateParameterMichelsonToMicheline(parameters);\n                transaction.parameters = { entrypoint: entrypoint || 'default', value: JSON.parse(michelineParams) };\n            }\n            else if (parameterFormat === TezosTypes.TezosParameterFormat.Micheline) {\n                transaction.parameters = { entrypoint: entrypoint || 'default', value: JSON.parse(parameters) };\n            }\n            else if (parameterFormat === TezosTypes.TezosParameterFormat.MichelsonLambda) {\n                const michelineLambda = TezosLanguageUtil_1.TezosLanguageUtil.translateMichelsonToMicheline(`code ${parameters}`);\n                transaction.parameters = { entrypoint: entrypoint || 'default', value: JSON.parse(michelineLambda) };\n            }\n        }\n        else if (entrypoint !== undefined) {\n            transaction.parameters = { entrypoint: entrypoint, value: [] };\n        }\n        return transaction;\n    }\n    TezosNodeWriter.constructContractInvocationOperation = constructContractInvocationOperation;\n    function sendContractPing(server, keyStore, to, fee, derivationPath, storageLimit, gasLimit, entrypoint) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return sendContractInvocationOperation(server, keyStore, to, 0, fee, derivationPath, storageLimit, gasLimit, entrypoint, undefined);\n        });\n    }\n    TezosNodeWriter.sendContractPing = sendContractPing;\n    function sendKeyRevealOperation(server, keyStore, fee = TezosConstants_1.TezosConstants.DefaultKeyRevealFee, derivationPath = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n            const revealOp = {\n                kind: 'reveal',\n                source: keyStore.publicKeyHash,\n                fee: fee + '',\n                counter: counter.toString(),\n                gas_limit: '10000',\n                storage_limit: '0',\n                public_key: keyStore.publicKey\n            };\n            const operations = [revealOp];\n            return sendOperation(server, operations, keyStore, derivationPath);\n        });\n    }\n    TezosNodeWriter.sendKeyRevealOperation = sendKeyRevealOperation;\n    function sendIdentityActivationOperation(server, keyStore, activationCode) {\n        const activation = { kind: 'activate_account', pkh: keyStore.publicKeyHash, secret: activationCode };\n        return sendOperation(server, [activation], keyStore, '');\n    }\n    TezosNodeWriter.sendIdentityActivationOperation = sendIdentityActivationOperation;\n    function testContractInvocationOperation(server, chainid, keyStore, contract, amount, fee, storageLimit, gasLimit, entrypoint, parameters, parameterFormat = TezosTypes.TezosParameterFormat.Micheline) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n            const transaction = constructContractInvocationOperation(keyStore.publicKeyHash, counter, contract, amount, fee, storageLimit, gasLimit, entrypoint, parameters, parameterFormat);\n            return estimateOperation(server, chainid, transaction);\n        });\n    }\n    TezosNodeWriter.testContractInvocationOperation = testContractInvocationOperation;\n    function testContractDeployOperation(server, chainid, keyStore, amount, delegate, fee, storageLimit, gasLimit, code, storage, codeFormat = TezosTypes.TezosParameterFormat.Micheline) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(server, keyStore.publicKeyHash)) + 1;\n            const transaction = constructContractOriginationOperation(keyStore, amount, delegate, fee, storageLimit, gasLimit, code, storage, codeFormat, counter);\n            const resources = yield estimateOperation(server, chainid, transaction);\n            const fixedOriginationStorageCost = 257;\n            return {\n                gas: resources.gas,\n                storageCost: resources.storageCost + fixedOriginationStorageCost\n            };\n        });\n    }\n    TezosNodeWriter.testContractDeployOperation = testContractDeployOperation;\n    function estimateOperation(server, chainid, operation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const fake_signature = 'edsigu6xFLH2NpJ1VcYshpjW99Yc1TAL1m2XBqJyXrxcZQgBMo8sszw2zm626yjpA3pWMhjpsahLrWdmvX9cqhd4ZEUchuBuFYy';\n            const fake_chainid = 'NetXdQprcVkpaWU';\n            const fake_branch = 'BL94i2ShahPx3BoNs6tJdXDdGeoJ9ukwujUA2P8WJwULYNdimmq';\n            const response = yield performPostRequest(server, `chains/${chainid}/blocks/head/helpers/scripts/run_operation`, { chain_id: fake_chainid, operation: { branch: fake_branch, contents: [operation], signature: fake_signature } });\n            const responseText = yield response.text();\n            parseRPCError(responseText);\n            const responseJSON = JSON.parse(responseText);\n            let gas = 0;\n            let storageCost = 0;\n            for (let c of responseJSON['contents']) {\n                try {\n                    gas += parseInt(c['metadata']['operation_result']['consumed_gas']) || 0;\n                    storageCost += parseInt(c['metadata']['operation_result']['paid_storage_size_diff']) || 0;\n                }\n                catch (_a) { }\n                const internalOperations = c['metadata']['internal_operation_results'];\n                if (internalOperations === undefined) {\n                    continue;\n                }\n                for (const internalOperation of internalOperations) {\n                    const result = internalOperation['result'];\n                    gas += parseInt(result['consumed_gas']) || 0;\n                    storageCost += parseInt(result['paid_storage_size_diff']) || 0;\n                }\n            }\n            return { gas, storageCost };\n        });\n    }\n    TezosNodeWriter.estimateOperation = estimateOperation;\n    function parseRPCError(response) {\n        let errors = '';\n        try {\n            const json = JSON.parse(response);\n            const arr = Array.isArray(json) ? json : [json];\n            if ('kind' in arr[0]) {\n                errors = arr.map(e => `(${e.kind}: ${e.id})`).join('');\n            }\n            else if (arr.length === 1 && arr[0].contents.length === 1 && arr[0].contents[0].kind === 'activate_account') {\n            }\n            else {\n                errors = arr.map(r => r.contents)\n                    .map(o => o.map(c => c.metadata.operation_result)\n                    .filter(r => r.status !== 'applied')\n                    .map(r => `${r.status}: ${r.errors.map(e => `(${e.kind}: ${e.id})`).join(', ')}\\n`))\n                    .join('');\n            }\n        }\n        catch (err) {\n            if (response.startsWith('Failed to parse the request body: ')) {\n                errors = response.slice(34);\n            }\n            else {\n                const hash = response.replace(/\\\"/g, '').replace(/\\n/, '');\n                if (hash.length === 51 && hash.charAt(0) === 'o') {\n                }\n                else {\n                    log.error(`failed to parse errors: '${err}' from '${response}'\\n, PLEASE report this to the maintainers`);\n                }\n            }\n        }\n        if (errors.length > 0) {\n            throw new Error(errors);\n        }\n    }\n})(TezosNodeWriter = exports.TezosNodeWriter || (exports.TezosNodeWriter = {}));\n//# sourceMappingURL=TezosNodeWriter.js.map"]},"metadata":{},"sourceType":"script"}