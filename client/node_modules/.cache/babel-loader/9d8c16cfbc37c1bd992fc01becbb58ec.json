{"ast":null,"code":"/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\nvar ScanError =\n/** @class */\nfunction (_super) {\n  __extends(ScanError, _super);\n\n  function ScanError(src, idx, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.src = src;\n    _this.idx = idx;\n    return _this;\n  }\n\n  return ScanError;\n}(Error);\n\nvar Literal;\n\n(function (Literal) {\n  Literal[Literal[\"Comment\"] = 0] = \"Comment\";\n  Literal[Literal[\"Number\"] = 1] = \"Number\";\n  Literal[Literal[\"String\"] = 2] = \"String\";\n  Literal[Literal[\"Bytes\"] = 3] = \"Bytes\";\n  Literal[Literal[\"Ident\"] = 4] = \"Ident\";\n})(Literal || (Literal = {}));\n\nvar isSpace = new RegExp(\"\\\\s\");\nvar isIdentStart = new RegExp(\"[:@%_A-Za-z]\");\nvar isIdent = new RegExp(\"[@%_\\\\.A-Za-z0-9]\");\nvar isDigit = new RegExp(\"[0-9]\");\nvar isHex = new RegExp(\"[0-9a-fA-F]\");\n\nfunction scan(src, scanComments) {\n  var i, s, start, ii, esc;\n\n  if (scanComments === void 0) {\n    scanComments = false;\n  }\n\n  return __generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        i = 0;\n        _a.label = 1;\n\n      case 1:\n        if (!(i < src.length)) return [3\n        /*break*/\n        , 16]; // Skip space\n\n        while (i < src.length && isSpace.test(src[i])) {\n          i++;\n        }\n\n        if (i === src.length) {\n          return [2\n          /*return*/\n          ];\n        }\n\n        s = src[i];\n        start = i;\n        if (!isIdentStart.test(s)) return [3\n        /*break*/\n        , 3]; // Identifier\n\n        i++;\n\n        while (i < src.length && isIdent.test(src[i])) {\n          i++;\n        }\n\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Ident,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 2:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 3:\n        if (!(src.length - i > 1 && src.substr(i, 2) === \"0x\")) return [3\n        /*break*/\n        , 5]; // Bytes\n\n        i += 2;\n\n        while (i < src.length && isHex.test(src[i])) {\n          i++;\n        }\n\n        if (i - start === 2) {\n          throw new ScanError(src, i, \"Bytes literal is too short\");\n        } else if ((i - start & 1) !== 0) {\n          throw new ScanError(src, i, \"Bytes literal length is expected to be power of two\");\n        }\n\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Bytes,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 4:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 5:\n        if (!(isDigit.test(s) || s === \"-\")) return [3\n        /*break*/\n        , 7]; // Number\n\n        if (s === \"-\") {\n          i++;\n        }\n\n        ii = i;\n\n        while (i < src.length && isDigit.test(src[i])) {\n          i++;\n        }\n\n        if (ii === i) {\n          throw new ScanError(src, i, \"Number literal is too short\");\n        }\n\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Number,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 6:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 7:\n        if (!(s === \"\\\"\")) return [3\n        /*break*/\n        , 9]; // String\n\n        i++;\n        esc = false;\n\n        for (; i < src.length && (esc || src[i] !== \"\\\"\"); i++) {\n          if (!esc && src[i] === \"\\\\\") {\n            esc = true;\n          } else {\n            esc = false;\n          }\n        }\n\n        if (i === src.length) {\n          throw new ScanError(src, i, \"Unterminated string literal\");\n        }\n\n        i++;\n        return [4\n        /*yield*/\n        , {\n          t: Literal.String,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 8:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 9:\n        if (!(s === \"#\")) return [3\n        /*break*/\n        , 12]; // Comment\n\n        i++;\n\n        while (i < src.length && src[i] !== \"\\n\") {\n          i++;\n        }\n\n        if (!scanComments) return [3\n        /*break*/\n        , 11];\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Comment,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 10:\n        _a.sent();\n\n        _a.label = 11;\n\n      case 11:\n        return [3\n        /*break*/\n        , 15];\n\n      case 12:\n        if (!(s === \"(\" || s === \")\" || s === \"{\" || s === \"}\" || s === \";\")) return [3\n        /*break*/\n        , 14];\n        i++;\n        return [4\n        /*yield*/\n        , {\n          t: s,\n          v: s,\n          offset: i\n        }];\n\n      case 13:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 14:\n        throw new ScanError(src, i, \"Invalid character at offset \" + i + \": `\" + s + \"'\");\n\n      case 15:\n        return [3\n        /*break*/\n        , 1];\n\n      case 16:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n\nvar MacroError =\n/** @class */\nfunction (_super) {\n  __extends(MacroError, _super);\n\n  function MacroError(prim, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.prim = prim;\n    return _this;\n  }\n\n  return MacroError;\n}(Error);\n\nfunction assertArgs(ex, n) {\n  var _a, _b;\n\n  if (n === 0 && ex.args === undefined || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\n    return true;\n  }\n\n  throw new MacroError(ex, \"macro \" + ex.prim + \" expects \" + n + \" arguments, was given \" + ((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length));\n}\n\nfunction assertNoAnnots(ex) {\n  if (ex.annots === undefined) {\n    return true;\n  }\n\n  throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + ex.annots);\n}\n\nfunction assertIntArg(ex, arg) {\n  if (\"int\" in arg) {\n    return true;\n  }\n\n  throw new MacroError(ex, \"macro \" + ex.prim + \" expects int argument\");\n}\n\nfunction parsePairUnpairExpr(p, expr, annotations, agg) {\n  var res = [];\n  var i = 0;\n  var ai = 0;\n  var ann = [null, null]; // Left expression\n\n  if (i === expr.length) {\n    throw new MacroError(p, \"unexpected end: \" + p.prim);\n  }\n\n  var c = expr[i++];\n\n  switch (c) {\n    case \"P\":\n      var _a = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg),\n          r = _a.r,\n          n = _a.n,\n          an = _a.an;\n\n      res.push.apply(res, __spread(r));\n      i += n;\n      ai += an;\n      break;\n\n    case \"A\":\n      if (ai !== annotations.length) {\n        ann[0] = annotations[ai++];\n      }\n\n      break;\n\n    default:\n      throw new MacroError(p, p.prim + \": unexpected character: \" + c);\n  } // Right expression\n\n\n  if (i === expr.length) {\n    throw new MacroError(p, \"unexpected end: \" + p.prim);\n  }\n\n  c = expr[i++];\n\n  switch (c) {\n    case \"P\":\n      var _b = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg),\n          r = _b.r,\n          n = _b.n,\n          an = _b.an;\n\n      res.push.apply(res, __spread(r.map(function (_a) {\n        var _b = __read(_a, 2),\n            v = _b[0],\n            a = _b[1];\n\n        return [v + 1, a];\n      })));\n      i += n;\n      ai += an;\n      break;\n\n    case \"I\":\n      if (ai !== annotations.length) {\n        ann[1] = annotations[ai++];\n      }\n\n      break;\n\n    default:\n      throw new MacroError(p, p.prim + \": unexpected character: \" + c);\n  }\n\n  return {\n    r: agg(res, [0, ann]),\n    n: i,\n    an: ai\n  };\n}\n\nfunction parseSetMapCadr(p, expr, vann, term) {\n  var c = expr[0];\n\n  switch (c) {\n    case \"A\":\n      return expr.length > 1 ? [{\n        prim: \"DUP\"\n      }, {\n        prim: \"DIP\",\n        args: [[{\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, parseSetMapCadr(p, expr.slice(1), [], term)]]\n      }, {\n        prim: \"CDR\",\n        annots: [\"@%%\"]\n      }, {\n        prim: \"SWAP\"\n      }, {\n        prim: \"PAIR\",\n        annots: __spread([\"%@\", \"%@\"], vann)\n      }] : term.a;\n\n    case \"D\":\n      return expr.length > 1 ? [{\n        prim: \"DUP\"\n      }, {\n        prim: \"DIP\",\n        args: [[{\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, parseSetMapCadr(p, expr.slice(1), [], term)]]\n      }, {\n        prim: \"CAR\",\n        annots: [\"@%%\"]\n      }, {\n        prim: \"PAIR\",\n        annots: __spread([\"%@\", \"%@\"], vann)\n      }] : term.d;\n\n    default:\n      throw new MacroError(p, p.prim + \": unexpected character: \" + c);\n  }\n}\n\nfunction trimLast(a, v) {\n  var l = a.length;\n\n  while (l > 0 && a[l - 1] === v) {\n    l--;\n  }\n\n  return a.slice(0, l);\n}\n\nfunction filterAnnotations(a) {\n  var e_1, _a;\n\n  var fields = [];\n  var rest = [];\n\n  if (a !== undefined) {\n    try {\n      for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {\n        var v = a_1_1.value;\n        (v.length !== 0 && v[0] === \"%\" ? fields : rest).push(v);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  return {\n    fields: fields,\n    rest: rest\n  };\n}\n\nfunction mkPrim(_a) {\n  var prim = _a.prim,\n      annots = _a.annots,\n      args = _a.args;\n  return __assign(__assign({\n    prim: prim\n  }, annots && {\n    annots: annots\n  }), args && {\n    args: args\n  });\n}\n\nvar pairRe = /^P[PAI]{3,}R$/;\nvar unpairRe = /^UNP[PAI]{2,}R$/;\nvar cadrRe = /^C[AD]{2,}R$/;\nvar setCadrRe = /^SET_C[AD]+R$/;\nvar mapCadrRe = /^MAP_C[AD]+R$/;\nvar diipRe = /^DI{2,}P$/;\nvar duupRe = /^DU+P$/;\n\nfunction expandMacros(ex) {\n  function mayRename(annots) {\n    return annots !== undefined ? [{\n      prim: \"RENAME\",\n      annots: annots\n    }] : [];\n  }\n\n  switch (ex.prim) {\n    // Compare\n    case \"CMPEQ\":\n    case \"CMPNEQ\":\n    case \"CMPLT\":\n    case \"CMPGT\":\n    case \"CMPLE\":\n    case \"CMPGE\":\n      if (assertArgs(ex, 0)) {\n        return [{\n          prim: \"COMPARE\"\n        }, mkPrim({\n          prim: ex.prim.slice(3),\n          annots: ex.annots\n        })];\n      }\n\n      break;\n\n    case \"IFEQ\":\n    case \"IFNEQ\":\n    case \"IFLT\":\n    case \"IFGT\":\n    case \"IFLE\":\n    case \"IFGE\":\n      if (assertArgs(ex, 2)) {\n        return [{\n          prim: ex.prim.slice(2)\n        }, mkPrim({\n          prim: \"IF\",\n          annots: ex.annots,\n          args: ex.args\n        })];\n      }\n\n      break;\n\n    case \"IFCMPEQ\":\n    case \"IFCMPNEQ\":\n    case \"IFCMPLT\":\n    case \"IFCMPGT\":\n    case \"IFCMPLE\":\n    case \"IFCMPGE\":\n      if (assertArgs(ex, 2)) {\n        return [{\n          prim: \"COMPARE\"\n        }, {\n          prim: ex.prim.slice(5)\n        }, mkPrim({\n          prim: \"IF\",\n          annots: ex.annots,\n          args: ex.args\n        })];\n      }\n\n      break;\n    // Fail\n\n    case \"FAIL\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: \"UNIT\"\n        }, {\n          prim: \"FAILWITH\"\n        }];\n      }\n\n      break;\n    // Assertion macros\n\n    case \"ASSERT\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: \"IF\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_EQ\":\n    case \"ASSERT_NEQ\":\n    case \"ASSERT_LT\":\n    case \"ASSERT_GT\":\n    case \"ASSERT_LE\":\n    case \"ASSERT_GE\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: ex.prim.slice(7)\n        }, {\n          prim: \"IF\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_CMPEQ\":\n    case \"ASSERT_CMPNEQ\":\n    case \"ASSERT_CMPLT\":\n    case \"ASSERT_CMPGT\":\n    case \"ASSERT_CMPLE\":\n    case \"ASSERT_CMPGE\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [[{\n          prim: \"COMPARE\"\n        }, {\n          prim: ex.prim.slice(10)\n        }], {\n          prim: \"IF\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_NONE\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: \"IF_NONE\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_SOME\":\n      if (assertArgs(ex, 0)) {\n        return [{\n          prim: \"IF_NONE\",\n          args: [[[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]], mayRename(ex.annots)]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_LEFT\":\n      if (assertArgs(ex, 0)) {\n        return [{\n          prim: \"IF_LEFT\",\n          args: [mayRename(ex.annots), [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_RIGHT\":\n      if (assertArgs(ex, 0)) {\n        return [{\n          prim: \"IF_LEFT\",\n          args: [[[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]], mayRename(ex.annots)]\n        }];\n      }\n\n      break;\n    // Syntactic conveniences\n\n    case \"IF_SOME\":\n      if (assertArgs(ex, 2)) {\n        return [mkPrim({\n          prim: \"IF_NONE\",\n          annots: ex.annots,\n          args: [ex.args[1], ex.args[0]]\n        })];\n      }\n\n      break;\n\n    case \"IF_RIGHT\":\n      if (assertArgs(ex, 2)) {\n        return [mkPrim({\n          prim: \"IF_LEFT\",\n          annots: ex.annots,\n          args: [ex.args[1], ex.args[0]]\n        })];\n      }\n\n  } // More syntactic conveniences\n  // PAPPAIIR macro\n\n\n  if (pairRe.test(ex.prim)) {\n    if (assertArgs(ex, 0)) {\n      var _a = filterAnnotations(ex.annots),\n          fields = _a.fields,\n          rest_1 = _a.rest;\n\n      var r_1 = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, function (a, v) {\n        return __spread(a, [v]);\n      }).r;\n      return r_1.map(function (_a, i) {\n        var _b = __read(_a, 2),\n            v = _b[0],\n            a = _b[1];\n\n        var ann = __spread(trimLast(a, null).map(function (v) {\n          return v === null ? \"%\" : v;\n        }), v === 0 && i === r_1.length - 1 ? rest_1 : []);\n\n        var leaf = mkPrim({\n          prim: \"PAIR\",\n          annots: ann.length !== 0 ? ann : undefined\n        });\n        return v === 0 ? leaf : {\n          prim: \"DIP\",\n          args: v === 1 ? [[leaf]] : [{\n            int: String(v)\n          }, [leaf]]\n        };\n      });\n    }\n  } // UNPAPPAIIR macro\n\n\n  if (unpairRe.test(ex.prim)) {\n    if (assertArgs(ex, 0)) {\n      var r = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], function (a, v) {\n        return __spread([v], a);\n      }).r;\n      return r.map(function (_a) {\n        var _b = __read(_a, 2),\n            v = _b[0],\n            a = _b[1];\n\n        var leaf = [{\n          prim: \"DUP\"\n        }, mkPrim({\n          prim: \"CAR\",\n          annots: a[0] !== null ? [a[0]] : undefined\n        }), {\n          prim: \"DIP\",\n          args: [[mkPrim({\n            prim: \"CDR\",\n            annots: a[1] !== null ? [a[1]] : undefined\n          })]]\n        }];\n        return v === 0 ? leaf : {\n          prim: \"DIP\",\n          args: v === 1 ? [[leaf]] : [{\n            int: String(v)\n          }, [leaf]]\n        };\n      });\n    }\n  } // C[AD]+R macro\n\n\n  if (cadrRe.test(ex.prim)) {\n    if (assertArgs(ex, 0)) {\n      var ch_1 = __spread(ex.prim.slice(1, ex.prim.length - 1));\n\n      return ch_1.map(function (c, i) {\n        var ann = i === ch_1.length - 1 ? ex.annots : undefined;\n\n        switch (c) {\n          case \"A\":\n            return mkPrim({\n              prim: \"CAR\",\n              annots: ann\n            });\n\n          case \"D\":\n            return mkPrim({\n              prim: \"CDR\",\n              annots: ann\n            });\n\n          default:\n            throw new MacroError(ex, \"unexpected character: \" + c);\n        }\n      });\n    }\n  } // SET_C[AD]+R macro\n\n\n  if (setCadrRe.test(ex.prim)) {\n    if (assertArgs(ex, 0)) {\n      var _b = filterAnnotations(ex.annots),\n          fields = _b.fields,\n          rest = _b.rest;\n\n      if (fields.length > 1) {\n        throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + fields);\n      }\n\n      var term = fields.length !== 0 ? {\n        a: [{\n          prim: \"DUP\"\n        }, {\n          prim: \"CAR\",\n          annots: fields\n        }, {\n          prim: \"DROP\"\n        }, {\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"SWAP\"\n        }, {\n          prim: \"PAIR\",\n          annots: [fields[0], \"%@\"]\n        }],\n        d: [{\n          prim: \"DUP\"\n        }, {\n          prim: \"CDR\",\n          annots: fields\n        }, {\n          prim: \"DROP\"\n        }, {\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%@\", fields[0]]\n        }]\n      } : {\n        a: [{\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"SWAP\"\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%\", \"%@\"]\n        }],\n        d: [{\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%@\", \"%\"]\n        }]\n      };\n      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);\n    }\n  } // MAP_C[AD]+R macro\n\n\n  if (mapCadrRe.test(ex.prim)) {\n    if (assertArgs(ex, 1)) {\n      var fields = filterAnnotations(ex.annots).fields;\n\n      if (fields.length > 1) {\n        throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + fields);\n      }\n\n      var term = {\n        a: [{\n          prim: \"DUP\"\n        }, {\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"DIP\",\n          args: [[mkPrim({\n            prim: \"CAR\",\n            annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined\n          }), ex.args[0]]]\n        }, {\n          prim: \"SWAP\"\n        }, {\n          prim: \"PAIR\",\n          annots: [fields.length !== 0 ? fields[0] : \"%\", \"%@\"]\n        }],\n        d: [{\n          prim: \"DUP\"\n        }, mkPrim({\n          prim: \"CDR\",\n          annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined\n        }), ex.args[0], {\n          prim: \"SWAP\"\n        }, {\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%@\", fields.length !== 0 ? fields[0] : \"%\"]\n        }]\n      };\n      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);\n    }\n  } // Expand deprecated DI...IP to [DIP n]\n\n\n  if (diipRe.test(ex.prim)) {\n    if (assertArgs(ex, 1)) {\n      var n = 0;\n\n      while (ex.prim[1 + n] === \"I\") {\n        n++;\n      }\n\n      return mkPrim({\n        prim: \"DIP\",\n        args: [{\n          int: String(n)\n        }, ex.args[0]]\n      });\n    }\n  } // Expand modern DUP n or deprecated DU...UP\n\n\n  if (duupRe.test(ex.prim)) {\n    var n = 0;\n\n    while (ex.prim[1 + n] === \"U\") {\n      n++;\n    }\n\n    if (n === 1) {\n      if (ex.args === undefined) {\n        return ex; // skip\n      }\n\n      if (assertArgs(ex, 1) && assertIntArg(ex, ex.args[0])) {\n        n = parseInt(ex.args[0].int, 10);\n      }\n    } else {\n      assertArgs(ex, 0);\n    }\n\n    if (n === 1) {\n      return [mkPrim({\n        prim: \"DUP\",\n        annots: ex.annots\n      })];\n    } else if (n === 2) {\n      return [{\n        prim: \"DIP\",\n        args: [[mkPrim({\n          prim: \"DUP\",\n          annots: ex.annots\n        })]]\n      }, {\n        prim: \"SWAP\"\n      }];\n    } else {\n      return [{\n        prim: \"DIP\",\n        args: [{\n          int: String(n - 1)\n        }, [mkPrim({\n          prim: \"DUP\",\n          annots: ex.annots\n        })]]\n      }, {\n        prim: \"DIG\",\n        args: [{\n          int: String(n)\n        }]\n      }];\n    }\n  }\n\n  return ex;\n}\n\nvar MichelineParseError =\n/** @class */\nfunction (_super) {\n  __extends(MichelineParseError, _super);\n  /**\r\n   * @param token A token caused the error\r\n   * @param message An error message\r\n   */\n\n\n  function MichelineParseError(token, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.token = token;\n    return _this;\n  }\n\n  return MichelineParseError;\n}(Error);\n\nvar JSONParseError =\n/** @class */\nfunction (_super) {\n  __extends(JSONParseError, _super);\n  /**\r\n   * @param node A node caused the error\r\n   * @param message An error message\r\n   */\n\n\n  function JSONParseError(node, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.node = node;\n    return _this;\n  }\n\n  return JSONParseError;\n}(Error);\n\nvar errEOF = new MichelineParseError(null, 'Unexpected EOF');\n\nfunction isAnnotation(tok) {\n  return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');\n}\n\nvar intRe = new RegExp('^-?[0-9]+$');\nvar bytesRe = new RegExp('^([0-9a-fA-F]{2})+$');\n/**\r\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\r\n *\r\n * Pretty Print a Michelson Smart Contract:\r\n * ```\r\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\r\n * const p = new Parser();\r\n *\r\n * const michelsonCode = p.parseJSON(contract.script.code);\r\n * const storage = p.parseJSON(contract.script.storage);\r\n *\r\n * console.log(\"Pretty print Michelson smart contract:\");\r\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\r\n *\r\n * console.log(\"Pretty print Storage:\");\r\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\r\n * ```\r\n *\r\n * Encode a Michelson expression for inital storage of a smart contract\r\n * ```\r\n * const src = `(Pair (Pair { Elt 1\r\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\r\n *                      0x0501000000026869) }\r\n *          10000000)\r\n *    (Pair 2 333))`;\r\n *\r\n * const p = new Parser();\r\n *\r\n * const exp = p.parseMichelineExpression(src);\r\n * console.log(JSON.stringify(exp));\r\n * ```\r\n */\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(opt) {\n    this.opt = opt;\n  }\n\n  Parser.prototype.expand = function (ex) {\n    var _a;\n\n    return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.expandMacros) ? expandMacros(ex) : ex;\n  };\n\n  Parser.prototype.parseList = function (scanner) {\n    var tok = scanner.next();\n\n    if (tok.done) {\n      throw errEOF;\n    }\n\n    if (tok.value.t !== Literal.Ident) {\n      throw new MichelineParseError(tok.value, \"List: not an identifier: \" + tok.value.v);\n    }\n\n    var ret = {\n      prim: tok.value.v\n    };\n\n    for (;;) {\n      var tok_1 = scanner.next();\n\n      if (tok_1.done) {\n        throw errEOF;\n      }\n\n      if (tok_1.value.t === ')') {\n        break;\n      }\n\n      if (isAnnotation(tok_1.value)) {\n        ret.annots = ret.annots || [];\n        ret.annots.push(tok_1.value.v);\n      } else {\n        ret.args = ret.args || [];\n        ret.args.push(this.parseExpr(scanner, tok_1.value));\n      }\n    }\n\n    return this.expand(ret);\n  };\n\n  Parser.prototype.parseArgs = function (scanner, prim, expectBracket) {\n    // Identifier with arguments\n    var p = {\n      prim: prim\n    };\n\n    for (;;) {\n      var t = scanner.next();\n\n      if (t.done) {\n        if (expectBracket) {\n          throw errEOF;\n        } else {\n          return [p, true];\n        }\n      } else if (t.value.t === '}') {\n        if (!expectBracket) {\n          throw new MichelineParseError(t.value, \"Seq: unexpected token: \" + t.value.v);\n        } else {\n          return [p, true];\n        }\n      } else if (t.value.t === ';') {\n        return [p, false];\n      }\n\n      if (isAnnotation(t.value)) {\n        p.annots = p.annots || [];\n        p.annots.push(t.value.v);\n      } else {\n        p.args = p.args || [];\n        p.args.push(this.parseExpr(scanner, t.value));\n      }\n    }\n  };\n\n  Parser.prototype.parseSequence = function (scanner, initialToken, expectBracket) {\n    var seq = [];\n\n    for (;;) {\n      var tok = void 0;\n\n      if (initialToken !== null) {\n        tok = initialToken;\n        initialToken = null;\n      } else {\n        var t = scanner.next();\n\n        if (t.done) {\n          if (expectBracket) {\n            throw errEOF;\n          } else {\n            return seq;\n          }\n        }\n\n        tok = t.value;\n      }\n\n      if (tok.t === '}') {\n        if (!expectBracket) {\n          throw new MichelineParseError(tok, \"Seq: unexpected token: \" + tok.v);\n        } else {\n          return seq;\n        }\n      } else if (tok.t === Literal.Ident) {\n        // Identifier with arguments\n        var _a = __read(this.parseArgs(scanner, tok.v, expectBracket), 2),\n            itm = _a[0],\n            done = _a[1];\n\n        seq.push(this.expand(itm));\n\n        if (done) {\n          return seq;\n        }\n      } else {\n        // Other\n        seq.push(this.parseExpr(scanner, tok));\n        var t = scanner.next();\n\n        if (t.done) {\n          if (expectBracket) {\n            throw errEOF;\n          } else {\n            return seq;\n          }\n        } else if (t.value.t === '}') {\n          if (!expectBracket) {\n            throw new MichelineParseError(t.value, \"Seq: unexpected token: \" + t.value.v);\n          } else {\n            return seq;\n          }\n        } else if (t.value.t !== ';') {\n          throw new MichelineParseError(t.value, \"Seq: unexpected token: \" + t.value.v);\n        }\n      }\n    }\n  };\n\n  Parser.prototype.parseExpr = function (scanner, tok) {\n    switch (tok.t) {\n      case Literal.Ident:\n        return this.expand({\n          prim: tok.v\n        });\n\n      case Literal.Number:\n        return {\n          int: tok.v\n        };\n\n      case Literal.String:\n        return {\n          string: JSON.parse(tok.v)\n        };\n\n      case Literal.Bytes:\n        return {\n          bytes: tok.v.substr(2)\n        };\n\n      case '(':\n        return this.parseList(scanner);\n\n      case '{':\n        return this.parseSequence(scanner, null, true);\n\n      default:\n        throw new MichelineParseError(tok, \"Expr: unexpected token: \" + tok.v);\n    }\n  };\n  /**\r\n   * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\r\n   * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\r\n   */\n\n\n  Parser.prototype.parseScript = function (src) {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof src !== \"string\") {\n      throw new TypeError(\"string type was expected, got \" + typeof src + \" instead\");\n    }\n\n    var scanner = scan(src);\n    var tok = scanner.next();\n\n    if (tok.done) {\n      return null;\n    }\n\n    return tok.value.t === '{' ? this.parseSequence(scanner, null, true) : this.parseSequence(scanner, tok.value, false);\n  };\n  /**\r\n   * Parse any Michelson expression\r\n   * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\r\n   * @returns An AST node or null for empty document.\r\n   */\n\n\n  Parser.prototype.parseMichelineExpression = function (src) {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof src !== \"string\") {\n      throw new TypeError(\"string type was expected, got \" + typeof src + \" instead\");\n    }\n\n    var scanner = scan(src);\n    var tok = scanner.next();\n\n    if (tok.done) {\n      return null;\n    }\n\n    return this.parseExpr(scanner, tok.value);\n  };\n  /**\r\n   * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\r\n   * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\r\n   */\n\n\n  Parser.prototype.parseJSON = function (src) {\n    var e_1, _a, e_2, _b, e_3, _c; // tslint:disable-next-line: strict-type-predicates\n\n\n    if (typeof src !== \"object\") {\n      throw new TypeError(\"object type was expected, got \" + typeof src + \" instead\");\n    }\n\n    if (Array.isArray(src)) {\n      var ret = [];\n\n      try {\n        for (var src_1 = __values(src), src_1_1 = src_1.next(); !src_1_1.done; src_1_1 = src_1.next()) {\n          var n = src_1_1.value;\n\n          if (n === null || typeof n !== 'object') {\n            throw new JSONParseError(n, \"unexpected sequence element: \" + n);\n          }\n\n          ret.push(this.parseJSON(n));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (src_1_1 && !src_1_1.done && (_a = src_1.return)) _a.call(src_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return ret;\n    } else if ('prim' in src) {\n      var p = src;\n\n      if (typeof p.prim === 'string' && (p.annots === undefined || Array.isArray(p.annots)) && (p.args === undefined || Array.isArray(p.args))) {\n        var ret = {\n          prim: p.prim\n        };\n\n        if (p.annots !== undefined) {\n          try {\n            for (var _d = __values(p.annots), _e = _d.next(); !_e.done; _e = _d.next()) {\n              var a = _e.value;\n\n              if (typeof a !== 'string') {\n                throw new JSONParseError(a, \"string expected: \" + a);\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n\n          ret.annots = p.annots;\n        }\n\n        if (p.args !== undefined) {\n          ret.args = [];\n\n          try {\n            for (var _f = __values(p.args), _g = _f.next(); !_g.done; _g = _f.next()) {\n              var a = _g.value;\n\n              if (a === null || typeof a !== 'object') {\n                throw new JSONParseError(a, \"unexpected argument: \" + a);\n              }\n\n              ret.args.push(this.parseJSON(a));\n            }\n          } catch (e_3_1) {\n            e_3 = {\n              error: e_3_1\n            };\n          } finally {\n            try {\n              if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n          }\n        }\n\n        return this.expand(ret);\n      }\n\n      throw new JSONParseError(src, \"malformed prim expression: \" + src);\n    } else if ('string' in src) {\n      if (typeof src.string === 'string') {\n        return {\n          string: src.string\n        };\n      }\n\n      throw new JSONParseError(src, \"malformed string literal: \" + src);\n    } else if ('int' in src) {\n      if (typeof src.int === 'string' && intRe.test(src.int)) {\n        return {\n          int: src.int\n        };\n      }\n\n      throw new JSONParseError(src, \"malformed int literal: \" + src);\n    } else if ('bytes' in src) {\n      if (typeof src.bytes === 'string' && bytesRe.test(src.bytes)) {\n        return {\n          bytes: src.bytes\n        };\n      }\n\n      throw new JSONParseError(src, \"malformed bytes literal: \" + src);\n    } else {\n      throw new JSONParseError(src, \"unexpected object: \" + src);\n    }\n  };\n\n  return Parser;\n}();\n\nvar Formatter =\n/** @class */\nfunction () {\n  function Formatter(opt, lev) {\n    if (lev === void 0) {\n      lev = 0;\n    }\n\n    this.opt = opt;\n    this.lev = lev;\n  }\n\n  Formatter.prototype.indent = function (n) {\n    var _a;\n\n    if (n === void 0) {\n      n = 0;\n    }\n\n    var ret = \"\";\n\n    if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.indent) !== undefined) {\n      for (var i = this.lev + n; i > 0; i--) {\n        ret += this.opt.indent;\n      }\n    }\n\n    return ret;\n  };\n\n  Object.defineProperty(Formatter.prototype, \"lf\", {\n    get: function () {\n      var _a;\n\n      return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \"\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Formatter.prototype, \"lfsp\", {\n    get: function () {\n      var _a;\n\n      return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \" \";\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Formatter.prototype.down = function (n) {\n    return new Formatter(this.opt, this.lev + n);\n  };\n\n  return Formatter;\n}();\n\nfunction hasArgs(node) {\n  return \"prim\" in node && (node.annots !== undefined && node.annots.length !== 0 || node.args !== undefined && node.args.length !== 0);\n}\n\nfunction isMultiline(node) {\n  var e_1, _a;\n\n  if (node.args !== undefined) {\n    try {\n      for (var _b = __values(node.args), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var a = _c.value;\n\n        if (Array.isArray(a) || hasArgs(a)) {\n          return true;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction emitExpr(node, f) {\n  var e_2, _a, e_3, _b;\n\n  if (Array.isArray(node)) {\n    return emitSeq(node, f);\n  } else if (\"string\" in node) {\n    return JSON.stringify(node.string);\n  } else if (\"int\" in node) {\n    return node.int;\n  } else if (\"bytes\" in node) {\n    return \"0x\" + node.bytes;\n  } else {\n    if ((node.annots === undefined || node.annots.length === 0) && (node.args === undefined || node.args.length === 0)) {\n      return node.prim;\n    }\n\n    var ret = \"(\" + node.prim;\n\n    if (node.annots !== undefined) {\n      try {\n        for (var _c = __values(node.annots), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var a = _d.value;\n          ret += \" \" + a;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    if (node.args !== undefined) {\n      var multiline = isMultiline(node);\n\n      try {\n        for (var _e = __values(node.args), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var a = _f.value;\n\n          if (multiline) {\n            ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1));\n          } else {\n            ret += \" \" + emitExpr(a, f);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n\n    return ret + \")\";\n  }\n}\n\nfunction emitSeq(node, f) {\n  var e_4, _a, e_5, _b, e_6, _c;\n\n  var ret = \"{\" + f.lf;\n  var i = node.length;\n\n  try {\n    for (var node_1 = __values(node), node_1_1 = node_1.next(); !node_1_1.done; node_1_1 = node_1.next()) {\n      var el = node_1_1.value;\n      ret += f.indent(1);\n\n      if (\"prim\" in el) {\n        ret += el.prim;\n\n        if (el.annots !== undefined) {\n          try {\n            for (var _d = (e_5 = void 0, __values(el.annots)), _e = _d.next(); !_e.done; _e = _d.next()) {\n              var a = _e.value;\n              ret += \" \" + a;\n            }\n          } catch (e_5_1) {\n            e_5 = {\n              error: e_5_1\n            };\n          } finally {\n            try {\n              if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n            } finally {\n              if (e_5) throw e_5.error;\n            }\n          }\n        }\n\n        if (el.args !== undefined) {\n          var multiline = isMultiline(el);\n\n          try {\n            for (var _f = (e_6 = void 0, __values(el.args)), _g = _f.next(); !_g.done; _g = _f.next()) {\n              var a = _g.value;\n\n              if (multiline) {\n                ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2));\n              } else {\n                ret += \" \" + emitExpr(a, f);\n              }\n            }\n          } catch (e_6_1) {\n            e_6 = {\n              error: e_6_1\n            };\n          } finally {\n            try {\n              if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n            } finally {\n              if (e_6) throw e_6.error;\n            }\n          }\n        }\n      } else {\n        ret += emitExpr(el, f.down(1));\n      }\n\n      ret += (i > 1 ? \";\" : \"\") + f.lf;\n      i--;\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (node_1_1 && !node_1_1.done && (_a = node_1.return)) _a.call(node_1);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n\n  return ret + f.indent() + \"}\";\n}\n/**\r\n * Formats Micheline expression\r\n * @param expr An AST node\r\n * @param opt Options\r\n */\n\n\nfunction emitMicheline(expr, opt) {\n  // tslint:disable-next-line: strict-type-predicates\n  if (typeof expr !== \"object\") {\n    throw new TypeError(\"object type was expected, got \" + typeof expr + \" instead\");\n  }\n\n  return emitExpr(expr, new Formatter(opt));\n} // Michelson types\n\n\nvar ValidationError =\n/** @class */\nfunction (_super) {\n  __extends(ValidationError, _super);\n  /**\r\n   * @param val Value of a node caused the error\r\n   * @param path Path to a node caused the error in the AST tree\r\n   * @param message An error message\r\n   */\n\n\n  function ValidationError(val, path, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.val = val;\n    _this.path = path;\n    return _this;\n  }\n\n  return ValidationError;\n}(Error);\n\nfunction isPrim(ex) {\n  return \"prim\" in ex;\n}\n\nfunction assertPrim(ex, path) {\n  if (isPrim(ex)) {\n    return true;\n  }\n\n  throw new ValidationError(ex, path, \"prim expression expected\");\n}\n\nfunction assertSeq(ex, path) {\n  if (Array.isArray(ex)) {\n    return true;\n  }\n\n  throw new ValidationError(ex, path, \"sequence expression expected\");\n}\n\nfunction assertNatural(i, path) {\n  if (i.int[0] === \"-\") {\n    throw new ValidationError(i, path, \"natural number expected\");\n  }\n}\n\nfunction assertIntLiteral(ex, path) {\n  if (\"int\" in ex) {\n    return true;\n  }\n\n  throw new ValidationError(ex, path, \"int literal expected\");\n}\n\nfunction assertArgs$1(ex, n, path) {\n  var _a;\n\n  if (n === 0 && ex.args === undefined || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\n    return true;\n  }\n\n  throw new ValidationError(ex, path, n + \" arguments expected\");\n}\n\nvar unaryInstructionTable = {\n  \"DUP\": true,\n  \"SWAP\": true,\n  \"SOME\": true,\n  \"UNIT\": true,\n  \"PAIR\": true,\n  \"CAR\": true,\n  \"CDR\": true,\n  \"CONS\": true,\n  \"SIZE\": true,\n  \"MEM\": true,\n  \"GET\": true,\n  \"UPDATE\": true,\n  \"EXEC\": true,\n  \"FAILWITH\": true,\n  \"RENAME\": true,\n  \"CONCAT\": true,\n  \"SLICE\": true,\n  \"PACK\": true,\n  \"ADD\": true,\n  \"SUB\": true,\n  \"MUL\": true,\n  \"EDIV\": true,\n  \"ABS\": true,\n  \"ISNAT\": true,\n  \"INT\": true,\n  \"NEG\": true,\n  \"LSL\": true,\n  \"LSR\": true,\n  \"OR\": true,\n  \"AND\": true,\n  \"XOR\": true,\n  \"NOT\": true,\n  \"COMPARE\": true,\n  \"EQ\": true,\n  \"NEQ\": true,\n  \"LT\": true,\n  \"GT\": true,\n  \"LE\": true,\n  \"GE\": true,\n  \"SELF\": true,\n  \"TRANSFER_TOKENS\": true,\n  \"SET_DELEGATE\": true,\n  \"CREATE_ACCOUNT\": true,\n  \"IMPLICIT_ACCOUNT\": true,\n  \"NOW\": true,\n  \"AMOUNT\": true,\n  \"BALANCE\": true,\n  \"CHECK_SIGNATURE\": true,\n  \"BLAKE2B\": true,\n  \"SHA256\": true,\n  \"SHA512\": true,\n  \"HASH_KEY\": true,\n  \"STEPS_TO_QUOTA\": true,\n  \"SOURCE\": true,\n  \"SENDER\": true,\n  \"ADDRESS\": true,\n  \"CHAIN_ID\": true\n};\nvar instructionTable = Object.assign({}, unaryInstructionTable, {\n  \"DROP\": true,\n  \"DIG\": true,\n  \"DUG\": true,\n  \"NONE\": true,\n  \"LEFT\": true,\n  \"RIGHT\": true,\n  \"NIL\": true,\n  \"UNPACK\": true,\n  \"CONTRACT\": true,\n  \"CAST\": true,\n  \"IF_NONE\": true,\n  \"IF_LEFT\": true,\n  \"IF_CONS\": true,\n  \"IF\": true,\n  \"MAP\": true,\n  \"ITER\": true,\n  \"LOOP\": true,\n  \"LOOP_LEFT\": true,\n  \"DIP\": true,\n  \"CREATE_CONTRACT\": true,\n  \"PUSH\": true,\n  \"EMPTY_SET\": true,\n  \"EMPTY_MAP\": true,\n  \"EMPTY_BIG_MAP\": true,\n  \"LAMBDA\": true\n});\n\nfunction assertMichelsonInstruction(ex, path) {\n  var e_1, _a;\n\n  var _b, _c;\n\n  if (Array.isArray(ex)) {\n    var i = 0;\n\n    try {\n      for (var ex_1 = __values(ex), ex_1_1 = ex_1.next(); !ex_1_1.done; ex_1_1 = ex_1.next()) {\n        var n = ex_1_1.value;\n\n        var p = __spread(path, [{\n          index: i,\n          val: n\n        }]);\n\n        if (!Array.isArray(n) && !isPrim(n)) {\n          throw new ValidationError(ex, p, \"sequence or prim expected\");\n        }\n\n        assertMichelsonInstruction(n, p);\n        i++;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (ex_1_1 && !ex_1_1.done && (_a = ex_1.return)) _a.call(ex_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(unaryInstructionTable, ex.prim)) {\n    assertArgs$1(ex, 0, path);\n  } else {\n    switch (ex.prim) {\n      case \"DROP\":\n        if (ex.args !== undefined && assertArgs$1(ex, 1, path)) {\n          var p = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertIntLiteral(ex.args[0], p)) {\n            assertNatural(ex.args[0], p);\n          }\n        }\n\n        break;\n\n      case \"DIG\":\n      case \"DUG\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          var p = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertIntLiteral(ex.args[0], p)) {\n            assertNatural(ex.args[0], p);\n          }\n        }\n\n        break;\n\n      case \"NONE\":\n      case \"LEFT\":\n      case \"RIGHT\":\n      case \"NIL\":\n      case \"UNPACK\":\n      case \"CONTRACT\":\n      case \"CAST\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      case \"IF_NONE\":\n      case \"IF_LEFT\":\n      case \"IF_CONS\":\n      case \"IF\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          var p0 = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[0], p0)) {\n            assertMichelsonInstruction(ex.args[0], p0);\n          }\n\n          var p1 = __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[1], p1)) {\n            assertMichelsonInstruction(ex.args[1], p1);\n          }\n        }\n\n        break;\n\n      case \"MAP\":\n      case \"ITER\":\n      case \"LOOP\":\n      case \"LOOP_LEFT\":\n      case \"CREATE_CONTRACT\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          var p = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[0], p)) {\n            assertMichelsonInstruction(ex.args[0], p);\n          }\n        }\n\n        break;\n\n      case \"DIP\":\n        if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 2) {\n          var p0 = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertIntLiteral(ex.args[0], p0)) {\n            assertNatural(ex.args[0], p0);\n          }\n\n          var p1 = __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[1], p1)) {\n            assertMichelsonInstruction(ex.args[1], p1);\n          }\n        } else if (((_c = ex.args) === null || _c === void 0 ? void 0 : _c.length) === 1) {\n          var p = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[0], p)) {\n            assertMichelsonInstruction(ex.args[0], p);\n          }\n        } else {\n          throw new ValidationError(ex, path, \"1 or 2 arguments expected\");\n        }\n\n        break;\n\n      case \"PUSH\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonDataInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      case \"EMPTY_SET\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonComparableType(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      case \"EMPTY_MAP\":\n      case \"EMPTY_BIG_MAP\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonComparableType(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonTypeInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      case \"LAMBDA\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 3, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonTypeInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n\n          var p2 = __spread(path, [{\n            index: 2,\n            val: ex.args[2]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[2], p2)) {\n            assertMichelsonInstruction(ex.args[2], p2);\n          }\n        }\n\n        break;\n\n      default:\n        throw new ValidationError(ex, path, \"instruction expected\");\n    }\n  }\n\n  return true;\n}\n\nvar simpleComparableTypeTable = {\n  \"int\": true,\n  \"nat\": true,\n  \"string\": true,\n  \"bytes\": true,\n  \"mutez\": true,\n  \"bool\": true,\n  \"key_hash\": true,\n  \"timestamp\": true,\n  \"address\": true\n};\n\nfunction assertMichelsonSimpleComparableType(ex, path) {\n  /* istanbul ignore else */\n  if (assertPrim(ex, path)) {\n    if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n      throw new ValidationError(ex, path, \"simple comparable type expected\");\n    }\n\n    assertArgs$1(ex, 0, path);\n  }\n\n  return true;\n}\n\nfunction assertMichelsonComparableType(ex, path) {\n  /* istanbul ignore else */\n  if (assertPrim(ex, path)) {\n    if (Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n      assertArgs$1(ex, 0, path);\n    } else if (ex.prim === \"pair\") {\n      /* istanbul ignore else */\n      if (assertArgs$1(ex, 2, path)) {\n        assertMichelsonSimpleComparableType(ex.args[0], __spread(path, [{\n          index: 0,\n          val: ex.args[0]\n        }]));\n        assertMichelsonComparableType(ex.args[1], __spread(path, [{\n          index: 1,\n          val: ex.args[1]\n        }]));\n      }\n    } else {\n      throw new ValidationError(ex, path, \"comparable type expected\");\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonTypeInternal(ex, path) {\n  /* istanbul ignore else */\n  if (assertPrim(ex, path)) {\n    switch (ex.prim) {\n      case \"key\":\n      case \"unit\":\n      case \"signature\":\n      case \"operation\":\n      case \"chain_id\":\n        assertArgs$1(ex, 0, path);\n        break;\n\n      case \"option\":\n      case \"list\":\n      case \"contract\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      case \"pair\":\n      case \"or\":\n      case \"lambda\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonTypeInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      case \"set\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonComparableType(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      case \"map\":\n      case \"big_map\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonComparableType(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonTypeInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      default:\n        assertMichelsonComparableType(ex, path);\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonDataInternal(ex, path) {\n  var e_2, _a;\n\n  if (\"int\" in ex || \"string\" in ex || \"bytes\" in ex) {\n    return true;\n  }\n\n  if (Array.isArray(ex)) {\n    var mapElts = 0;\n    var i = 0;\n\n    try {\n      for (var ex_2 = __values(ex), ex_2_1 = ex_2.next(); !ex_2_1.done; ex_2_1 = ex_2.next()) {\n        var n = ex_2_1.value;\n\n        var p = __spread(path, [{\n          index: i,\n          val: n\n        }]);\n\n        if (isPrim(n) && n.prim === \"Elt\") {\n          /* istanbul ignore else */\n          if (assertArgs$1(n, 2, p)) {\n            assertMichelsonDataInternal(n.args[0], __spread(p, [{\n              index: 0,\n              val: n.args[0]\n            }]));\n            assertMichelsonDataInternal(n.args[1], __spread(p, [{\n              index: 1,\n              val: n.args[1]\n            }]));\n          }\n\n          mapElts++;\n        } else {\n          assertMichelsonDataInternal(n, p);\n        }\n\n        i++;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (ex_2_1 && !ex_2_1.done && (_a = ex_2.return)) _a.call(ex_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    if (mapElts !== 0 && mapElts !== ex.length) {\n      throw new ValidationError(ex, path, \"data entries and map elements can't be intermixed\");\n    }\n\n    return true;\n  }\n\n  if (isPrim(ex)) {\n    switch (ex.prim) {\n      case \"Unit\":\n      case \"True\":\n      case \"False\":\n      case \"None\":\n        assertArgs$1(ex, 0, path);\n        break;\n\n      case \"Pair\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonDataInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonDataInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      case \"Left\":\n      case \"Right\":\n      case \"Some\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonDataInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      default:\n        if (Object.prototype.hasOwnProperty.call(instructionTable, ex.prim)) {\n          assertMichelsonInstruction(ex, path);\n        } else {\n          throw new ValidationError(ex, path, \"data entry or instruction expected\");\n        }\n\n    }\n  } else {\n    throw new ValidationError(ex, path, \"data entry expected\");\n  }\n\n  return true;\n}\n\nfunction assertMichelsonScriptInternal(ex, path) {\n  var e_3, _a;\n  /* istanbul ignore else */\n\n\n  if (assertSeq(ex, path) && ex.length === 3 && assertPrim(ex[0], __spread(path, [{\n    index: 0,\n    val: ex[0]\n  }])) && assertPrim(ex[1], __spread(path, [{\n    index: 1,\n    val: ex[1]\n  }])) && assertPrim(ex[2], __spread(path, [{\n    index: 2,\n    val: ex[2]\n  }]))) {\n    var p = [ex[0].prim, ex[1].prim, ex[2].prim].sort();\n\n    if (p[0] === \"code\" && p[1] === \"parameter\" && p[2] === \"storage\") {\n      var i = 0;\n\n      try {\n        for (var _b = __values(ex), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var n = _c.value;\n\n          var p_1 = __spread(path, [{\n            index: i,\n            val: n\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertArgs$1(n, 1, p_1)) {\n            var pp = __spread(p_1, [{\n              index: 0,\n              val: n.args[0]\n            }]);\n\n            switch (n.prim) {\n              case \"code\":\n                /* istanbul ignore else */\n                if (assertSeq(n.args[0], pp)) {\n                  assertMichelsonInstruction(n.args[0], pp);\n                }\n\n                break;\n\n              case \"parameter\":\n              case \"storage\":\n                assertMichelsonTypeInternal(n.args[0], pp);\n            }\n          }\n\n          i++;\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    } else {\n      throw new ValidationError(ex, path, \"valid Michelson script expected\");\n    }\n  }\n\n  return true;\n}\n/**\r\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonScript(ex) {\n  return assertMichelsonScriptInternal(ex, []);\n}\n/**\r\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonData(ex) {\n  return assertMichelsonDataInternal(ex, []);\n}\n/**\r\n * Checks if the node is a valid Michelson code (sequence of instructions).\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonCode(ex) {\n  return assertMichelsonInstruction(ex, []);\n}\n/**\r\n * Checks if the node is a valid Michelson type expression.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonType(ex) {\n  return assertMichelsonTypeInternal(ex, []);\n}\n\nexport { JSONParseError, MacroError, MichelineParseError, Parser, ValidationError, assertMichelsonCode, assertMichelsonData, assertMichelsonScript, assertMichelsonType, emitMicheline };","map":{"version":3,"sources":["../src/scan.ts","../src/macros.ts","../src/micheline-parser.ts","../src/micheline-emitter.ts","../src/michelson-validator.ts"],"names":["assertArgs"],"mappings":"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","sourcesContent":["export class ScanError extends Error {\n    constructor(public src: string, public idx: number, message?: string) {\n        super(message);\n    }\n}\n\nexport enum Literal {\n    Comment,\n    Number,\n    String,\n    Bytes,\n    Ident,\n}\n\nexport type TokenType = \"(\" | \")\" | \"{\" | \"}\" | \";\" | Literal;\n\nconst isSpace = new RegExp(\"\\\\s\");\nconst isIdentStart = new RegExp(\"[:@%_A-Za-z]\");\nconst isIdent = new RegExp(\"[@%_\\\\.A-Za-z0-9]\");\nconst isDigit = new RegExp(\"[0-9]\");\nconst isHex = new RegExp(\"[0-9a-fA-F]\");\n\nexport interface Token {\n    t: TokenType;\n    v: string;\n    offset: number;\n}\n\nexport function* scan(src: string, scanComments = false): Generator<Token, void> {\n    let i = 0;\n    while (i < src.length) {\n        // Skip space\n        while (i < src.length && isSpace.test(src[i])) {\n            i++;\n        }\n        if (i === src.length) {\n            return;\n        }\n\n        const s = src[i];\n        const start = i;\n        if (isIdentStart.test(s)) {\n            // Identifier\n            i++;\n            while (i < src.length && isIdent.test(src[i])) {\n                i++;\n            }\n            yield { t: Literal.Ident, v: src.slice(start, i), offset: i };\n        } else if (src.length - i > 1 && src.substr(i, 2) === \"0x\") {\n            // Bytes\n            i += 2;\n            while (i < src.length && isHex.test(src[i])) {\n                i++;\n            }\n            if (i - start === 2) {\n                throw new ScanError(src, i, \"Bytes literal is too short\");\n            } else if (((i - start) & 1) !== 0) {\n                throw new ScanError(src, i, \"Bytes literal length is expected to be power of two\");\n            }\n            yield { t: Literal.Bytes, v: src.slice(start, i), offset: i };\n        } else if (isDigit.test(s) || s === \"-\") {\n            // Number\n            if (s === \"-\") {\n                i++;\n            }\n            const ii = i;\n            while (i < src.length && isDigit.test(src[i])) {\n                i++;\n            }\n            if (ii === i) {\n                throw new ScanError(src, i, \"Number literal is too short\");\n            }\n            yield { t: Literal.Number, v: src.slice(start, i), offset: i };\n        } else if (s === \"\\\"\") {\n            // String\n            i++;\n            let esc = false;\n            for (; i < src.length && (esc || src[i] !== \"\\\"\"); i++) {\n                if (!esc && src[i] === \"\\\\\") {\n                    esc = true;\n                } else {\n                    esc = false;\n                }\n            }\n            if (i === src.length) {\n                throw new ScanError(src, i, \"Unterminated string literal\");\n            }\n            i++;\n            yield { t: Literal.String, v: src.slice(start, i), offset: i };\n        } else if (s === \"#\") {\n            // Comment\n            i++;\n            while (i < src.length && src[i] !== \"\\n\") {\n                i++;\n            }\n            if (scanComments) {\n                yield { t: Literal.Comment, v: src.slice(start, i), offset: i };\n            }\n        } else if (s === \"(\" || s === \")\" || s === \"{\" || s === \"}\" || s === \";\") {\n            i++;\n            yield { t: s, v: s, offset: i };\n        } else {\n            throw new ScanError(src, i, `Invalid character at offset ${i}: \\`${s}'`);\n        }\n    }\n}","import { Prim, Expr, IntLiteral } from \"./micheline\";\nimport { Tuple, NoArgs, ReqArgs, NoAnnots } from \"./utils\";\n\nexport class MacroError extends Error {\n    constructor(public prim: Prim, message?: string) {\n        super(message);\n    }\n}\n\nfunction assertArgs<N extends number>(ex: Prim, n: N):\n    ex is N extends 0 ?\n    NoArgs<Prim<string>> :\n    ReqArgs<Prim<string, Tuple<Expr, N>>> {\n    if ((n === 0 && ex.args === undefined) || ex.args?.length === n) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects ${n} arguments, was given ${ex.args?.length}`);\n}\n\nfunction assertNoAnnots(ex: Prim): ex is NoAnnots<Prim> {\n    if (ex.annots === undefined) {\n        return true;\n    }\n    throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${ex.annots}`);\n}\n\nfunction assertIntArg(ex: Prim, arg: Expr): arg is IntLiteral {\n    if (\"int\" in arg) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects int argument`);\n}\n\ntype PT = [number, [string | null, string | null]];\n\nfunction parsePairUnpairExpr(p: Prim, expr: string, annotations: string[], agg: (a: PT[], v: PT) => PT[]): { r: PT[], n: number, an: number } {\n    const res: PT[] = [];\n    let i = 0;\n    let ai = 0;\n    const ann: [string | null, string | null] = [null, null];\n\n    // Left expression\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    let c = expr[i++];\n    switch (c) {\n        case \"P\":\n            const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n            res.push(...r);\n            i += n;\n            ai += an;\n            break;\n        case \"A\":\n            if (ai !== annotations.length) {\n                ann[0] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n\n    // Right expression\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    c = expr[i++];\n    switch (c) {\n        case \"P\":\n            const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n            res.push(...r.map<PT>(([v, a]) => [v + 1, a]));\n            i += n;\n            ai += an;\n            break;\n        case \"I\":\n            if (ai !== annotations.length) {\n                ann[1] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n\n    return { r: agg(res, [0, ann]), n: i, an: ai };\n}\n\nfunction parseSetMapCadr(p: Prim, expr: string, vann: string[], term: { a: Expr, d: Expr }): Expr {\n    const c = expr[0];\n    switch (c) {\n        case \"A\":\n            return expr.length > 1 ?\n                [\n                    { prim: \"DUP\" },\n                    {\n                        prim: \"DIP\",\n                        args: [[\n                            { prim: \"CAR\", annots: [\"@%%\"] },\n                            parseSetMapCadr(p, expr.slice(1), [], term),\n                        ]],\n                    },\n                    { prim: \"CDR\", annots: [\"@%%\"] },\n                    { prim: \"SWAP\" },\n                    { prim: \"PAIR\", annots: [\"%@\", \"%@\", ...vann] },\n                ] : term.a;\n\n        case \"D\":\n            return expr.length > 1 ?\n                [\n                    { prim: \"DUP\" },\n                    {\n                        prim: \"DIP\",\n                        args: [[\n                            { prim: \"CDR\", annots: [\"@%%\"] },\n                            parseSetMapCadr(p, expr.slice(1), [], term),\n                        ]],\n                    },\n                    { prim: \"CAR\", annots: [\"@%%\"] },\n                    { prim: \"PAIR\", annots: [\"%@\", \"%@\", ...vann] },\n                ] : term.d;\n\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n}\n\nfunction trimLast<T>(a: T[], v: T): T[] {\n    let l = a.length;\n    while (l > 0 && a[l - 1] === v) {\n        l--;\n    }\n    return a.slice(0, l);\n}\n\nfunction filterAnnotations(a?: string[]): {\n    fields: string[];\n    rest: string[];\n} {\n    const fields: string[] = [];\n    const rest: string[] = [];\n    if (a !== undefined) {\n        for (const v of a) {\n            (v.length !== 0 && v[0] === \"%\" ? fields : rest).push(v);\n        }\n    }\n    return { fields, rest };\n}\n\nfunction mkPrim({ prim, annots, args }: Prim): Prim {\n    return {\n        prim,\n        ...(annots && { annots }),\n        ...(args && { args }),\n    };\n}\n\nconst pairRe = /^P[PAI]{3,}R$/;\nconst unpairRe = /^UNP[PAI]{2,}R$/;\nconst cadrRe = /^C[AD]{2,}R$/;\nconst setCadrRe = /^SET_C[AD]+R$/;\nconst mapCadrRe = /^MAP_C[AD]+R$/;\nconst diipRe = /^DI{2,}P$/;\nconst duupRe = /^DU+P$/;\n\nexport function expandMacros(ex: Prim): Expr {\n    function mayRename(annots?: string[]): Prim[] {\n        return annots !== undefined ? [{ prim: \"RENAME\", annots }] : [];\n    }\n\n    switch (ex.prim) {\n        // Compare\n        case \"CMPEQ\":\n        case \"CMPNEQ\":\n        case \"CMPLT\":\n        case \"CMPGT\":\n        case \"CMPLE\":\n        case \"CMPGE\":\n            if (assertArgs(ex, 0)) {\n                return [\n                    { prim: \"COMPARE\" },\n                    mkPrim({ prim: ex.prim.slice(3), annots: ex.annots }),\n                ];\n            }\n            break;\n\n        case \"IFEQ\":\n        case \"IFNEQ\":\n        case \"IFLT\":\n        case \"IFGT\":\n        case \"IFLE\":\n        case \"IFGE\":\n            if (assertArgs(ex, 2)) {\n                return [\n                    { prim: ex.prim.slice(2) },\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\n                ];\n            }\n            break;\n\n        case \"IFCMPEQ\":\n        case \"IFCMPNEQ\":\n        case \"IFCMPLT\":\n        case \"IFCMPGT\":\n        case \"IFCMPLE\":\n        case \"IFCMPGE\":\n            if (assertArgs(ex, 2)) {\n                return [\n                    { prim: \"COMPARE\" },\n                    { prim: ex.prim.slice(5) },\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\n                ];\n            }\n            break;\n\n        // Fail\n        case \"FAIL\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    { prim: \"UNIT\" },\n                    { prim: \"FAILWITH\" },\n                ];\n            }\n            break;\n\n        // Assertion macros\n        case \"ASSERT\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [{\n                    prim: \"IF\", args: [\n                        [],\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_EQ\":\n        case \"ASSERT_NEQ\":\n        case \"ASSERT_LT\":\n        case \"ASSERT_GT\":\n        case \"ASSERT_LE\":\n        case \"ASSERT_GE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    { prim: ex.prim.slice(7) },\n                    {\n                        prim: \"IF\", args: [\n                            [],\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        ]\n                    },\n                ];\n            }\n            break;\n\n        case \"ASSERT_CMPEQ\":\n        case \"ASSERT_CMPNEQ\":\n        case \"ASSERT_CMPLT\":\n        case \"ASSERT_CMPGT\":\n        case \"ASSERT_CMPLE\":\n        case \"ASSERT_CMPGE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    [\n                        { prim: \"COMPARE\" },\n                        { prim: ex.prim.slice(10) },\n                    ],\n                    {\n                        prim: \"IF\", args: [\n                            [],\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        ]\n                    },\n                ];\n            }\n            break;\n\n        case \"ASSERT_NONE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [{\n                    prim: \"IF_NONE\", args: [\n                        [],\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_SOME\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_NONE\", args: [\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        mayRename(ex.annots),\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_LEFT\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_LEFT\", args: [\n                        mayRename(ex.annots),\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_RIGHT\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_LEFT\", args: [\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        mayRename(ex.annots),\n                    ]\n                }];\n            }\n            break;\n\n        // Syntactic conveniences\n\n        case \"IF_SOME\":\n            if (assertArgs(ex, 2)) {\n                return [mkPrim({ prim: \"IF_NONE\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\n            }\n            break;\n\n        case \"IF_RIGHT\":\n            if (assertArgs(ex, 2)) {\n                return [mkPrim({ prim: \"IF_LEFT\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\n            }\n    }\n\n    // More syntactic conveniences\n\n    // PAPPAIIR macro\n    if (pairRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, (a, v) => [...a, v]);\n\n            return r.map(([v, a], i) => {\n                const ann = [\n                    ...trimLast(a, null).map(v => v === null ? \"%\" : v),\n                    ...((v === 0 && i === r.length - 1) ? rest : [])];\n\n                const leaf = mkPrim({ prim: \"PAIR\", annots: ann.length !== 0 ? ann : undefined, });\n\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\n                };\n            });\n        }\n    }\n\n    // UNPAPPAIIR macro\n    if (unpairRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], (a, v) => [v, ...a]);\n\n            return r.map(([v, a]) => {\n                const leaf: Prim[] = [\n                    { prim: \"DUP\" },\n                    mkPrim({ prim: \"CAR\", annots: a[0] !== null ? [a[0]] : undefined }),\n                    {\n                        prim: \"DIP\",\n                        args: [[mkPrim({ prim: \"CDR\", annots: a[1] !== null ? [a[1]] : undefined })]],\n                    }\n                ];\n\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\n                };\n            });\n        }\n    }\n\n    // C[AD]+R macro\n    if (cadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const ch = [...ex.prim.slice(1, ex.prim.length - 1)];\n\n            return ch.map<Prim>((c, i) => {\n                const ann = i === ch.length - 1 ? ex.annots : undefined;\n                switch (c) {\n                    case \"A\":\n                        return mkPrim({ prim: \"CAR\", annots: ann });\n                    case \"D\":\n                        return mkPrim({ prim: \"CDR\", annots: ann });\n                    default:\n                        throw new MacroError(ex, `unexpected character: ${c}`);\n                }\n            });\n        }\n    }\n\n    // SET_C[AD]+R macro\n    if (setCadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n\n            const term = fields.length !== 0 ?\n                {\n                    a: [\n                        { prim: \"DUP\" },\n                        { prim: \"CAR\", annots: fields },\n                        { prim: \"DROP\" },\n                        { prim: \"CDR\", annots: [\"@%%\"] },\n                        { prim: \"SWAP\" },\n                        { prim: \"PAIR\", annots: [fields[0], \"%@\"] },\n                    ],\n                    d: [\n                        { prim: \"DUP\" },\n                        { prim: \"CDR\", annots: fields },\n                        { prim: \"DROP\" },\n                        { prim: \"CAR\", annots: [\"@%%\"] },\n                        { prim: \"PAIR\", annots: [\"%@\", fields[0]] },\n                    ],\n                } :\n                {\n                    a: [\n                        { prim: \"CDR\", annots: [\"@%%\"] },\n                        { prim: \"SWAP\" },\n                        { prim: \"PAIR\", annots: [\"%\", \"%@\"] },\n                    ],\n                    d: [\n                        { prim: \"CAR\", annots: [\"@%%\"] },\n                        { prim: \"PAIR\", annots: [\"%@\", \"%\"] },\n                    ],\n                };\n\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);\n        }\n    }\n\n    // MAP_C[AD]+R macro\n    if (mapCadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 1)) {\n            const { fields } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n\n            const term = {\n                a: [\n                    { prim: \"DUP\" },\n                    { prim: \"CDR\", annots: [\"@%%\"] },\n                    {\n                        prim: \"DIP\", args: [[\n                            mkPrim({ prim: \"CAR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\n                            ex.args[0],\n                        ]]\n                    },\n                    { prim: \"SWAP\" },\n                    { prim: \"PAIR\", annots: [fields.length !== 0 ? fields[0] : \"%\", \"%@\"] },\n                ],\n                d: [\n                    { prim: \"DUP\" },\n                    mkPrim({ prim: \"CDR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\n                    ex.args[0],\n                    { prim: \"SWAP\" },\n                    { prim: \"CAR\", annots: [\"@%%\"] },\n                    { prim: \"PAIR\", annots: [\"%@\", fields.length !== 0 ? fields[0] : \"%\"] },\n                ],\n            };\n\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);\n        }\n    }\n\n    // Expand deprecated DI...IP to [DIP n]\n    if (diipRe.test(ex.prim)) {\n        if (assertArgs(ex, 1)) {\n            let n = 0;\n            while (ex.prim[1 + n] === \"I\") { n++ }\n            return mkPrim({ prim: \"DIP\", args: [{ int: String(n) }, ex.args[0]] });\n        }\n    }\n\n    // Expand modern DUP n or deprecated DU...UP\n    if (duupRe.test(ex.prim)) {\n        let n = 0;\n        while (ex.prim[1 + n] === \"U\") { n++ }\n\n        if (n === 1) {\n            if (ex.args === undefined) {\n                return ex; // skip\n            }\n            if (assertArgs(ex, 1) && assertIntArg(ex, ex.args[0])) {\n                n = parseInt(ex.args[0].int, 10);\n            }\n        } else {\n            assertArgs(ex, 0);\n        }\n\n        if (n === 1) {\n            return [mkPrim({ prim: \"DUP\", annots: ex.annots })];\n\n        } else if (n === 2) {\n            return [\n                {\n                    prim: \"DIP\",\n                    args: [[mkPrim({ prim: \"DUP\", annots: ex.annots })]],\n                },\n                { prim: \"SWAP\" },\n            ];\n\n        } else {\n            return [\n                {\n                    prim: \"DIP\",\n                    args: [\n                        { int: String(n - 1) },\n                        [mkPrim({ prim: \"DUP\", annots: ex.annots })],\n                    ],\n                },\n                {\n                    prim: \"DIG\",\n                    args: [{ int: String(n) }],\n                },\n            ];\n        }\n\n    }\n\n    return ex;\n}","import { scan, Token, Literal } from './scan';\nimport { Expr, Prim, StringLiteral, IntLiteral, BytesLiteral } from './micheline';\nimport { expandMacros } from './macros';\n\nexport class MichelineParseError extends Error {\n    /**\n     * @param token A token caused the error\n     * @param message An error message\n     */\n    constructor(public token: Token | null, message?: string) {\n        super(message);\n    }\n}\n\nexport class JSONParseError extends Error {\n    /**\n     * @param node A node caused the error\n     * @param message An error message\n     */\n    constructor(public node: any, message?: string) {\n        super(message);\n    }\n}\n\nconst errEOF = new MichelineParseError(null, 'Unexpected EOF');\n\nfunction isAnnotation(tok: Token): boolean {\n    return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');\n}\n\nconst intRe = new RegExp('^-?[0-9]+$');\nconst bytesRe = new RegExp('^([0-9a-fA-F]{2})+$');\n\nexport interface ParserOptions {\n    /**\n     * Expand [Michelson macros](https://tezos.gitlab.io/whitedoc/michelson.html#macros) during parsing.\n     */\n    expandMacros: boolean;\n}\n\n/**\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\n *\n * Pretty Print a Michelson Smart Contract:\n * ```\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\n * const p = new Parser();\n *\n * const michelsonCode = p.parseJSON(contract.script.code);\n * const storage = p.parseJSON(contract.script.storage);\n *\n * console.log(\"Pretty print Michelson smart contract:\");\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\n *\n * console.log(\"Pretty print Storage:\");\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\n * ```\n *\n * Encode a Michelson expression for inital storage of a smart contract\n * ```\n * const src = `(Pair (Pair { Elt 1\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\n *                      0x0501000000026869) }\n *          10000000)\n *    (Pair 2 333))`;\n *\n * const p = new Parser();\n *\n * const exp = p.parseMichelineExpression(src);\n * console.log(JSON.stringify(exp));\n * ```\n */\nexport class Parser {\n    constructor(private opt?: ParserOptions) { }\n\n    private expand(ex: Prim): Expr {\n        return this.opt?.expandMacros ? expandMacros(ex) : ex;\n    }\n\n    private parseList(scanner: Iterator<Token>): Expr {\n        const tok = scanner.next();\n        if (tok.done) {\n            throw errEOF;\n        }\n\n        if (tok.value.t !== Literal.Ident) {\n            throw new MichelineParseError(tok.value, `List: not an identifier: ${tok.value.v}`);\n        }\n\n        const ret: Prim = {\n            prim: tok.value.v,\n        };\n\n        for (; ;) {\n            const tok = scanner.next();\n            if (tok.done) {\n                throw errEOF;\n            }\n            if (tok.value.t === ')') {\n                break;\n            }\n            if (isAnnotation(tok.value)) {\n                ret.annots = ret.annots || [];\n                ret.annots.push(tok.value.v);\n            } else {\n                ret.args = ret.args || [];\n                ret.args.push(this.parseExpr(scanner, tok.value));\n            }\n        }\n        return this.expand(ret);\n    }\n\n    private parseArgs(\n        scanner: Iterator<Token>,\n        prim: string,\n        expectBracket: boolean\n    ): [Prim, boolean] {\n        // Identifier with arguments\n        const p: Prim = { prim };\n\n        for (; ;) {\n            const t = scanner.next();\n            if (t.done) {\n                if (expectBracket) {\n                    throw errEOF;\n                } else {\n                    return [p, true];\n                }\n            } else if (t.value.t === '}') {\n                if (!expectBracket) {\n                    throw new MichelineParseError(t.value, `Seq: unexpected token: ${t.value.v}`);\n                } else {\n                    return [p, true];\n                }\n            } else if (t.value.t === ';') {\n                return [p, false];\n            }\n\n            if (isAnnotation(t.value)) {\n                p.annots = p.annots || [];\n                p.annots.push(t.value.v);\n            } else {\n                p.args = p.args || [];\n                p.args.push(this.parseExpr(scanner, t.value));\n            }\n        }\n    }\n\n    private parseSequence(\n        scanner: Iterator<Token>,\n        initialToken: Token | null,\n        expectBracket: boolean\n    ): Expr[] {\n        const seq: Expr[] = [];\n        for (; ;) {\n            let tok: Token;\n            if (initialToken !== null) {\n                tok = initialToken;\n                initialToken = null;\n            } else {\n                const t = scanner.next();\n                if (t.done) {\n                    if (expectBracket) {\n                        throw errEOF;\n                    } else {\n                        return seq;\n                    }\n                }\n                tok = t.value;\n            }\n\n            if (tok.t === '}') {\n                if (!expectBracket) {\n                    throw new MichelineParseError(tok, `Seq: unexpected token: ${tok.v}`);\n                } else {\n                    return seq;\n                }\n            } else if (tok.t === Literal.Ident) {\n                // Identifier with arguments\n                const [itm, done] = this.parseArgs(scanner, tok.v, expectBracket);\n                seq.push(this.expand(itm));\n                if (done) {\n                    return seq;\n                }\n            } else {\n                // Other\n                seq.push(this.parseExpr(scanner, tok));\n\n                const t = scanner.next();\n                if (t.done) {\n                    if (expectBracket) {\n                        throw errEOF;\n                    } else {\n                        return seq;\n                    }\n                } else if (t.value.t === '}') {\n                    if (!expectBracket) {\n                        throw new MichelineParseError(t.value, `Seq: unexpected token: ${t.value.v}`);\n                    } else {\n                        return seq;\n                    }\n                } else if (t.value.t !== ';') {\n                    throw new MichelineParseError(t.value, `Seq: unexpected token: ${t.value.v}`);\n                }\n            }\n        }\n    }\n\n    private parseExpr(scanner: Iterator<Token>, tok: Token): Expr {\n        switch (tok.t) {\n            case Literal.Ident:\n                return this.expand({ prim: tok.v });\n\n            case Literal.Number:\n                return { int: tok.v };\n\n            case Literal.String:\n                return { string: JSON.parse(tok.v) as string };\n\n            case Literal.Bytes:\n                return { bytes: tok.v.substr(2) };\n\n            case '(':\n                return this.parseList(scanner);\n\n            case '{':\n                return this.parseSequence(scanner, null, true);\n\n            default:\n                throw new MichelineParseError(tok, `Expr: unexpected token: ${tok.v}`);\n        }\n    }\n\n    /**\n     * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\n     */\n    parseScript(src: string): Expr[] | null {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n\n        return tok.value.t === '{'\n            ? this.parseSequence(scanner, null, true)\n            : this.parseSequence(scanner, tok.value, false);\n    }\n\n    /**\n     * Parse any Michelson expression\n     * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\n     * @returns An AST node or null for empty document.\n     */\n    parseMichelineExpression(src: string): Expr | null {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n        return this.parseExpr(scanner, tok.value);\n    }\n\n    /**\n     * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\n     * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\n     */\n    parseJSON(src: object): Expr {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"object\") {\n            throw new TypeError(`object type was expected, got ${typeof src} instead`);\n        }\n\n        if (Array.isArray(src)) {\n            const ret: Expr[] = [];\n            for (const n of src) {\n                if (n === null || typeof n !== 'object') {\n                    throw new JSONParseError(n, `unexpected sequence element: ${n}`);\n                }\n                ret.push(this.parseJSON(n));\n            }\n            return ret;\n\n        } else if ('prim' in src) {\n            const p = src as { prim: any, annots?: any[], args?: any[] };\n            if (\n                typeof p.prim === 'string' &&\n                (p.annots === undefined || Array.isArray(p.annots)) &&\n                (p.args === undefined || Array.isArray(p.args))\n            ) {\n                const ret: Prim = {\n                    prim: p.prim,\n                };\n\n                if (p.annots !== undefined) {\n                    for (const a of p.annots) {\n                        if (typeof a !== 'string') {\n                            throw new JSONParseError(a, `string expected: ${a}`);\n                        }\n                    }\n                    ret.annots = p.annots;\n                }\n\n                if (p.args !== undefined) {\n                    ret.args = [];\n                    for (const a of p.args) {\n                        if (a === null || typeof a !== 'object') {\n                            throw new JSONParseError(a, `unexpected argument: ${a}`);\n                        }\n                        ret.args.push(this.parseJSON(a));\n                    }\n                }\n\n                return this.expand(ret);\n            }\n\n            throw new JSONParseError(src, `malformed prim expression: ${src}`);\n        } else if ('string' in src) {\n            if (typeof (src as any).string === 'string') {\n                return { string: (src as StringLiteral).string };\n            }\n\n            throw new JSONParseError(src, `malformed string literal: ${src}`);\n        } else if ('int' in src) {\n            if (typeof (src as any).int === 'string' && intRe.test((src as IntLiteral).int)) {\n                return { int: (src as IntLiteral).int };\n            }\n\n            throw new JSONParseError(src, `malformed int literal: ${src}`);\n        } else if ('bytes' in src) {\n            if (\n                typeof (src as any).bytes === 'string' &&\n                bytesRe.test((src as BytesLiteral).bytes)\n            ) {\n                return { bytes: (src as BytesLiteral).bytes };\n            }\n\n            throw new JSONParseError(src, `malformed bytes literal: ${src}`);\n        } else {\n            throw new JSONParseError(src, `unexpected object: ${src}`);\n        }\n    }\n}\n","import { Expr, Prim } from \"./micheline\";\n\nexport interface FormatOptions {\n    /**\n     * A string used for code indentation if desired. Usually a tab character or a number of spaces.\n     */\n    indent?: string;\n    /**\n     * A string used for line separation. Usually a newline character (\"\\n\");\n     */\n    newline?: string;\n}\n\nclass Formatter {\n    constructor(private opt?: FormatOptions, private lev: number = 0) {\n    }\n\n    indent(n = 0): string {\n        let ret = \"\";\n        if (this.opt?.indent !== undefined) {\n            for (let i = this.lev + n; i > 0; i--) {\n                ret += this.opt.indent;\n            }\n        }\n        return ret;\n    }\n\n    get lf(): string {\n        return this.opt?.newline || \"\";\n    }\n\n    get lfsp(): string {\n        return this.opt?.newline || \" \";\n    }\n\n    down(n: number): Formatter {\n        return new Formatter(this.opt, this.lev + n);\n    }\n}\n\nfunction hasArgs(node: Expr): node is Prim {\n    return (\"prim\" in node) &&\n        ((node.annots !== undefined && node.annots.length !== 0) ||\n            (node.args !== undefined && node.args.length !== 0));\n}\n\nfunction isMultiline(node: Prim): boolean {\n    if (node.args !== undefined) {\n        for (const a of node.args) {\n            if (Array.isArray(a) || hasArgs(a)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction emitExpr(node: Expr, f: Formatter): string {\n    if (Array.isArray(node)) {\n        return emitSeq(node, f);\n\n    } else if (\"string\" in node) {\n        return JSON.stringify(node.string);\n\n    } else if (\"int\" in node) {\n        return node.int;\n\n    } else if (\"bytes\" in node) {\n        return \"0x\" + node.bytes;\n\n    } else {\n        if ((node.annots === undefined || node.annots.length === 0) &&\n            (node.args === undefined || node.args.length === 0)) {\n            return node.prim;\n        }\n\n        let ret = \"(\" + node.prim;\n        if (node.annots !== undefined) {\n            for (const a of node.annots) {\n                ret += \" \" + a;\n            }\n        }\n        if (node.args !== undefined) {\n            const multiline = isMultiline(node);\n            for (const a of node.args) {\n                if (multiline) {\n                    ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1));\n                } else {\n                    ret += \" \" + emitExpr(a, f);\n                }\n            }\n        }\n        return ret + \")\";\n    }\n}\n\nfunction emitSeq(node: Expr[], f: Formatter): string {\n    let ret = \"{\" + f.lf;\n    let i = node.length;\n    for (const el of node) {\n        ret += f.indent(1);\n\n        if (\"prim\" in el) {\n            ret += el.prim;\n\n            if (el.annots !== undefined) {\n                for (const a of el.annots) {\n                    ret += \" \" + a;\n                }\n            }\n            if (el.args !== undefined) {\n                const multiline = isMultiline(el);\n                for (const a of el.args) {\n                    if (multiline) {\n                        ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2));\n                    } else {\n                        ret += \" \" + emitExpr(a, f);\n                    }\n                }\n            }\n        } else {\n            ret += emitExpr(el, f.down(1));\n        }\n\n        ret += (i > 1 ? \";\" : \"\") + f.lf;\n        i--;\n    }\n    return ret + f.indent() + \"}\";\n}\n\n/**\n * Formats Micheline expression\n * @param expr An AST node\n * @param opt Options\n */\nexport function emitMicheline(expr: Expr, opt?: FormatOptions): string {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof expr !== \"object\") {\n        throw new TypeError(`object type was expected, got ${typeof expr} instead`);\n    }\n\n    return emitExpr(expr, new Formatter(opt));\n}","// Michelson types\n\nimport { Prim, Expr, IntLiteral, StringLiteral, BytesLiteral } from \"./micheline\";\nimport { Tuple, NoArgs, ReqArgs } from \"./utils\";\n\n// Instructions\n\nexport type MichelsonUnaryInstructionId = \"DUP\" | \"SWAP\" | \"SOME\" | \"UNIT\" | \"PAIR\" | \"CAR\" | \"CDR\" |\n   \"CONS\" | \"SIZE\" | \"MEM\" | \"GET\" | \"UPDATE\" | \"EXEC\" | \"FAILWITH\" | \"RENAME\" | \"CONCAT\" | \"SLICE\" |\n   \"PACK\" | \"ADD\" | \"SUB\" | \"MUL\" | \"EDIV\" | \"ABS\" | \"ISNAT\" | \"INT\" | \"NEG\" | \"LSL\" | \"LSR\" | \"OR\" |\n   \"AND\" | \"XOR\" | \"NOT\" | \"COMPARE\" | \"EQ\" | \"NEQ\" | \"LT\" | \"GT\" | \"LE\" | \"GE\" | \"SELF\" |\n   \"TRANSFER_TOKENS\" | \"SET_DELEGATE\" | \"CREATE_ACCOUNT\" | \"IMPLICIT_ACCOUNT\" | \"NOW\" | \"AMOUNT\" |\n   \"BALANCE\" | \"CHECK_SIGNATURE\" | \"BLAKE2B\" | \"SHA256\" | \"SHA512\" | \"HASH_KEY\" | \"STEPS_TO_QUOTA\" |\n   \"SOURCE\" | \"SENDER\" | \"ADDRESS\" | \"CHAIN_ID\";\n\nexport type MichelsonInstructionId = MichelsonUnaryInstructionId |\n   \"DROP\" | \"DIG\" | \"DUG\" | \"NONE\" | \"LEFT\" | \"RIGHT\" | \"NIL\" | \"UNPACK\" | \"CONTRACT\" | \"CAST\" |\n   \"IF_NONE\" | \"IF_LEFT\" | \"IF_CONS\" | \"IF\" | \"MAP\" | \"ITER\" | \"LOOP\" | \"LOOP_LEFT\" | \"DIP\" |\n   \"CREATE_CONTRACT\" | \"PUSH\" | \"EMPTY_SET\" | \"EMPTY_MAP\" | \"EMPTY_BIG_MAP\" | \"LAMBDA\";\n\ntype InstrPrim<PT extends MichelsonInstructionId, AT extends Expr[] = never> = Prim<PT, AT>;\n\nexport type MichelsonInstruction = MichelsonInstruction[] |\n   NoArgs<InstrPrim<MichelsonUnaryInstructionId>> |\n   ReqArgs<InstrPrim<\"DIG\" | \"DUG\", [IntLiteral]>> |\n   InstrPrim<\"DROP\", [IntLiteral]> | // Keep optional argument\n   ReqArgs<InstrPrim<\"NONE\" | \"LEFT\" | \"RIGHT\" | \"NIL\" | \"UNPACK\" | \"CONTRACT\" | \"CAST\", [MichelsonType]>> |\n   ReqArgs<InstrPrim<\"IF_NONE\" | \"IF_LEFT\" | \"IF_CONS\" | \"IF\", [MichelsonInstruction[], MichelsonInstruction[]]>> |\n   ReqArgs<InstrPrim<\"MAP\" | \"ITER\" | \"LOOP\" | \"LOOP_LEFT\" | \"DIP\" | \"CREATE_CONTRACT\", [MichelsonInstruction[]]>> |\n   ReqArgs<InstrPrim<\"PUSH\", [MichelsonType, MichelsonData]>> |\n   ReqArgs<InstrPrim<\"EMPTY_SET\", [MichelsonComparableType]>> |\n   ReqArgs<InstrPrim<\"EMPTY_MAP\" | \"EMPTY_BIG_MAP\", [MichelsonComparableType, MichelsonType]>> |\n   ReqArgs<InstrPrim<\"LAMBDA\", [MichelsonType, MichelsonType, MichelsonInstruction[]]>> |\n   ReqArgs<InstrPrim<\"DIP\", [IntLiteral, MichelsonInstruction[]] | [MichelsonInstruction[]]>>;\n\n// Types\n\nexport type MichelsonSimpleComparableTypeId = \"int\" | \"nat\" | \"string\" | \"bytes\" | \"mutez\" | \"bool\" |\n   \"key_hash\" | \"timestamp\" | \"address\";\n\nexport type MichelsonTypeId = MichelsonSimpleComparableTypeId |\n   \"key\" | \"unit\" | \"signature\" | \"operation\" | \"chain_id\" | \"option\" | \"list\" | \"contract\" | \"pair\" |\n   \"or\" | \"lambda\" | \"set\" | \"map\" | \"big_map\";\n\ntype TypePrim<PT extends MichelsonTypeId, AT extends MichelsonType[] = never> = Prim<PT, AT>;\n\nexport type MichelsonSimpleComparableType = NoArgs<TypePrim<MichelsonSimpleComparableTypeId>>;\nexport type MichelsonComparableType = MichelsonSimpleComparableType |\n   ReqArgs<TypePrim<\"pair\", [MichelsonSimpleComparableType, MichelsonComparableType]>>;\n\nexport type MichelsonType = MichelsonComparableType |\n   NoArgs<TypePrim<\"key\" | \"unit\" | \"signature\" | \"operation\" | \"chain_id\">> |\n   ReqArgs<TypePrim<\"option\" | \"list\" | \"contract\", [MichelsonType]>> |\n   ReqArgs<TypePrim<\"pair\" | \"or\" | \"lambda\", [MichelsonType, MichelsonType]>> |\n   ReqArgs<TypePrim<\"set\", [MichelsonComparableType]>> |\n   ReqArgs<TypePrim<\"map\" | \"big_map\", [MichelsonComparableType, MichelsonType]>>;\n\n// Data\n\nexport type MichelsonMapElt = ReqArgs<Prim<\"Elt\", [MichelsonData, MichelsonData]>>;\nexport type MichelsonDataId = \"Unit\" | \"True\" | \"False\" | \"None\" | \"Pair\" | \"Left\" | \"Right\" | \"Some\";\ntype DataPrim<PT extends MichelsonDataId, AT extends MichelsonData[] = never> = Prim<PT, AT>;\n\nexport type MichelsonData = IntLiteral |\n   StringLiteral |\n   BytesLiteral |\n   NoArgs<DataPrim<\"Unit\" | \"True\" | \"False\" | \"None\">> |\n   ReqArgs<DataPrim<\"Pair\", [MichelsonData, MichelsonData]>> |\n   ReqArgs<DataPrim<\"Left\" | \"Right\" | \"Some\", [MichelsonData]>> |\n   MichelsonData[] |\n   MichelsonMapElt[] |\n   MichelsonInstruction;\n\n// Top level script sections\n\ntype MichelsonSectionId = \"parameter\" | \"storage\" | \"code\";\ntype SectionPrim<PT extends MichelsonSectionId, AT extends Expr[]> = ReqArgs<Prim<PT, AT>>;\n\nexport type MichelsonParameter = SectionPrim<\"parameter\", [MichelsonType]>;\nexport type MichelsonStorage = SectionPrim<\"storage\", [MichelsonType]>;\nexport type MichelsonCode = SectionPrim<\"code\", [MichelsonInstruction[]]>;\n\nexport type MichelsonScript = [MichelsonParameter, MichelsonStorage, MichelsonCode] |\n   [MichelsonStorage, MichelsonCode, MichelsonParameter] |\n   [MichelsonCode, MichelsonParameter, MichelsonStorage];\n\n// Michelson validator\n\ninterface PathElem {\n   /**\n    * Node's index. Either argument index or sequence index.\n    */\n   index: number;\n   /**\n    * Node's value.\n    */\n   val: Expr;\n}\n\nexport class ValidationError extends Error {\n   /**\n    * @param val Value of a node caused the error\n    * @param path Path to a node caused the error in the AST tree\n    * @param message An error message\n    */\n   constructor(public val: Expr, public path?: PathElem[], message?: string) {\n      super(message);\n   }\n}\n\nfunction isPrim(ex: Expr): ex is Prim {\n   return \"prim\" in ex;\n}\n\nfunction assertPrim(ex: Expr, path: PathElem[]): ex is Prim {\n   if (isPrim(ex)) {\n      return true;\n   }\n   throw new ValidationError(ex, path, \"prim expression expected\");\n}\n\nfunction assertSeq(ex: Expr, path: PathElem[]): ex is Expr[] {\n   if (Array.isArray(ex)) {\n      return true;\n   }\n   throw new ValidationError(ex, path, \"sequence expression expected\");\n}\n\nfunction assertNatural(i: IntLiteral, path: PathElem[]) {\n   if (i.int[0] === \"-\") {\n      throw new ValidationError(i, path, \"natural number expected\");\n   }\n}\n\nfunction assertIntLiteral(ex: Expr, path: PathElem[]): ex is IntLiteral {\n   if (\"int\" in ex) {\n      return true;\n   }\n   throw new ValidationError(ex, path, \"int literal expected\");\n}\n\nfunction assertArgs<N extends number>(ex: Prim, n: N, path: PathElem[]):\n   ex is N extends 0 ?\n   NoArgs<Prim<string>> :\n   ReqArgs<Prim<string, Tuple<Expr, N>>> {\n   if ((n === 0 && ex.args === undefined) || ex.args?.length === n) {\n      return true;\n   }\n   throw new ValidationError(ex, path, `${n} arguments expected`);\n}\n\nconst unaryInstructionTable: Record<MichelsonUnaryInstructionId, boolean> = {\n   \"DUP\": true, \"SWAP\": true, \"SOME\": true, \"UNIT\": true, \"PAIR\": true, \"CAR\": true, \"CDR\": true,\n   \"CONS\": true, \"SIZE\": true, \"MEM\": true, \"GET\": true, \"UPDATE\": true, \"EXEC\": true, \"FAILWITH\": true, \"RENAME\": true, \"CONCAT\": true, \"SLICE\": true,\n   \"PACK\": true, \"ADD\": true, \"SUB\": true, \"MUL\": true, \"EDIV\": true, \"ABS\": true, \"ISNAT\": true, \"INT\": true, \"NEG\": true, \"LSL\": true, \"LSR\": true, \"OR\": true,\n   \"AND\": true, \"XOR\": true, \"NOT\": true, \"COMPARE\": true, \"EQ\": true, \"NEQ\": true, \"LT\": true, \"GT\": true, \"LE\": true, \"GE\": true, \"SELF\": true,\n   \"TRANSFER_TOKENS\": true, \"SET_DELEGATE\": true, \"CREATE_ACCOUNT\": true, \"IMPLICIT_ACCOUNT\": true, \"NOW\": true, \"AMOUNT\": true,\n   \"BALANCE\": true, \"CHECK_SIGNATURE\": true, \"BLAKE2B\": true, \"SHA256\": true, \"SHA512\": true, \"HASH_KEY\": true, \"STEPS_TO_QUOTA\": true,\n   \"SOURCE\": true, \"SENDER\": true, \"ADDRESS\": true, \"CHAIN_ID\": true,\n};\n\nconst instructionTable: Record<MichelsonInstructionId, boolean> = Object.assign({}, unaryInstructionTable, {\n   \"DROP\": true, \"DIG\": true, \"DUG\": true, \"NONE\": true, \"LEFT\": true, \"RIGHT\": true, \"NIL\": true, \"UNPACK\": true, \"CONTRACT\": true, \"CAST\": true,\n   \"IF_NONE\": true, \"IF_LEFT\": true, \"IF_CONS\": true, \"IF\": true, \"MAP\": true, \"ITER\": true, \"LOOP\": true, \"LOOP_LEFT\": true, \"DIP\": true,\n   \"CREATE_CONTRACT\": true, \"PUSH\": true, \"EMPTY_SET\": true, \"EMPTY_MAP\": true, \"EMPTY_BIG_MAP\": true, \"LAMBDA\": true,\n});\n\nfunction assertMichelsonInstruction(ex: Expr[] | Prim, path: PathElem[]): ex is MichelsonInstruction {\n   if (Array.isArray(ex)) {\n      let i = 0;\n      for (const n of ex) {\n         const p = [...path, { index: i, val: n }];\n         if (!Array.isArray(n) && !isPrim(n)) {\n            throw new ValidationError(ex, p, \"sequence or prim expected\");\n         }\n         assertMichelsonInstruction(n, p);\n         i++;\n      }\n   } else if (Object.prototype.hasOwnProperty.call(unaryInstructionTable, ex.prim)) {\n      assertArgs(ex, 0, path);\n   } else {\n      switch (ex.prim) {\n         case \"DROP\":\n            if (ex.args !== undefined && assertArgs(ex, 1, path)) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0], p)) {\n                  assertNatural(ex.args[0], p);\n               }\n            }\n            break;\n\n         case \"DIG\":\n         case \"DUG\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0], p)) {\n                  assertNatural(ex.args[0], p);\n               }\n            }\n            break;\n\n         case \"NONE\":\n         case \"LEFT\":\n         case \"RIGHT\":\n         case \"NIL\":\n         case \"UNPACK\":\n         case \"CONTRACT\":\n         case \"CAST\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"IF_NONE\":\n         case \"IF_LEFT\":\n         case \"IF_CONS\":\n         case \"IF\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               const p0 = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0], p0)) {\n                  assertMichelsonInstruction(ex.args[0], p0);\n               }\n               const p1 = [...path, { index: 1, val: ex.args[1] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[1], p1)) {\n                  assertMichelsonInstruction(ex.args[1], p1);\n               }\n            }\n            break;\n\n         case \"MAP\":\n         case \"ITER\":\n         case \"LOOP\":\n         case \"LOOP_LEFT\":\n         case \"CREATE_CONTRACT\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0], p)) {\n                  assertMichelsonInstruction(ex.args[0], p);\n               }\n            }\n            break;\n\n         case \"DIP\":\n            if (ex.args?.length === 2) {\n               const p0 = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0], p0)) {\n                  assertNatural(ex.args[0], p0);\n               }\n               const p1 = [...path, { index: 1, val: ex.args[1] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[1], p1)) {\n                  assertMichelsonInstruction(ex.args[1], p1);\n               }\n            } else if (ex.args?.length === 1) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0], p)) {\n                  assertMichelsonInstruction(ex.args[0], p);\n               }\n            } else {\n               throw new ValidationError(ex, path, \"1 or 2 arguments expected\");\n            }\n            break;\n\n         case \"PUSH\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonDataInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"EMPTY_SET\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"EMPTY_MAP\":\n         case \"EMPTY_BIG_MAP\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"LAMBDA\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 3, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n               const p2 = [...path, { index: 2, val: ex.args[2] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[2], p2)) {\n                  assertMichelsonInstruction(ex.args[2], p2);\n               }\n            }\n            break;\n\n         default:\n            throw new ValidationError(ex, path, \"instruction expected\");\n      }\n   }\n   return true;\n}\n\nconst simpleComparableTypeTable: Record<MichelsonSimpleComparableTypeId, boolean> = {\n   \"int\": true, \"nat\": true, \"string\": true, \"bytes\": true, \"mutez\": true,\n   \"bool\": true, \"key_hash\": true, \"timestamp\": true, \"address\": true,\n};\n\nfunction assertMichelsonSimpleComparableType(ex: Expr, path: PathElem[]): ex is MichelsonSimpleComparableType {\n   /* istanbul ignore else */\n   if (assertPrim(ex, path)) {\n      if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n         throw new ValidationError(ex, path, \"simple comparable type expected\");\n      }\n      assertArgs(ex, 0, path);\n   }\n   return true;\n}\n\nfunction assertMichelsonComparableType(ex: Expr, path: PathElem[]): ex is MichelsonComparableType {\n   /* istanbul ignore else */\n   if (assertPrim(ex, path)) {\n      if (Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n         assertArgs(ex, 0, path);\n      } else if (ex.prim === \"pair\") {\n         /* istanbul ignore else */\n         if (assertArgs(ex, 2, path)) {\n            assertMichelsonSimpleComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            assertMichelsonComparableType(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n         }\n      } else {\n         throw new ValidationError(ex, path, \"comparable type expected\");\n      }\n   }\n   return true;\n}\n\nfunction assertMichelsonTypeInternal(ex: Expr, path: PathElem[]): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrim(ex, path)) {\n      switch (ex.prim) {\n         case \"key\":\n         case \"unit\":\n         case \"signature\":\n         case \"operation\":\n         case \"chain_id\":\n            assertArgs(ex, 0, path);\n            break;\n\n         case \"option\":\n         case \"list\":\n         case \"contract\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"pair\":\n         case \"or\":\n         case \"lambda\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"set\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"map\":\n         case \"big_map\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         default:\n            assertMichelsonComparableType(ex, path);\n      }\n   }\n\n   return true;\n}\n\nfunction assertMichelsonDataInternal(ex: Expr, path: PathElem[]): ex is MichelsonData {\n   if ((\"int\" in ex) || (\"string\" in ex) || (\"bytes\" in ex)) {\n      return true;\n   }\n\n   if (Array.isArray(ex)) {\n      let mapElts = 0;\n      let i = 0;\n      for (const n of ex) {\n         const p = [...path, { index: i, val: n }];\n         if (isPrim(n) && n.prim === \"Elt\") {\n            /* istanbul ignore else */\n            if (assertArgs(n, 2, p)) {\n               assertMichelsonDataInternal(n.args[0], [...p, { index: 0, val: n.args[0] }]);\n               assertMichelsonDataInternal(n.args[1], [...p, { index: 1, val: n.args[1] }]);\n            }\n            mapElts++;\n         } else {\n            assertMichelsonDataInternal(n, p);\n         }\n         i++;\n      }\n\n      if (mapElts !== 0 && mapElts !== ex.length) {\n         throw new ValidationError(ex, path, \"data entries and map elements can't be intermixed\");\n      }\n      return true;\n   }\n\n   if (isPrim(ex)) {\n      switch (ex.prim) {\n         case \"Unit\":\n         case \"True\":\n         case \"False\":\n         case \"None\":\n            assertArgs(ex, 0, path);\n            break;\n\n         case \"Pair\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonDataInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonDataInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"Left\":\n         case \"Right\":\n         case \"Some\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonDataInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         default:\n            if (Object.prototype.hasOwnProperty.call(instructionTable, ex.prim)) {\n               assertMichelsonInstruction(ex, path);\n            } else {\n               throw new ValidationError(ex, path, \"data entry or instruction expected\");\n            }\n      }\n   } else {\n      throw new ValidationError(ex, path, \"data entry expected\");\n   }\n\n   return true;\n}\n\nfunction assertMichelsonScriptInternal(ex: Expr, path: PathElem[]): ex is MichelsonScript {\n   /* istanbul ignore else */\n   if (assertSeq(ex, path) && ex.length === 3 &&\n      assertPrim(ex[0], [...path, { index: 0, val: ex[0] }]) &&\n      assertPrim(ex[1], [...path, { index: 1, val: ex[1] }]) &&\n      assertPrim(ex[2], [...path, { index: 2, val: ex[2] }])) {\n\n      const p = [ex[0].prim, ex[1].prim, ex[2].prim].sort();\n      if (p[0] === \"code\" && p[1] === \"parameter\" && p[2] === \"storage\") {\n         let i = 0;\n         for (const n of ex as Prim[]) {\n            const p = [...path, { index: i, val: n }];\n\n            /* istanbul ignore else */\n            if (assertArgs(n, 1, p)) {\n               const pp = [...p, { index: 0, val: n.args[0] }];\n\n               switch (n.prim) {\n                  case \"code\":\n                     /* istanbul ignore else */\n                     if (assertSeq(n.args[0], pp)) {\n                        assertMichelsonInstruction(n.args[0], pp);\n                     }\n                     break;\n\n                  case \"parameter\":\n                  case \"storage\":\n                     assertMichelsonTypeInternal(n.args[0], pp);\n               }\n            }\n            i++;\n         }\n      } else {\n         throw new ValidationError(ex, path, \"valid Michelson script expected\");\n      }\n   }\n   return true;\n}\n\n/**\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonScript(ex: Expr): ex is MichelsonScript {\n   return assertMichelsonScriptInternal(ex, []);\n}\n\n/**\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonData(ex: Expr): ex is MichelsonData {\n   return assertMichelsonDataInternal(ex, []);\n}\n\n/**\n * Checks if the node is a valid Michelson code (sequence of instructions).\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonCode(ex: Expr[]): ex is MichelsonInstruction[] {\n   return assertMichelsonInstruction(ex, []);\n}\n\n/**\n * Checks if the node is a valid Michelson type expression.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonType(ex: Expr): ex is MichelsonType {\n   return assertMichelsonTypeInternal(ex, []);\n}"]},"metadata":{},"sourceType":"module"}