{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Micheline = __importStar(require(\"./lexer/Micheline\"));\n\nconst Michelson = __importStar(require(\"./lexer/Michelson\"));\n\nconst nearley = __importStar(require(\"nearley\"));\n\nconst TezosMessageUtil_1 = require(\"./TezosMessageUtil\");\n\nconst MichelineKeywords = ['\"parameter\"', '\"storage\"', '\"code\"', '\"False\"', '\"Elt\"', '\"Left\"', '\"None\"', '\"Pair\"', '\"Right\"', '\"Some\"', '\"True\"', '\"Unit\"', '\"PACK\"', '\"UNPACK\"', '\"BLAKE2B\"', '\"SHA256\"', '\"SHA512\"', '\"ABS\"', '\"ADD\"', '\"AMOUNT\"', '\"AND\"', '\"BALANCE\"', '\"CAR\"', '\"CDR\"', '\"CHECK_SIGNATURE\"', '\"COMPARE\"', '\"CONCAT\"', '\"CONS\"', '\"CREATE_ACCOUNT\"', '\"CREATE_CONTRACT\"', '\"IMPLICIT_ACCOUNT\"', '\"DIP\"', '\"DROP\"', '\"DUP\"', '\"EDIV\"', '\"EMPTY_MAP\"', '\"EMPTY_SET\"', '\"EQ\"', '\"EXEC\"', '\"FAILWITH\"', '\"GE\"', '\"GET\"', '\"GT\"', '\"HASH_KEY\"', '\"IF\"', '\"IF_CONS\"', '\"IF_LEFT\"', '\"IF_NONE\"', '\"INT\"', '\"LAMBDA\"', '\"LE\"', '\"LEFT\"', '\"LOOP\"', '\"LSL\"', '\"LSR\"', '\"LT\"', '\"MAP\"', '\"MEM\"', '\"MUL\"', '\"NEG\"', '\"NEQ\"', '\"NIL\"', '\"NONE\"', '\"NOT\"', '\"NOW\"', '\"OR\"', '\"PAIR\"', '\"PUSH\"', '\"RIGHT\"', '\"SIZE\"', '\"SOME\"', '\"SOURCE\"', '\"SENDER\"', '\"SELF\"', '\"STEPS_TO_QUOTA\"', '\"SUB\"', '\"SWAP\"', '\"TRANSFER_TOKENS\"', '\"SET_DELEGATE\"', '\"UNIT\"', '\"UPDATE\"', '\"XOR\"', '\"ITER\"', '\"LOOP_LEFT\"', '\"ADDRESS\"', '\"CONTRACT\"', '\"ISNAT\"', '\"CAST\"', '\"RENAME\"', '\"bool\"', '\"contract\"', '\"int\"', '\"key\"', '\"key_hash\"', '\"lambda\"', '\"list\"', '\"map\"', '\"big_map\"', '\"nat\"', '\"option\"', '\"or\"', '\"pair\"', '\"set\"', '\"signature\"', '\"string\"', '\"bytes\"', '\"mutez\"', '\"timestamp\"', '\"unit\"', '\"operation\"', '\"address\"', '\"SLICE\"', '\"DEFAULT_ACCOUNT\"', '\"tez\"'];\nvar TezosLanguageUtil;\n\n(function (TezosLanguageUtil) {\n  function hexToMicheline(hex) {\n    if (hex.length < 2) {\n      throw new Error(`Malformed Micheline fragment '${hex}'`);\n    }\n\n    let code = '';\n    let offset = 0;\n    let fieldType = hex.substring(offset, offset + 2);\n    offset += 2;\n\n    switch (fieldType) {\n      case '00':\n        {\n          const value = TezosMessageUtil_1.TezosMessageUtils.findInt(hex.substring(offset), 0, true);\n          code += `{ \"int\": \"${value.value}\" }`;\n          offset += value.length;\n          break;\n        }\n\n      case '01':\n        {\n          const stringEnvelope = michelineHexToString(hex.substring(offset));\n          code += `{ \"string\": \"${stringEnvelope.code}\" }`;\n          offset += stringEnvelope.consumed;\n          break;\n        }\n\n      case '02':\n        {\n          const length = parseInt(hex.substring(offset, offset + 8), 16);\n          offset += 8;\n          let buffer = [];\n          let consumed = 0;\n\n          while (consumed < length) {\n            let envelope = hexToMicheline(hex.substring(offset));\n            buffer.push(envelope.code);\n            consumed += envelope.consumed / 2;\n            offset += envelope.consumed;\n          }\n\n          if (length === 0) {\n            code += '[]';\n          } else {\n            code += `[ ${buffer.join(', ')} ]`;\n          }\n\n          break;\n        }\n\n      case '03':\n        {\n          code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)} }`;\n          offset += 2;\n          break;\n        }\n\n      case '04':\n        {\n          code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n          offset += 2;\n          const annEnvelope = michelineHexToAnnotations(hex.substring(offset));\n          code += `\"annots\": [ ${annEnvelope.code} ] }`;\n          offset += annEnvelope.consumed;\n          break;\n        }\n\n      case '05':\n        {\n          code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n          offset += 2;\n          const envelope = hexToMicheline(hex.substring(offset));\n          code += `\"args\": [ ${envelope.code} ] }`;\n          offset += envelope.consumed;\n          break;\n        }\n\n      case '06':\n        {\n          code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n          offset += 2;\n          const args = hexToMicheline(hex.substring(offset));\n          code += `\"args\": [ ${args.code} ], `;\n          offset += args.consumed;\n          const anns = michelineHexToAnnotations(hex.substring(offset));\n          code += `\"annots\": [ ${anns.code} ] }`;\n          offset += anns.consumed;\n          break;\n        }\n\n      case '07':\n        {\n          code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n          offset += 2;\n          let buffer = [];\n          let envelope = hexToMicheline(hex.substring(offset));\n          buffer.push(envelope.code);\n          offset += envelope.consumed;\n          envelope = hexToMicheline(hex.substring(offset));\n          buffer.push(envelope.code);\n          offset += envelope.consumed;\n          code += `\"args\": [ ${buffer.join(', ')} ] }`;\n          break;\n        }\n\n      case '08':\n        {\n          code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n          offset += 2;\n          const arg0 = hexToMicheline(hex.substring(offset));\n          offset += arg0.consumed;\n          const arg1 = hexToMicheline(hex.substring(offset));\n          offset += arg1.consumed;\n          code += `\"args\": [ ${arg0.code}, ${arg1.code} ], `;\n          const anns = michelineHexToAnnotations(hex.substring(offset));\n          code += `\"annots\": [ ${anns.code} ] }`;\n          offset += anns.consumed;\n          break;\n        }\n\n      case '09':\n        {\n          code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n          offset += 2;\n          let envelope = hexToMicheline('02' + hex.substring(offset));\n          code += `\"args\": ${envelope.code}`;\n          offset += envelope.consumed - 2;\n\n          if (hex.substring(offset, offset + 8) !== '00000000') {\n            const annEnvelope = michelineHexToAnnotations(hex.substring(offset));\n\n            if (annEnvelope.code.length > 2) {\n              code += `, \"annots\": [ ${annEnvelope.code} ] }`;\n            }\n\n            offset += annEnvelope.consumed;\n          } else {\n            code += ' }';\n            offset += 8;\n          }\n\n          break;\n        }\n\n      case '0a':\n        {\n          const length = parseInt(hex.substring(offset, offset + 8), 16);\n          offset += 8;\n          code += `{ \"bytes\": \"${hex.substring(offset, offset + length * 2)}\" }`;\n          offset += length * 2;\n          break;\n        }\n\n      default:\n        {\n          throw new Error(`Unknown Micheline field type '${fieldType}'`);\n        }\n    }\n\n    return {\n      code: code,\n      consumed: offset\n    };\n  }\n\n  TezosLanguageUtil.hexToMicheline = hexToMicheline;\n\n  function translateMichelsonToMicheline(code) {\n    const parser = new nearley.Parser(nearley.Grammar.fromCompiled(Michelson.default));\n    preProcessMichelsonScript(code).forEach(p => {\n      parser.feed(p);\n    });\n    return parser.results[0];\n  }\n\n  TezosLanguageUtil.translateMichelsonToMicheline = translateMichelsonToMicheline;\n\n  function translateParameterMichelsonToMicheline(code) {\n    return translateMichelsonToMicheline(code);\n  }\n\n  TezosLanguageUtil.translateParameterMichelsonToMicheline = translateParameterMichelsonToMicheline;\n\n  function translateMichelsonToHex(code) {\n    return preProcessMicheline(translateMichelsonToMicheline(code)).map(p => {\n      var c = normalizeMichelineWhiteSpace(p);\n      return c;\n    }).map(p => translateMichelineToHex(p)).reduce((m, p) => {\n      return m += ('0000000' + (p.length / 2).toString(16)).slice(-8) + p;\n    }, '');\n  }\n\n  TezosLanguageUtil.translateMichelsonToHex = translateMichelsonToHex;\n\n  function preProcessMicheline(code) {\n    const container = JSON.parse(code);\n    let parts = [];\n    parts.push(getSection(container, 'code'));\n    parts.push(getSection(container, 'storage'));\n    return parts;\n  }\n\n  function getSection(container, key) {\n    let root = container;\n\n    if (!!container.script) {\n      root = container.script;\n    }\n\n    for (let i = 0; i < root.length; i++) {\n      if (root[i]['prim'] === key) {\n        return JSON.stringify(root[i], null, 1);\n      }\n    }\n\n    throw new Error(`${key} key was not found`);\n  }\n\n  function translateMichelineToHex(code) {\n    const parser = new nearley.Parser(nearley.Grammar.fromCompiled(Micheline.default));\n    parser.feed(normalizeMichelineWhiteSpace(code));\n    return parser.results.join('');\n  }\n\n  TezosLanguageUtil.translateMichelineToHex = translateMichelineToHex;\n\n  function michelineHexToString(hex) {\n    let offset = 0;\n    const length = parseInt(hex.substring(offset, offset + 8), 16);\n    offset += 8;\n    const text = Buffer.from(hex.substring(offset, offset + length * 2), 'hex').toString();\n    offset += length * 2;\n    return {\n      code: text,\n      consumed: offset\n    };\n  }\n\n  function michelineHexToKeyword(hex, offset) {\n    return MichelineKeywords[parseInt(hex.substring(offset, offset + 2), 16)];\n  }\n\n  function michelineHexToAnnotations(hex) {\n    const stringEnvelope = michelineHexToString(hex);\n    return {\n      code: stringEnvelope.code.split(' ').map(s => `\"${s}\"`).join(', '),\n      consumed: stringEnvelope.consumed\n    };\n  }\n\n  function preProcessMichelsonScript(code) {\n    let sections = new Map();\n    sections['parameter'] = code.search(/(^|\\s+)parameter/m);\n    sections['storage'] = code.search(/(^|\\s+)storage/m);\n    sections['code'] = code.search(/(^|\\s+)code/m);\n    const boundaries = Object.values(sections).sort((a, b) => Number(a) - Number(b));\n    sections[Object.keys(sections).find(key => sections[key] === boundaries[0]) + ''] = code.substring(boundaries[0], boundaries[1]);\n    sections[Object.keys(sections).find(key => sections[key] === boundaries[1]) + ''] = code.substring(boundaries[1], boundaries[2]);\n    sections[Object.keys(sections).find(key => sections[key] === boundaries[2]) + ''] = code.substring(boundaries[2]);\n    const parts = [sections['parameter'], sections['storage'], sections['code']];\n    return parts.map(p => p.trim().split('\\n').map(l => l.replace(/\\#[\\s\\S]+$/, '').trim()).filter(v => v.length > 0).join(' '));\n  }\n\n  TezosLanguageUtil.preProcessMichelsonScript = preProcessMichelsonScript;\n\n  function normalizeMichelineWhiteSpace(fragment) {\n    return fragment.replace(/\\n/g, ' ').replace(/ +/g, ' ').replace(/\\[{/g, '[ {').replace(/}\\]/g, '} ]').replace(/},{/g, '}, {').replace(/\\]}/g, '] }').replace(/\":\"/g, '\": \"').replace(/\":\\[/g, '\": [').replace(/{\"/g, '{ \"').replace(/\"}/g, '\" }').replace(/,\"/g, ', \"').replace(/\",\"/g, '\", \"').replace(/\\[\\[/g, '[ [').replace(/\\]\\]/g, '] ]').replace(/\\[\"/g, '\\[ \"').replace(/\"\\]/g, '\" \\]').replace(/\\[ +\\]/g, '\\[\\]').trim();\n  }\n\n  TezosLanguageUtil.normalizeMichelineWhiteSpace = normalizeMichelineWhiteSpace;\n\n  function stripComments(fragment) {\n    return fragment.trim().split('\\n').map(l => l.replace(/\\#[\\s\\S]+$/, '').trim()).filter(v => v.length > 0).join(' ');\n  }\n\n  TezosLanguageUtil.stripComments = stripComments;\n})(TezosLanguageUtil = exports.TezosLanguageUtil || (exports.TezosLanguageUtil = {}));","map":{"version":3,"sources":["../../../src/chain/tezos/TezosLanguageUtil.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Micheline = __importStar(require(\"./lexer/Micheline\"));\nconst Michelson = __importStar(require(\"./lexer/Michelson\"));\nconst nearley = __importStar(require(\"nearley\"));\nconst TezosMessageUtil_1 = require(\"./TezosMessageUtil\");\nconst MichelineKeywords = ['\"parameter\"', '\"storage\"', '\"code\"', '\"False\"', '\"Elt\"', '\"Left\"', '\"None\"', '\"Pair\"', '\"Right\"', '\"Some\"', '\"True\"', '\"Unit\"', '\"PACK\"', '\"UNPACK\"', '\"BLAKE2B\"', '\"SHA256\"', '\"SHA512\"', '\"ABS\"', '\"ADD\"', '\"AMOUNT\"', '\"AND\"', '\"BALANCE\"', '\"CAR\"', '\"CDR\"', '\"CHECK_SIGNATURE\"', '\"COMPARE\"', '\"CONCAT\"', '\"CONS\"', '\"CREATE_ACCOUNT\"', '\"CREATE_CONTRACT\"', '\"IMPLICIT_ACCOUNT\"', '\"DIP\"', '\"DROP\"', '\"DUP\"', '\"EDIV\"', '\"EMPTY_MAP\"', '\"EMPTY_SET\"', '\"EQ\"', '\"EXEC\"', '\"FAILWITH\"', '\"GE\"', '\"GET\"', '\"GT\"', '\"HASH_KEY\"', '\"IF\"', '\"IF_CONS\"', '\"IF_LEFT\"', '\"IF_NONE\"', '\"INT\"', '\"LAMBDA\"', '\"LE\"', '\"LEFT\"', '\"LOOP\"', '\"LSL\"', '\"LSR\"', '\"LT\"', '\"MAP\"', '\"MEM\"', '\"MUL\"', '\"NEG\"', '\"NEQ\"', '\"NIL\"', '\"NONE\"', '\"NOT\"', '\"NOW\"', '\"OR\"', '\"PAIR\"', '\"PUSH\"', '\"RIGHT\"', '\"SIZE\"', '\"SOME\"', '\"SOURCE\"', '\"SENDER\"', '\"SELF\"', '\"STEPS_TO_QUOTA\"', '\"SUB\"', '\"SWAP\"', '\"TRANSFER_TOKENS\"', '\"SET_DELEGATE\"', '\"UNIT\"', '\"UPDATE\"', '\"XOR\"', '\"ITER\"', '\"LOOP_LEFT\"', '\"ADDRESS\"', '\"CONTRACT\"', '\"ISNAT\"', '\"CAST\"', '\"RENAME\"', '\"bool\"', '\"contract\"', '\"int\"', '\"key\"', '\"key_hash\"', '\"lambda\"', '\"list\"', '\"map\"', '\"big_map\"', '\"nat\"', '\"option\"', '\"or\"', '\"pair\"', '\"set\"', '\"signature\"', '\"string\"', '\"bytes\"', '\"mutez\"', '\"timestamp\"', '\"unit\"', '\"operation\"', '\"address\"', '\"SLICE\"', '\"DEFAULT_ACCOUNT\"', '\"tez\"'];\nvar TezosLanguageUtil;\n(function (TezosLanguageUtil) {\n    function hexToMicheline(hex) {\n        if (hex.length < 2) {\n            throw new Error(`Malformed Micheline fragment '${hex}'`);\n        }\n        let code = '';\n        let offset = 0;\n        let fieldType = hex.substring(offset, offset + 2);\n        offset += 2;\n        switch (fieldType) {\n            case '00': {\n                const value = TezosMessageUtil_1.TezosMessageUtils.findInt(hex.substring(offset), 0, true);\n                code += `{ \"int\": \"${value.value}\" }`;\n                offset += value.length;\n                break;\n            }\n            case '01': {\n                const stringEnvelope = michelineHexToString(hex.substring(offset));\n                code += `{ \"string\": \"${stringEnvelope.code}\" }`;\n                offset += stringEnvelope.consumed;\n                break;\n            }\n            case '02': {\n                const length = parseInt(hex.substring(offset, offset + 8), 16);\n                offset += 8;\n                let buffer = [];\n                let consumed = 0;\n                while (consumed < length) {\n                    let envelope = hexToMicheline(hex.substring(offset));\n                    buffer.push(envelope.code);\n                    consumed += envelope.consumed / 2;\n                    offset += envelope.consumed;\n                }\n                if (length === 0) {\n                    code += '[]';\n                }\n                else {\n                    code += `[ ${buffer.join(', ')} ]`;\n                }\n                break;\n            }\n            case '03': {\n                code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)} }`;\n                offset += 2;\n                break;\n            }\n            case '04': {\n                code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n                offset += 2;\n                const annEnvelope = michelineHexToAnnotations(hex.substring(offset));\n                code += `\"annots\": [ ${annEnvelope.code} ] }`;\n                offset += annEnvelope.consumed;\n                break;\n            }\n            case '05': {\n                code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n                offset += 2;\n                const envelope = hexToMicheline(hex.substring(offset));\n                code += `\"args\": [ ${envelope.code} ] }`;\n                offset += envelope.consumed;\n                break;\n            }\n            case '06': {\n                code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n                offset += 2;\n                const args = hexToMicheline(hex.substring(offset));\n                code += `\"args\": [ ${args.code} ], `;\n                offset += args.consumed;\n                const anns = michelineHexToAnnotations(hex.substring(offset));\n                code += `\"annots\": [ ${anns.code} ] }`;\n                offset += anns.consumed;\n                break;\n            }\n            case '07': {\n                code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n                offset += 2;\n                let buffer = [];\n                let envelope = hexToMicheline(hex.substring(offset));\n                buffer.push(envelope.code);\n                offset += envelope.consumed;\n                envelope = hexToMicheline(hex.substring(offset));\n                buffer.push(envelope.code);\n                offset += envelope.consumed;\n                code += `\"args\": [ ${buffer.join(', ')} ] }`;\n                break;\n            }\n            case '08': {\n                code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n                offset += 2;\n                const arg0 = hexToMicheline(hex.substring(offset));\n                offset += arg0.consumed;\n                const arg1 = hexToMicheline(hex.substring(offset));\n                offset += arg1.consumed;\n                code += `\"args\": [ ${arg0.code}, ${arg1.code} ], `;\n                const anns = michelineHexToAnnotations(hex.substring(offset));\n                code += `\"annots\": [ ${anns.code} ] }`;\n                offset += anns.consumed;\n                break;\n            }\n            case '09': {\n                code += `{ \"prim\": ${michelineHexToKeyword(hex, offset)}, `;\n                offset += 2;\n                let envelope = hexToMicheline('02' + hex.substring(offset));\n                code += `\"args\": ${envelope.code}`;\n                offset += envelope.consumed - 2;\n                if (hex.substring(offset, offset + 8) !== '00000000') {\n                    const annEnvelope = michelineHexToAnnotations(hex.substring(offset));\n                    if (annEnvelope.code.length > 2) {\n                        code += `, \"annots\": [ ${annEnvelope.code} ] }`;\n                    }\n                    offset += annEnvelope.consumed;\n                }\n                else {\n                    code += ' }';\n                    offset += 8;\n                }\n                break;\n            }\n            case '0a': {\n                const length = parseInt(hex.substring(offset, offset + 8), 16);\n                offset += 8;\n                code += `{ \"bytes\": \"${hex.substring(offset, offset + length * 2)}\" }`;\n                offset += length * 2;\n                break;\n            }\n            default: {\n                throw new Error(`Unknown Micheline field type '${fieldType}'`);\n            }\n        }\n        return { code: code, consumed: offset };\n    }\n    TezosLanguageUtil.hexToMicheline = hexToMicheline;\n    function translateMichelsonToMicheline(code) {\n        const parser = new nearley.Parser(nearley.Grammar.fromCompiled(Michelson.default));\n        preProcessMichelsonScript(code).forEach(p => { parser.feed(p); });\n        return parser.results[0];\n    }\n    TezosLanguageUtil.translateMichelsonToMicheline = translateMichelsonToMicheline;\n    function translateParameterMichelsonToMicheline(code) {\n        return translateMichelsonToMicheline(code);\n    }\n    TezosLanguageUtil.translateParameterMichelsonToMicheline = translateParameterMichelsonToMicheline;\n    function translateMichelsonToHex(code) {\n        return preProcessMicheline(translateMichelsonToMicheline(code))\n            .map(p => { var c = normalizeMichelineWhiteSpace(p); return c; })\n            .map(p => translateMichelineToHex(p))\n            .reduce((m, p) => { return m += ('0000000' + (p.length / 2).toString(16)).slice(-8) + p; }, '');\n    }\n    TezosLanguageUtil.translateMichelsonToHex = translateMichelsonToHex;\n    function preProcessMicheline(code) {\n        const container = JSON.parse(code);\n        let parts = [];\n        parts.push(getSection(container, 'code'));\n        parts.push(getSection(container, 'storage'));\n        return parts;\n    }\n    function getSection(container, key) {\n        let root = container;\n        if (!!container.script) {\n            root = container.script;\n        }\n        for (let i = 0; i < root.length; i++) {\n            if (root[i]['prim'] === key) {\n                return JSON.stringify(root[i], null, 1);\n            }\n        }\n        throw new Error(`${key} key was not found`);\n    }\n    function translateMichelineToHex(code) {\n        const parser = new nearley.Parser(nearley.Grammar.fromCompiled(Micheline.default));\n        parser.feed(normalizeMichelineWhiteSpace(code));\n        return parser.results.join('');\n    }\n    TezosLanguageUtil.translateMichelineToHex = translateMichelineToHex;\n    function michelineHexToString(hex) {\n        let offset = 0;\n        const length = parseInt(hex.substring(offset, offset + 8), 16);\n        offset += 8;\n        const text = Buffer.from(hex.substring(offset, offset + length * 2), 'hex').toString();\n        offset += length * 2;\n        return { code: text, consumed: offset };\n    }\n    function michelineHexToKeyword(hex, offset) {\n        return MichelineKeywords[parseInt(hex.substring(offset, offset + 2), 16)];\n    }\n    function michelineHexToAnnotations(hex) {\n        const stringEnvelope = michelineHexToString(hex);\n        return { code: stringEnvelope.code.split(' ').map(s => `\"${s}\"`).join(', '), consumed: stringEnvelope.consumed };\n    }\n    function preProcessMichelsonScript(code) {\n        let sections = new Map();\n        sections['parameter'] = code.search(/(^|\\s+)parameter/m);\n        sections['storage'] = code.search(/(^|\\s+)storage/m);\n        sections['code'] = code.search(/(^|\\s+)code/m);\n        const boundaries = Object.values(sections).sort((a, b) => Number(a) - Number(b));\n        sections[Object.keys(sections).find(key => sections[key] === boundaries[0]) + ''] = code.substring(boundaries[0], boundaries[1]);\n        sections[Object.keys(sections).find(key => sections[key] === boundaries[1]) + ''] = code.substring(boundaries[1], boundaries[2]);\n        sections[Object.keys(sections).find(key => sections[key] === boundaries[2]) + ''] = code.substring(boundaries[2]);\n        const parts = [sections['parameter'], sections['storage'], sections['code']];\n        return parts.map(p => p.trim().split('\\n').map(l => l.replace(/\\#[\\s\\S]+$/, '').trim()).filter(v => v.length > 0).join(' '));\n    }\n    TezosLanguageUtil.preProcessMichelsonScript = preProcessMichelsonScript;\n    function normalizeMichelineWhiteSpace(fragment) {\n        return fragment.replace(/\\n/g, ' ')\n            .replace(/ +/g, ' ')\n            .replace(/\\[{/g, '[ {')\n            .replace(/}\\]/g, '} ]')\n            .replace(/},{/g, '}, {')\n            .replace(/\\]}/g, '] }')\n            .replace(/\":\"/g, '\": \"')\n            .replace(/\":\\[/g, '\": [')\n            .replace(/{\"/g, '{ \"')\n            .replace(/\"}/g, '\" }')\n            .replace(/,\"/g, ', \"')\n            .replace(/\",\"/g, '\", \"')\n            .replace(/\\[\\[/g, '[ [')\n            .replace(/\\]\\]/g, '] ]')\n            .replace(/\\[\"/g, '\\[ \"')\n            .replace(/\"\\]/g, '\" \\]')\n            .replace(/\\[ +\\]/g, '\\[\\]')\n            .trim();\n    }\n    TezosLanguageUtil.normalizeMichelineWhiteSpace = normalizeMichelineWhiteSpace;\n    function stripComments(fragment) {\n        return fragment.trim().split('\\n').map(l => l.replace(/\\#[\\s\\S]+$/, '').trim()).filter(v => v.length > 0).join(' ');\n    }\n    TezosLanguageUtil.stripComments = stripComments;\n})(TezosLanguageUtil = exports.TezosLanguageUtil || (exports.TezosLanguageUtil = {}));\n//# sourceMappingURL=TezosLanguageUtil.js.map"]},"metadata":{},"sourceType":"script"}