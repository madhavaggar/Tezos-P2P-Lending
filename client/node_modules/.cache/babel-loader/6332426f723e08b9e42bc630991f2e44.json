{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst QueryTypes_1 = require(\"../types/conseil/QueryTypes\");\n\nvar ConseilQueryBuilder;\n\n(function (ConseilQueryBuilder) {\n  function blankQuery() {\n    return {\n      fields: [],\n      predicates: [],\n      orderBy: [],\n      aggregation: [],\n      limit: 100\n    };\n  }\n\n  ConseilQueryBuilder.blankQuery = blankQuery;\n\n  function addFields(query, ...fields) {\n    let q = Object.assign({}, query);\n    let fieldSet = new Set(query.fields);\n    fields.forEach(f => fieldSet.add(f));\n    q.fields = Array.from(fieldSet.values());\n    return q;\n  }\n\n  ConseilQueryBuilder.addFields = addFields;\n\n  function addPredicate(query, field, operation, values, invert = false, group = undefined) {\n    if (operation === QueryTypes_1.ConseilOperator.BETWEEN && values.length !== 2) {\n      throw new Error('BETWEEN operation requires a list of two values.');\n    } else if (operation === QueryTypes_1.ConseilOperator.IN && values.length < 2) {\n      throw new Error('IN operation requires a list of two or more values.');\n    } else if (values.length !== 1 && operation !== QueryTypes_1.ConseilOperator.IN && operation !== QueryTypes_1.ConseilOperator.BETWEEN && operation !== QueryTypes_1.ConseilOperator.ISNULL) {\n      throw new Error(`invalid values list for ${operation}.`);\n    }\n\n    let q = Object.assign({}, query);\n    q.predicates.push({\n      field,\n      operation,\n      set: values,\n      inverse: invert,\n      group\n    });\n    return q;\n  }\n\n  ConseilQueryBuilder.addPredicate = addPredicate;\n\n  function addOrdering(query, field, direction = QueryTypes_1.ConseilSortDirection.ASC) {\n    let q = Object.assign({}, query);\n    q.orderBy.push({\n      field,\n      direction\n    });\n    return q;\n  }\n\n  ConseilQueryBuilder.addOrdering = addOrdering;\n\n  function setLimit(query, limit) {\n    if (limit < 1) {\n      throw new Error('Limit cannot be less than one.');\n    }\n\n    let q = Object.assign({}, query);\n    q.limit = limit;\n    return q;\n  }\n\n  ConseilQueryBuilder.setLimit = setLimit;\n\n  function setOutputType(query, outputType) {\n    let q = Object.assign({}, query);\n    q.output = outputType;\n    return q;\n  }\n\n  ConseilQueryBuilder.setOutputType = setOutputType;\n\n  function addAggregationFunction(query, field, aggregationFunction) {\n    if (!query.fields.includes(field)) {\n      throw new Error('Cannot apply an aggregation function on a field not being returned.');\n    }\n\n    let q = Object.assign({}, query);\n    q.aggregation.push({\n      'field': field,\n      'function': aggregationFunction\n    });\n    return q;\n  }\n\n  ConseilQueryBuilder.addAggregationFunction = addAggregationFunction;\n})(ConseilQueryBuilder = exports.ConseilQueryBuilder || (exports.ConseilQueryBuilder = {}));","map":{"version":3,"sources":["../../src/reporting/ConseilQueryBuilder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst QueryTypes_1 = require(\"../types/conseil/QueryTypes\");\nvar ConseilQueryBuilder;\n(function (ConseilQueryBuilder) {\n    function blankQuery() {\n        return {\n            fields: [],\n            predicates: [],\n            orderBy: [],\n            aggregation: [],\n            limit: 100\n        };\n    }\n    ConseilQueryBuilder.blankQuery = blankQuery;\n    function addFields(query, ...fields) {\n        let q = Object.assign({}, query);\n        let fieldSet = new Set(query.fields);\n        fields.forEach(f => fieldSet.add(f));\n        q.fields = Array.from(fieldSet.values());\n        return q;\n    }\n    ConseilQueryBuilder.addFields = addFields;\n    function addPredicate(query, field, operation, values, invert = false, group = undefined) {\n        if (operation === QueryTypes_1.ConseilOperator.BETWEEN && values.length !== 2) {\n            throw new Error('BETWEEN operation requires a list of two values.');\n        }\n        else if (operation === QueryTypes_1.ConseilOperator.IN && values.length < 2) {\n            throw new Error('IN operation requires a list of two or more values.');\n        }\n        else if (values.length !== 1 && operation !== QueryTypes_1.ConseilOperator.IN && operation !== QueryTypes_1.ConseilOperator.BETWEEN && operation !== QueryTypes_1.ConseilOperator.ISNULL) {\n            throw new Error(`invalid values list for ${operation}.`);\n        }\n        let q = Object.assign({}, query);\n        q.predicates.push({ field, operation, set: values, inverse: invert, group });\n        return q;\n    }\n    ConseilQueryBuilder.addPredicate = addPredicate;\n    function addOrdering(query, field, direction = QueryTypes_1.ConseilSortDirection.ASC) {\n        let q = Object.assign({}, query);\n        q.orderBy.push({ field, direction });\n        return q;\n    }\n    ConseilQueryBuilder.addOrdering = addOrdering;\n    function setLimit(query, limit) {\n        if (limit < 1) {\n            throw new Error('Limit cannot be less than one.');\n        }\n        let q = Object.assign({}, query);\n        q.limit = limit;\n        return q;\n    }\n    ConseilQueryBuilder.setLimit = setLimit;\n    function setOutputType(query, outputType) {\n        let q = Object.assign({}, query);\n        q.output = outputType;\n        return q;\n    }\n    ConseilQueryBuilder.setOutputType = setOutputType;\n    function addAggregationFunction(query, field, aggregationFunction) {\n        if (!query.fields.includes(field)) {\n            throw new Error('Cannot apply an aggregation function on a field not being returned.');\n        }\n        let q = Object.assign({}, query);\n        q.aggregation.push({ 'field': field, 'function': aggregationFunction });\n        return q;\n    }\n    ConseilQueryBuilder.addAggregationFunction = addAggregationFunction;\n})(ConseilQueryBuilder = exports.ConseilQueryBuilder || (exports.ConseilQueryBuilder = {}));\n//# sourceMappingURL=ConseilQueryBuilder.js.map"]},"metadata":{},"sourceType":"script"}