{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction id(d) {\n  return d[0];\n}\n\nconst moo = require(\"moo\");\n\nconst lexer = moo.compile({\n  wspace: /[ \\t]+/,\n  lparen: '(',\n  rparen: ')',\n  annot: /:[^ );]+|%[^ );]+/,\n  parameter: 'parameter',\n  or: 'or',\n  pair: 'pair',\n  data: ['bytes', 'int', 'nat', 'bool', 'string', 'timestamp', 'signature', 'key', 'key_hash', 'mutez', 'address', 'unit', 'operation', 'chain_id'],\n  singleArgData: ['option', 'list', 'contract', 'set'],\n  doubleArgData: ['lambda', 'map', 'big_map'],\n  semicolon: ';'\n});\n\nconst breakParameter = d => {\n  return d[2];\n};\n\nconst stripParen = d => d[2];\n\nconst branchOrWithTwoAnnot = d => {\n  const annotA = d[2];\n  const annotB = d[4];\n  const leftEntryPoints = d[6];\n  const rightEntryPoints = d[8];\n  const branchedEntryPoints = [];\n\n  for (const leftEntryPoint of leftEntryPoints) {\n    const branchedEntryPoint = {\n      name: leftEntryPoint.name,\n      parameters: leftEntryPoint.parameters,\n      structure: '(Left ' + leftEntryPoint.structure + ')',\n      generateInvocationString: leftEntryPoint.generateInvocationString,\n      generateInvocationPair: leftEntryPoint.generateInvocationPair,\n      generateSampleInvocation: leftEntryPoint.generateSampleInvocation\n    };\n    branchedEntryPoints.push(branchedEntryPoint);\n  }\n\n  for (const rightEntryPoint of rightEntryPoints) {\n    const branchedEntryPoint = {\n      name: rightEntryPoint.name,\n      parameters: rightEntryPoint.parameters,\n      structure: '(Right ' + rightEntryPoint.structure + ')',\n      generateInvocationString: rightEntryPoint.generateInvocationString,\n      generateInvocationPair: rightEntryPoint.generateInvocationPair,\n      generateSampleInvocation: rightEntryPoint.generateSampleInvocation\n    };\n    branchedEntryPoints.push(branchedEntryPoint);\n  }\n\n  return branchedEntryPoints;\n};\n\nconst branchOrWithAnnot = d => {\n  const annot = d[2];\n  const leftEntryPoints = d[4];\n  const rightEntryPoints = d[6];\n  const branchedEntryPoints = [];\n\n  for (const leftEntryPoint of leftEntryPoints) {\n    const branchedEntryPoint = {\n      name: `${annot}.${leftEntryPoint.name}`,\n      parameters: leftEntryPoint.parameters,\n      structure: '(Left ' + leftEntryPoint.structure + ')',\n      generateInvocationString: leftEntryPoint.generateInvocationString,\n      generateInvocationPair: leftEntryPoint.generateInvocationPair,\n      generateSampleInvocation: leftEntryPoint.generateSampleInvocation\n    };\n    branchedEntryPoints.push(branchedEntryPoint);\n  }\n\n  for (const rightEntryPoint of rightEntryPoints) {\n    const branchedEntryPoint = {\n      name: `${annot}.${rightEntryPoint.name}`,\n      parameters: rightEntryPoint.parameters,\n      structure: '(Right ' + rightEntryPoint.structure + ')',\n      generateInvocationString: rightEntryPoint.generateInvocationString,\n      generateInvocationPair: rightEntryPoint.generateInvocationPair,\n      generateSampleInvocation: rightEntryPoint.generateSampleInvocation\n    };\n    branchedEntryPoints.push(branchedEntryPoint);\n  }\n\n  return branchedEntryPoints;\n};\n\nconst branchOr = d => {\n  const leftEntryPoints = d[2];\n  const rightEntryPoints = d[4];\n  const branchedEntryPoints = [];\n\n  for (const leftEntryPoint of leftEntryPoints) {\n    if (leftEntryPoint.parameters.length === 1 && leftEntryPoint.parameters[0].name === leftEntryPoint.name) {\n      leftEntryPoint.parameters[0].name = undefined;\n    }\n\n    branchedEntryPoints.push(Object.assign(Object.assign({}, leftEntryPoint), {\n      structure: `(Left ${leftEntryPoint.structure})`\n    }));\n  }\n\n  for (const rightEntryPoint of rightEntryPoints) {\n    if (rightEntryPoint.parameters.length === 1 && rightEntryPoint.parameters[0].name === rightEntryPoint.name) {\n      rightEntryPoint.parameters[0].name = undefined;\n    }\n\n    branchedEntryPoints.push(Object.assign(Object.assign({}, rightEntryPoint), {\n      structure: `(Right ${rightEntryPoint.structure})`\n    }));\n  }\n\n  return branchedEntryPoints;\n};\n\nconst mergePairWithTwoAnnot = d => {\n  const annotA = d[2];\n  const annotB = d[4];\n  const firstEntryPoints = d[6];\n  const secondEntryPoints = d[8];\n  const pairedEntryPoints = [];\n\n  for (const firstEntryPoint of firstEntryPoints) {\n    for (const secondEntryPoint of secondEntryPoints) {\n      const pairedEntryPoint = {\n        name: getTypeAnnotation(annotA.toString(), annotB.toString()),\n        parameters: firstEntryPoint.parameters.concat(secondEntryPoint.parameters),\n        structure: `(Pair ${firstEntryPoint.structure} ${secondEntryPoint.structure})`,\n        generateInvocationString: firstEntryPoint.generateInvocationString,\n        generateInvocationPair: firstEntryPoint.generateInvocationPair,\n        generateSampleInvocation: firstEntryPoint.generateSampleInvocation\n      };\n      pairedEntryPoints.push(pairedEntryPoint);\n    }\n  }\n\n  return pairedEntryPoints;\n};\n\nconst mergePairWithAnnot = d => {\n  const annot = d[2];\n  const firstEntryPoints = d[4];\n  const secondEntryPoints = d[6];\n  const pairedEntryPoints = [];\n\n  for (const firstEntryPoint of firstEntryPoints) {\n    for (const secondEntryPoint of secondEntryPoints) {\n      const name = getTypeAnnotation(annot.toString()) || getFieldAnnotation(annot.toString());\n      const pairedEntryPoint = {\n        name: name || undefined,\n        parameters: firstEntryPoint.parameters.concat(secondEntryPoint.parameters),\n        structure: `(Pair ${firstEntryPoint.structure} ${secondEntryPoint.structure})`,\n        generateInvocationString: firstEntryPoint.generateInvocationString,\n        generateInvocationPair: firstEntryPoint.generateInvocationPair,\n        generateSampleInvocation: firstEntryPoint.generateSampleInvocation\n      };\n      pairedEntryPoints.push(pairedEntryPoint);\n    }\n  }\n\n  return pairedEntryPoints;\n};\n\nconst mergePair = d => {\n  const firstEntryPoints = d[2];\n  const secondEntryPoints = d[4];\n  const pairedEntryPoints = [];\n\n  for (const firstEntryPoint of firstEntryPoints) {\n    for (const secondEntryPoint of secondEntryPoints) {\n      const pairedEntryPoint = {\n        name: undefined,\n        parameters: firstEntryPoint.parameters.concat(secondEntryPoint.parameters),\n        structure: `(Pair ${firstEntryPoint.structure} ${secondEntryPoint.structure})`,\n        generateInvocationString: firstEntryPoint.generateInvocationString,\n        generateInvocationPair: firstEntryPoint.generateInvocationPair,\n        generateSampleInvocation: firstEntryPoint.generateSampleInvocation\n      };\n      pairedEntryPoints.push(pairedEntryPoint);\n    }\n  }\n\n  return pairedEntryPoints;\n};\n\nconst recordSingleArgDataWithTwoAnnot = d => {\n  const singleArgData = d[0].toString();\n  const annotA = d[2].toString();\n  const annotB = d[4].toString();\n  const entryPoints = d[6];\n  entryPoints[0].name = getFieldAnnotation(annotA, annotB);\n  entryPoints[0].parameters[0].constituentType = entryPoints[0].parameters[0].type;\n\n  if (singleArgData === 'option') {\n    entryPoints[0].parameters[0].optional = true;\n  }\n\n  entryPoints[0].parameters[0].type = `${singleArgData} (${entryPoints[0].parameters[0].type})`;\n  entryPoints[0].structure = `(${entryPoints[0].structure})`;\n  return entryPoints;\n};\n\nconst recordSingleArgDataWithAnnot = d => {\n  const singleArgData = d[0].toString();\n  const annot = d[2].toString();\n  const entryPoints = d[4];\n  entryPoints[0].name = getFieldAnnotation(annot);\n  entryPoints[0].parameters[0].constituentType = entryPoints[0].parameters[0].type;\n\n  if (singleArgData === 'option') {\n    entryPoints[0].parameters[0].optional = true;\n  }\n\n  entryPoints[0].parameters[0].type = `${singleArgData} (${entryPoints[0].parameters[0].type})`;\n  entryPoints[0].structure = `(${entryPoints[0].structure})`;\n  return entryPoints;\n};\n\nconst recordSingleArgData = d => {\n  const singleArgData = d[0].toString();\n  const entryPoints = d[2];\n  entryPoints[0].parameters[0].constituentType = entryPoints[0].parameters[0].type;\n\n  if (singleArgData === 'option') {\n    entryPoints[0].parameters[0].optional = true;\n  }\n\n  entryPoints[0].parameters[0].type = `${singleArgData} (${entryPoints[0].parameters[0].type})`;\n  entryPoints[0].structure = `(${entryPoints[0].structure})`;\n  return entryPoints;\n};\n\nconst recordDoubleArgDataWithTwoAnnot = d => {\n  const doubleArgData = d[0].toString();\n  const annotA = d[2].toString();\n  const annotB = d[4].toString();\n  const firstEntryPoints = d[6];\n  const secondEntryPoints = d[8];\n  firstEntryPoints[0].name = getFieldAnnotation(annotA, annotB);\n  firstEntryPoints[0].parameters[0].type = `${doubleArgData} (${firstEntryPoints[0].parameters[0].type}) (${secondEntryPoints[0].parameters[0].type})`;\n  firstEntryPoints[0].structure = `(${firstEntryPoints[0].structure})`;\n  return firstEntryPoints;\n};\n\nconst recordDoubleArgDataWithAnnot = d => {\n  const doubleArgData = d[0].toString();\n  const annot = d[2].toString();\n  const firstEntryPoints = d[4];\n  const secondEntryPoints = d[6];\n  firstEntryPoints[0].name = getFieldAnnotation(annot);\n  firstEntryPoints[0].parameters[0].type = `${doubleArgData} (${firstEntryPoints[0].parameters[0].type}) (${secondEntryPoints[0].parameters[0].type})`;\n  firstEntryPoints[0].structure = `(${firstEntryPoints[0].structure})`;\n  return firstEntryPoints;\n};\n\nconst recordDoubleArgData = d => {\n  const doubleArgData = d[0].toString();\n  const firstEntryPoints = d[2];\n  const secondEntryPoints = d[4];\n  firstEntryPoints[0].parameters[0].type = `${doubleArgData} (${firstEntryPoints[0].parameters[0].type}) (${secondEntryPoints[0].parameters[0].type})`;\n  firstEntryPoints[0].structure = `(${firstEntryPoints[0].structure})`;\n  return firstEntryPoints;\n};\n\nconst recordData = d => {\n  let parameterName = undefined;\n  let entryPointName = undefined;\n\n  if (d.length >= 3) {\n    const annot = d[2].toString();\n\n    if (annot.charAt(0) === '%') {\n      entryPointName = formatFieldAnnotation(annot);\n    } else {\n      parameterName = formatTypeAnnotation(annot);\n    }\n  }\n\n  if (d.length === 5) {\n    const anotherAnnot = d[4].toString();\n\n    if (anotherAnnot.startsWith('%') && entryPointName === undefined) {\n      entryPointName = formatFieldAnnotation(anotherAnnot);\n    }\n\n    if (anotherAnnot.startsWith(':') && parameterName === undefined) {\n      parameterName = formatTypeAnnotation(anotherAnnot);\n    }\n  }\n\n  const parameter = {\n    name: parameterName || entryPointName,\n    type: d[0].toString()\n  };\n  const entryPoint = {\n    name: entryPointName,\n    parameters: [parameter],\n    structure: '$PARAM',\n\n    generateInvocationString(...vars) {\n      if (this.parameters.length !== vars.length) {\n        throw new Error(`Incorrect number of parameters provided; expected ${this.parameters.length}, got ${vars.length}`);\n      }\n\n      let invocationParameter = this.structure;\n\n      for (let i = 0; i < this.parameters.length; i++) {\n        let val = vars[i];\n\n        if (this.parameters[i].type === 'unit') {\n          val = 'Unit';\n        }\n\n        if (this.parameters[i].type.startsWith('list')) {\n          if (!Array.isArray(val)) {\n            throw new Error(`${JSON.stringify(this.parameters[i])} requires an array value`);\n          }\n\n          val = `{${val.join('; ')}}`;\n        }\n\n        if (this.parameters[i].optional && vars[i]) {\n          val = `Some ${val}`;\n        } else if (this.parameters[i].optional && !vars[i]) {\n          val = 'None';\n        }\n\n        invocationParameter = invocationParameter.replace('$PARAM', val);\n      }\n\n      return invocationParameter;\n    },\n\n    generateInvocationPair(...vars) {\n      let param = this.generateInvocationString(...vars);\n\n      while (param.startsWith('(Left ') || param.startsWith('(Right ')) {\n        if (param.startsWith('(Left ')) {\n          param = param.slice(6, -1);\n        }\n\n        if (param.startsWith('(Right ')) {\n          param = param.slice(7, -1);\n        }\n      }\n\n      return {\n        entrypoint: this.name,\n        parameters: param\n      };\n    },\n\n    generateSampleInvocation() {\n      const params = this.parameters.map(p => {\n        switch (p.type) {\n          case 'string':\n            {\n              return '\"Tacos\"';\n            }\n\n          case 'int':\n            {\n              return -1;\n            }\n\n          case 'nat':\n            {\n              return 99;\n            }\n\n          case 'address':\n            {\n              return '\"KT1EGbAxguaWQFkV3Egb2Z1r933MWuEYyrJS\"';\n            }\n\n          case 'key_hash':\n            {\n              return '\"tz1SQnJaocpquTztY3zMgydTPoQBBQrDGonJ\"';\n            }\n\n          case 'timestamp':\n            {\n              return `\"${new Date().toISOString()}\"`;\n            }\n\n          case 'mutez':\n            {\n              return 500000;\n            }\n\n          case 'unit':\n            {\n              return 'Unit';\n            }\n\n          case 'bytes':\n          case 'bool':\n          case 'signature':\n          case 'key':\n          case 'operation':\n          case 'chain_id':\n          default:\n            {\n              return p.type;\n            }\n        }\n      });\n      return this.generateInvocationString(...params);\n    }\n\n  };\n  return [entryPoint];\n};\n\nconst getFieldAnnotation = (...annot) => {\n  const fa = annot.find(a => a.startsWith('%'));\n  return !!fa ? formatFieldAnnotation(fa) : undefined;\n};\n\nconst getTypeAnnotation = (...annot) => {\n  const ta = annot.find(a => a.startsWith(':'));\n  return !!ta ? formatTypeAnnotation(ta) : undefined;\n};\n\nconst formatFieldAnnotation = annot => {\n  if (!annot.startsWith('%')) {\n    throw new Error(`${annot} must start with '%'`);\n  }\n\n  return annot.replace(/^%_Liq_entry_/, '').replace('%', '');\n};\n\nconst formatTypeAnnotation = annot => {\n  if (!annot.startsWith(':')) {\n    throw new Error(`${annot} must start with ':'`);\n  }\n\n  return annot.replace(':', '');\n};\n\n;\n;\n;\n;\nconst grammar = {\n  Lexer: lexer,\n  ParserRules: [{\n    \"name\": \"entry\",\n    \"symbols\": [lexer.has(\"parameter\") ? {\n      type: \"parameter\"\n    } : parameter, \"__\", \"parameters\", \"_\", lexer.has(\"semicolon\") ? {\n      type: \"semicolon\"\n    } : semicolon],\n    \"postprocess\": breakParameter\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", \"parameters\", \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": stripParen\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"or\") ? {\n      type: \"or\"\n    } : or, \"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", \"parameters\", \"__\", \"parameters\"],\n    \"postprocess\": branchOrWithTwoAnnot\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"or\") ? {\n      type: \"or\"\n    } : or, \"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", \"parameters\", \"__\", \"parameters\"],\n    \"postprocess\": branchOrWithAnnot\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"or\") ? {\n      type: \"or\"\n    } : or, \"_\", \"parameters\", \"__\", \"parameters\"],\n    \"postprocess\": branchOr\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"pair\") ? {\n      type: \"pair\"\n    } : pair, \"__\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", \"parameters\", \"__\", \"parameters\"],\n    \"postprocess\": mergePairWithTwoAnnot\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"pair\") ? {\n      type: \"pair\"\n    } : pair, \"__\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", \"parameters\", \"__\", \"parameters\"],\n    \"postprocess\": mergePairWithAnnot\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"pair\") ? {\n      type: \"pair\"\n    } : pair, \"__\", \"parameters\", \"__\", \"parameters\"],\n    \"postprocess\": mergePair\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"singleArgData\") ? {\n      type: \"singleArgData\"\n    } : singleArgData, \"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", \"parameters\"],\n    \"postprocess\": recordSingleArgDataWithTwoAnnot\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"singleArgData\") ? {\n      type: \"singleArgData\"\n    } : singleArgData, \"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", \"parameters\"],\n    \"postprocess\": recordSingleArgDataWithAnnot\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"singleArgData\") ? {\n      type: \"singleArgData\"\n    } : singleArgData, \"_\", \"parameters\"],\n    \"postprocess\": recordSingleArgData\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"doubleArgData\") ? {\n      type: \"doubleArgData\"\n    } : doubleArgData, \"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", \"parameters\", \"__\", \"parameters\"],\n    \"postprocess\": recordDoubleArgDataWithTwoAnnot\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"doubleArgData\") ? {\n      type: \"doubleArgData\"\n    } : doubleArgData, \"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", \"parameters\", \"__\", \"parameters\"],\n    \"postprocess\": recordDoubleArgDataWithAnnot\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"doubleArgData\") ? {\n      type: \"doubleArgData\"\n    } : doubleArgData, \"_\", \"parameters\", \"__\", \"parameters\"],\n    \"postprocess\": recordDoubleArgData\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"data\") ? {\n      type: \"data\"\n    } : data, \"__\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot],\n    \"postprocess\": recordData\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"data\") ? {\n      type: \"data\"\n    } : data, \"__\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot, \"__\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot],\n    \"postprocess\": recordData\n  }, {\n    \"name\": \"parameters\",\n    \"symbols\": [lexer.has(\"data\") ? {\n      type: \"data\"\n    } : data],\n    \"postprocess\": recordData\n  }, {\n    \"name\": \"_$ebnf$1\",\n    \"symbols\": []\n  }, {\n    \"name\": \"_$ebnf$1\",\n    \"symbols\": [\"_$ebnf$1\", /[\\s]/],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"_\",\n    \"symbols\": [\"_$ebnf$1\"]\n  }, {\n    \"name\": \"__\",\n    \"symbols\": [/[\\s]/]\n  }],\n  ParserStart: \"entry\"\n};\nexports.default = grammar;","map":{"version":3,"sources":["../../../../src/chain/tezos/lexer/EntryPointTemplate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction id(d) { return d[0]; }\nconst moo = require(\"moo\");\nconst lexer = moo.compile({\n    wspace: /[ \\t]+/,\n    lparen: '(',\n    rparen: ')',\n    annot: /:[^ );]+|%[^ );]+/,\n    parameter: 'parameter',\n    or: 'or',\n    pair: 'pair',\n    data: ['bytes', 'int', 'nat', 'bool', 'string', 'timestamp', 'signature', 'key', 'key_hash', 'mutez', 'address', 'unit', 'operation', 'chain_id'],\n    singleArgData: ['option', 'list', 'contract', 'set'],\n    doubleArgData: ['lambda', 'map', 'big_map'],\n    semicolon: ';'\n});\nconst breakParameter = (d) => { return d[2]; };\nconst stripParen = (d) => d[2];\nconst branchOrWithTwoAnnot = (d) => {\n    const annotA = d[2];\n    const annotB = d[4];\n    const leftEntryPoints = d[6];\n    const rightEntryPoints = d[8];\n    const branchedEntryPoints = [];\n    for (const leftEntryPoint of leftEntryPoints) {\n        const branchedEntryPoint = {\n            name: leftEntryPoint.name,\n            parameters: leftEntryPoint.parameters,\n            structure: '(Left ' + leftEntryPoint.structure + ')',\n            generateInvocationString: leftEntryPoint.generateInvocationString,\n            generateInvocationPair: leftEntryPoint.generateInvocationPair,\n            generateSampleInvocation: leftEntryPoint.generateSampleInvocation\n        };\n        branchedEntryPoints.push(branchedEntryPoint);\n    }\n    for (const rightEntryPoint of rightEntryPoints) {\n        const branchedEntryPoint = {\n            name: rightEntryPoint.name,\n            parameters: rightEntryPoint.parameters,\n            structure: '(Right ' + rightEntryPoint.structure + ')',\n            generateInvocationString: rightEntryPoint.generateInvocationString,\n            generateInvocationPair: rightEntryPoint.generateInvocationPair,\n            generateSampleInvocation: rightEntryPoint.generateSampleInvocation\n        };\n        branchedEntryPoints.push(branchedEntryPoint);\n    }\n    return branchedEntryPoints;\n};\nconst branchOrWithAnnot = (d) => {\n    const annot = d[2];\n    const leftEntryPoints = d[4];\n    const rightEntryPoints = d[6];\n    const branchedEntryPoints = [];\n    for (const leftEntryPoint of leftEntryPoints) {\n        const branchedEntryPoint = {\n            name: `${annot}.${leftEntryPoint.name}`,\n            parameters: leftEntryPoint.parameters,\n            structure: '(Left ' + leftEntryPoint.structure + ')',\n            generateInvocationString: leftEntryPoint.generateInvocationString,\n            generateInvocationPair: leftEntryPoint.generateInvocationPair,\n            generateSampleInvocation: leftEntryPoint.generateSampleInvocation\n        };\n        branchedEntryPoints.push(branchedEntryPoint);\n    }\n    for (const rightEntryPoint of rightEntryPoints) {\n        const branchedEntryPoint = {\n            name: `${annot}.${rightEntryPoint.name}`,\n            parameters: rightEntryPoint.parameters,\n            structure: '(Right ' + rightEntryPoint.structure + ')',\n            generateInvocationString: rightEntryPoint.generateInvocationString,\n            generateInvocationPair: rightEntryPoint.generateInvocationPair,\n            generateSampleInvocation: rightEntryPoint.generateSampleInvocation\n        };\n        branchedEntryPoints.push(branchedEntryPoint);\n    }\n    return branchedEntryPoints;\n};\nconst branchOr = (d) => {\n    const leftEntryPoints = d[2];\n    const rightEntryPoints = d[4];\n    const branchedEntryPoints = [];\n    for (const leftEntryPoint of leftEntryPoints) {\n        if (leftEntryPoint.parameters.length === 1 && leftEntryPoint.parameters[0].name === leftEntryPoint.name) {\n            leftEntryPoint.parameters[0].name = undefined;\n        }\n        branchedEntryPoints.push(Object.assign(Object.assign({}, leftEntryPoint), { structure: `(Left ${leftEntryPoint.structure})` }));\n    }\n    for (const rightEntryPoint of rightEntryPoints) {\n        if (rightEntryPoint.parameters.length === 1 && rightEntryPoint.parameters[0].name === rightEntryPoint.name) {\n            rightEntryPoint.parameters[0].name = undefined;\n        }\n        branchedEntryPoints.push(Object.assign(Object.assign({}, rightEntryPoint), { structure: `(Right ${rightEntryPoint.structure})` }));\n    }\n    return branchedEntryPoints;\n};\nconst mergePairWithTwoAnnot = (d) => {\n    const annotA = d[2];\n    const annotB = d[4];\n    const firstEntryPoints = d[6];\n    const secondEntryPoints = d[8];\n    const pairedEntryPoints = [];\n    for (const firstEntryPoint of firstEntryPoints) {\n        for (const secondEntryPoint of secondEntryPoints) {\n            const pairedEntryPoint = {\n                name: getTypeAnnotation(annotA.toString(), annotB.toString()),\n                parameters: firstEntryPoint.parameters.concat(secondEntryPoint.parameters),\n                structure: `(Pair ${firstEntryPoint.structure} ${secondEntryPoint.structure})`,\n                generateInvocationString: firstEntryPoint.generateInvocationString,\n                generateInvocationPair: firstEntryPoint.generateInvocationPair,\n                generateSampleInvocation: firstEntryPoint.generateSampleInvocation\n            };\n            pairedEntryPoints.push(pairedEntryPoint);\n        }\n    }\n    return pairedEntryPoints;\n};\nconst mergePairWithAnnot = (d) => {\n    const annot = d[2];\n    const firstEntryPoints = d[4];\n    const secondEntryPoints = d[6];\n    const pairedEntryPoints = [];\n    for (const firstEntryPoint of firstEntryPoints) {\n        for (const secondEntryPoint of secondEntryPoints) {\n            const name = getTypeAnnotation(annot.toString()) || getFieldAnnotation(annot.toString());\n            const pairedEntryPoint = {\n                name: name || undefined,\n                parameters: firstEntryPoint.parameters.concat(secondEntryPoint.parameters),\n                structure: `(Pair ${firstEntryPoint.structure} ${secondEntryPoint.structure})`,\n                generateInvocationString: firstEntryPoint.generateInvocationString,\n                generateInvocationPair: firstEntryPoint.generateInvocationPair,\n                generateSampleInvocation: firstEntryPoint.generateSampleInvocation\n            };\n            pairedEntryPoints.push(pairedEntryPoint);\n        }\n    }\n    return pairedEntryPoints;\n};\nconst mergePair = (d) => {\n    const firstEntryPoints = d[2];\n    const secondEntryPoints = d[4];\n    const pairedEntryPoints = [];\n    for (const firstEntryPoint of firstEntryPoints) {\n        for (const secondEntryPoint of secondEntryPoints) {\n            const pairedEntryPoint = {\n                name: undefined,\n                parameters: firstEntryPoint.parameters.concat(secondEntryPoint.parameters),\n                structure: `(Pair ${firstEntryPoint.structure} ${secondEntryPoint.structure})`,\n                generateInvocationString: firstEntryPoint.generateInvocationString,\n                generateInvocationPair: firstEntryPoint.generateInvocationPair,\n                generateSampleInvocation: firstEntryPoint.generateSampleInvocation\n            };\n            pairedEntryPoints.push(pairedEntryPoint);\n        }\n    }\n    return pairedEntryPoints;\n};\nconst recordSingleArgDataWithTwoAnnot = (d) => {\n    const singleArgData = d[0].toString();\n    const annotA = d[2].toString();\n    const annotB = d[4].toString();\n    const entryPoints = d[6];\n    entryPoints[0].name = getFieldAnnotation(annotA, annotB);\n    entryPoints[0].parameters[0].constituentType = entryPoints[0].parameters[0].type;\n    if (singleArgData === 'option') {\n        entryPoints[0].parameters[0].optional = true;\n    }\n    entryPoints[0].parameters[0].type = `${singleArgData} (${entryPoints[0].parameters[0].type})`;\n    entryPoints[0].structure = `(${entryPoints[0].structure})`;\n    return entryPoints;\n};\nconst recordSingleArgDataWithAnnot = (d) => {\n    const singleArgData = d[0].toString();\n    const annot = d[2].toString();\n    const entryPoints = d[4];\n    entryPoints[0].name = getFieldAnnotation(annot);\n    entryPoints[0].parameters[0].constituentType = entryPoints[0].parameters[0].type;\n    if (singleArgData === 'option') {\n        entryPoints[0].parameters[0].optional = true;\n    }\n    entryPoints[0].parameters[0].type = `${singleArgData} (${entryPoints[0].parameters[0].type})`;\n    entryPoints[0].structure = `(${entryPoints[0].structure})`;\n    return entryPoints;\n};\nconst recordSingleArgData = (d) => {\n    const singleArgData = d[0].toString();\n    const entryPoints = d[2];\n    entryPoints[0].parameters[0].constituentType = entryPoints[0].parameters[0].type;\n    if (singleArgData === 'option') {\n        entryPoints[0].parameters[0].optional = true;\n    }\n    entryPoints[0].parameters[0].type = `${singleArgData} (${entryPoints[0].parameters[0].type})`;\n    entryPoints[0].structure = `(${entryPoints[0].structure})`;\n    return entryPoints;\n};\nconst recordDoubleArgDataWithTwoAnnot = (d) => {\n    const doubleArgData = d[0].toString();\n    const annotA = d[2].toString();\n    const annotB = d[4].toString();\n    const firstEntryPoints = d[6];\n    const secondEntryPoints = d[8];\n    firstEntryPoints[0].name = getFieldAnnotation(annotA, annotB);\n    firstEntryPoints[0].parameters[0].type = `${doubleArgData} (${firstEntryPoints[0].parameters[0].type}) (${secondEntryPoints[0].parameters[0].type})`;\n    firstEntryPoints[0].structure = `(${firstEntryPoints[0].structure})`;\n    return firstEntryPoints;\n};\nconst recordDoubleArgDataWithAnnot = (d) => {\n    const doubleArgData = d[0].toString();\n    const annot = d[2].toString();\n    const firstEntryPoints = d[4];\n    const secondEntryPoints = d[6];\n    firstEntryPoints[0].name = getFieldAnnotation(annot);\n    firstEntryPoints[0].parameters[0].type = `${doubleArgData} (${firstEntryPoints[0].parameters[0].type}) (${secondEntryPoints[0].parameters[0].type})`;\n    firstEntryPoints[0].structure = `(${firstEntryPoints[0].structure})`;\n    return firstEntryPoints;\n};\nconst recordDoubleArgData = (d) => {\n    const doubleArgData = d[0].toString();\n    const firstEntryPoints = d[2];\n    const secondEntryPoints = d[4];\n    firstEntryPoints[0].parameters[0].type = `${doubleArgData} (${firstEntryPoints[0].parameters[0].type}) (${secondEntryPoints[0].parameters[0].type})`;\n    firstEntryPoints[0].structure = `(${firstEntryPoints[0].structure})`;\n    return firstEntryPoints;\n};\nconst recordData = (d) => {\n    let parameterName = undefined;\n    let entryPointName = undefined;\n    if (d.length >= 3) {\n        const annot = d[2].toString();\n        if (annot.charAt(0) === '%') {\n            entryPointName = formatFieldAnnotation(annot);\n        }\n        else {\n            parameterName = formatTypeAnnotation(annot);\n        }\n    }\n    if (d.length === 5) {\n        const anotherAnnot = d[4].toString();\n        if (anotherAnnot.startsWith('%') && entryPointName === undefined) {\n            entryPointName = formatFieldAnnotation(anotherAnnot);\n        }\n        if (anotherAnnot.startsWith(':') && parameterName === undefined) {\n            parameterName = formatTypeAnnotation(anotherAnnot);\n        }\n    }\n    const parameter = {\n        name: parameterName || entryPointName,\n        type: d[0].toString()\n    };\n    const entryPoint = {\n        name: entryPointName,\n        parameters: [parameter],\n        structure: '$PARAM',\n        generateInvocationString(...vars) {\n            if (this.parameters.length !== vars.length) {\n                throw new Error(`Incorrect number of parameters provided; expected ${this.parameters.length}, got ${vars.length}`);\n            }\n            let invocationParameter = this.structure;\n            for (let i = 0; i < this.parameters.length; i++) {\n                let val = vars[i];\n                if (this.parameters[i].type === 'unit') {\n                    val = 'Unit';\n                }\n                if (this.parameters[i].type.startsWith('list')) {\n                    if (!Array.isArray(val)) {\n                        throw new Error(`${JSON.stringify(this.parameters[i])} requires an array value`);\n                    }\n                    val = `{${val.join('; ')}}`;\n                }\n                if (this.parameters[i].optional && vars[i]) {\n                    val = `Some ${val}`;\n                }\n                else if (this.parameters[i].optional && !vars[i]) {\n                    val = 'None';\n                }\n                invocationParameter = invocationParameter.replace('$PARAM', val);\n            }\n            return invocationParameter;\n        },\n        generateInvocationPair(...vars) {\n            let param = this.generateInvocationString(...vars);\n            while (param.startsWith('(Left ') || param.startsWith('(Right ')) {\n                if (param.startsWith('(Left ')) {\n                    param = param.slice(6, -1);\n                }\n                if (param.startsWith('(Right ')) {\n                    param = param.slice(7, -1);\n                }\n            }\n            return { entrypoint: this.name, parameters: param };\n        },\n        generateSampleInvocation() {\n            const params = this.parameters.map(p => {\n                switch (p.type) {\n                    case 'string': {\n                        return '\"Tacos\"';\n                    }\n                    case 'int': {\n                        return -1;\n                    }\n                    case 'nat': {\n                        return 99;\n                    }\n                    case 'address': {\n                        return '\"KT1EGbAxguaWQFkV3Egb2Z1r933MWuEYyrJS\"';\n                    }\n                    case 'key_hash': {\n                        return '\"tz1SQnJaocpquTztY3zMgydTPoQBBQrDGonJ\"';\n                    }\n                    case 'timestamp': {\n                        return `\"${(new Date()).toISOString()}\"`;\n                    }\n                    case 'mutez': {\n                        return 500000;\n                    }\n                    case 'unit': {\n                        return 'Unit';\n                    }\n                    case 'bytes':\n                    case 'bool':\n                    case 'signature':\n                    case 'key':\n                    case 'operation':\n                    case 'chain_id':\n                    default: {\n                        return p.type;\n                    }\n                }\n            });\n            return this.generateInvocationString(...params);\n        }\n    };\n    return [entryPoint];\n};\nconst getFieldAnnotation = (...annot) => {\n    const fa = annot.find(a => a.startsWith('%'));\n    return !!fa ? formatFieldAnnotation(fa) : undefined;\n};\nconst getTypeAnnotation = (...annot) => {\n    const ta = annot.find(a => a.startsWith(':'));\n    return !!ta ? formatTypeAnnotation(ta) : undefined;\n};\nconst formatFieldAnnotation = (annot) => {\n    if (!annot.startsWith('%')) {\n        throw new Error(`${annot} must start with '%'`);\n    }\n    return annot.replace(/^%_Liq_entry_/, '').replace('%', '');\n};\nconst formatTypeAnnotation = (annot) => {\n    if (!annot.startsWith(':')) {\n        throw new Error(`${annot} must start with ':'`);\n    }\n    return annot.replace(':', '');\n};\n;\n;\n;\n;\nconst grammar = {\n    Lexer: lexer,\n    ParserRules: [\n        { \"name\": \"entry\", \"symbols\": [(lexer.has(\"parameter\") ? { type: \"parameter\" } : parameter), \"__\", \"parameters\", \"_\", (lexer.has(\"semicolon\") ? { type: \"semicolon\" } : semicolon)], \"postprocess\": breakParameter },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", \"parameters\", \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": stripParen },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"or\") ? { type: \"or\" } : or), \"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", \"parameters\", \"__\", \"parameters\"], \"postprocess\": branchOrWithTwoAnnot },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"or\") ? { type: \"or\" } : or), \"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", \"parameters\", \"__\", \"parameters\"], \"postprocess\": branchOrWithAnnot },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"or\") ? { type: \"or\" } : or), \"_\", \"parameters\", \"__\", \"parameters\"], \"postprocess\": branchOr },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"pair\") ? { type: \"pair\" } : pair), \"__\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", \"parameters\", \"__\", \"parameters\"], \"postprocess\": mergePairWithTwoAnnot },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"pair\") ? { type: \"pair\" } : pair), \"__\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", \"parameters\", \"__\", \"parameters\"], \"postprocess\": mergePairWithAnnot },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"pair\") ? { type: \"pair\" } : pair), \"__\", \"parameters\", \"__\", \"parameters\"], \"postprocess\": mergePair },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"singleArgData\") ? { type: \"singleArgData\" } : singleArgData), \"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", \"parameters\"], \"postprocess\": recordSingleArgDataWithTwoAnnot },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"singleArgData\") ? { type: \"singleArgData\" } : singleArgData), \"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", \"parameters\"], \"postprocess\": recordSingleArgDataWithAnnot },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"singleArgData\") ? { type: \"singleArgData\" } : singleArgData), \"_\", \"parameters\"], \"postprocess\": recordSingleArgData },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"doubleArgData\") ? { type: \"doubleArgData\" } : doubleArgData), \"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", \"parameters\", \"__\", \"parameters\"], \"postprocess\": recordDoubleArgDataWithTwoAnnot },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"doubleArgData\") ? { type: \"doubleArgData\" } : doubleArgData), \"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", \"parameters\", \"__\", \"parameters\"], \"postprocess\": recordDoubleArgDataWithAnnot },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"doubleArgData\") ? { type: \"doubleArgData\" } : doubleArgData), \"_\", \"parameters\", \"__\", \"parameters\"], \"postprocess\": recordDoubleArgData },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"data\") ? { type: \"data\" } : data), \"__\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)], \"postprocess\": recordData },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"data\") ? { type: \"data\" } : data), \"__\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot), \"__\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)], \"postprocess\": recordData },\n        { \"name\": \"parameters\", \"symbols\": [(lexer.has(\"data\") ? { type: \"data\" } : data)], \"postprocess\": recordData },\n        { \"name\": \"_$ebnf$1\", \"symbols\": [] },\n        { \"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", /[\\s]/], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"_\", \"symbols\": [\"_$ebnf$1\"] },\n        { \"name\": \"__\", \"symbols\": [/[\\s]/] }\n    ],\n    ParserStart: \"entry\",\n};\nexports.default = grammar;\n//# sourceMappingURL=EntryPointTemplate.js.map"]},"metadata":{},"sourceType":"script"}