{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst TezosConstants_1 = require(\"../../types/tezos/TezosConstants\");\n\nconst TezosNodeReader_1 = require(\"./TezosNodeReader\");\n\nconst TezosNodeWriter_1 = require(\"./TezosNodeWriter\");\n\nconst LoggerSelector_1 = __importDefault(require(\"../../utils/LoggerSelector\"));\n\nconst log = LoggerSelector_1.default.getLogger();\n\nclass TezosOperationQueue {\n  constructor(server, derivationPath, keyStore, delay) {\n    this.triggerTimestamp = 0;\n    this.server = server;\n    this.keyStore = keyStore;\n    this.derivationPath = derivationPath;\n    this.delay = delay;\n    this.operations = [];\n  }\n\n  static createQueue(server, derivationPath, keyStore, delay = TezosConstants_1.TezosConstants.DefaultBatchDelay) {\n    return new TezosOperationQueue(server, derivationPath, keyStore, delay);\n  }\n\n  addOperations(...operations) {\n    if (this.operations.length === 0) {\n      this.triggerTimestamp = Date.now();\n      setTimeout(() => {\n        this.sendOperations();\n      }, this.delay * 1000);\n    }\n\n    operations.forEach(o => this.operations.push(o));\n  }\n\n  getStatus() {\n    return this.operations.length;\n  }\n\n  sendOperations() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(this.server, this.keyStore.publicKeyHash)) + 1;\n      let ops = [];\n      const queueLength = this.operations.length;\n\n      for (let i = 0; i < queueLength; i++) {\n        let o = this.operations.shift();\n\n        if (o.counter) {\n          o.counter = `${counter++}`;\n        }\n\n        ops.push(o);\n      }\n\n      if (this.operations.length > 0) {\n        this.triggerTimestamp = Date.now();\n        setTimeout(() => {\n          this.sendOperations();\n        }, this.delay * 1000);\n      }\n\n      try {\n        yield TezosNodeWriter_1.TezosNodeWriter.sendOperation(this.server, ops, this.keyStore, this.derivationPath);\n      } catch (error) {\n        log.error(`Error sending queued operations: ${error}`);\n      }\n    });\n  }\n\n}\n\nexports.TezosOperationQueue = TezosOperationQueue;","map":{"version":3,"sources":["../../../src/chain/tezos/TezosOperationQueue.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAA,gBAAA,GAAA,OAAA,CAAA,kCAAA,CAAA;;AAEA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAEA,MAAA,gBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,4BAAA,CAAA,CAAA;;AACA,MAAM,GAAG,GAAG,gBAAA,CAAA,OAAA,CAAY,SAAZ,EAAZ;;AAKA,MAAa,mBAAb,CAAgC;AAS5B,EAAA,WAAA,CAAoB,MAApB,EAAoC,cAApC,EAA4D,QAA5D,EAAgF,KAAhF,EAA6F;AAF7F,SAAA,gBAAA,GAA2B,CAA3B;AAGI,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,cAAL,GAAsB,cAAtB;AACA,SAAK,KAAL,GAAa,KAAb;AAEA,SAAK,UAAL,GAAkB,EAAlB;AACH;;AAUM,SAAO,WAAP,CAAmB,MAAnB,EAAmC,cAAnC,EAA2D,QAA3D,EAA+E,KAAA,GAAgB,gBAAA,CAAA,cAAA,CAAe,iBAA9G,EAA+H;AAClI,WAAO,IAAI,mBAAJ,CAAwB,MAAxB,EAAgC,cAAhC,EAAgD,QAAhD,EAA0D,KAA1D,CAAP;AACH;;AAKM,EAAA,aAAa,CAAC,GAAG,UAAJ,EAA2B;AAC3C,QAAI,KAAK,UAAL,CAAgB,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B,WAAK,gBAAL,GAAwB,IAAI,CAAC,GAAL,EAAxB;AACA,MAAA,UAAU,CAAC,MAAK;AAAG,aAAK,cAAL;AAAuB,OAAhC,EAAkC,KAAK,KAAL,GAAa,IAA/C,CAAV;AACH;;AAED,IAAA,UAAU,CAAC,OAAX,CAAmB,CAAC,IAAI,KAAK,UAAL,CAAgB,IAAhB,CAAqB,CAArB,CAAxB;AACH;;AAKM,EAAA,SAAS,GAAA;AACZ,WAAO,KAAK,UAAL,CAAgB,MAAvB;AACH;;AAEa,EAAA,cAAc,GAAA;;AACxB,UAAI,OAAO,GAAG,CAAA,MAAM,iBAAA,CAAA,eAAA,CAAgB,oBAAhB,CAAqC,KAAK,MAA1C,EAAkD,KAAK,QAAL,CAAc,aAAhE,CAAN,IAAuF,CAArG;AAEA,UAAI,GAAG,GAAgB,EAAvB;AACA,YAAM,WAAW,GAAG,KAAK,UAAL,CAAgB,MAApC;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAApB,EAAiC,CAAC,EAAlC,EAAsC;AAClC,YAAI,CAAC,GAAG,KAAK,UAAL,CAAgB,KAAhB,EAAR;;AACA,YAAK,CAAwB,CAAC,OAA9B,EAAuC;AAAG,UAAA,CAAwB,CAAC,OAAzB,GAAmC,GAAG,OAAO,EAAE,EAA/C;AAAoD;;AAC9F,QAAA,GAAG,CAAC,IAAJ,CAAS,CAAT;AACH;;AAED,UAAI,KAAK,UAAL,CAAgB,MAAhB,GAAyB,CAA7B,EAAgC;AAC5B,aAAK,gBAAL,GAAwB,IAAI,CAAC,GAAL,EAAxB;AACA,QAAA,UAAU,CAAC,MAAK;AAAG,eAAK,cAAL;AAAuB,SAAhC,EAAkC,KAAK,KAAL,GAAa,IAA/C,CAAV;AACH;;AAED,UAAI;AACA,cAAM,iBAAA,CAAA,eAAA,CAAgB,aAAhB,CAA8B,KAAK,MAAnC,EAA2C,GAA3C,EAAgD,KAAK,QAArD,EAA+D,KAAK,cAApE,CAAN;AACH,OAFD,CAEE,OAAM,KAAN,EAAa;AACX,QAAA,GAAG,CAAC,KAAJ,CAAU,oCAAoC,KAAK,EAAnD;AACH;AACJ,K;AAAA;;AAtE2B;;AAAhC,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TezosConstants_1 = require(\"../../types/tezos/TezosConstants\");\nconst TezosNodeReader_1 = require(\"./TezosNodeReader\");\nconst TezosNodeWriter_1 = require(\"./TezosNodeWriter\");\nconst LoggerSelector_1 = __importDefault(require(\"../../utils/LoggerSelector\"));\nconst log = LoggerSelector_1.default.getLogger();\nclass TezosOperationQueue {\n    constructor(server, derivationPath, keyStore, delay) {\n        this.triggerTimestamp = 0;\n        this.server = server;\n        this.keyStore = keyStore;\n        this.derivationPath = derivationPath;\n        this.delay = delay;\n        this.operations = [];\n    }\n    static createQueue(server, derivationPath, keyStore, delay = TezosConstants_1.TezosConstants.DefaultBatchDelay) {\n        return new TezosOperationQueue(server, derivationPath, keyStore, delay);\n    }\n    addOperations(...operations) {\n        if (this.operations.length === 0) {\n            this.triggerTimestamp = Date.now();\n            setTimeout(() => { this.sendOperations(); }, this.delay * 1000);\n        }\n        operations.forEach(o => this.operations.push(o));\n    }\n    getStatus() {\n        return this.operations.length;\n    }\n    sendOperations() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let counter = (yield TezosNodeReader_1.TezosNodeReader.getCounterForAccount(this.server, this.keyStore.publicKeyHash)) + 1;\n            let ops = [];\n            const queueLength = this.operations.length;\n            for (let i = 0; i < queueLength; i++) {\n                let o = this.operations.shift();\n                if (o.counter) {\n                    o.counter = `${counter++}`;\n                }\n                ops.push(o);\n            }\n            if (this.operations.length > 0) {\n                this.triggerTimestamp = Date.now();\n                setTimeout(() => { this.sendOperations(); }, this.delay * 1000);\n            }\n            try {\n                yield TezosNodeWriter_1.TezosNodeWriter.sendOperation(this.server, ops, this.keyStore, this.derivationPath);\n            }\n            catch (error) {\n                log.error(`Error sending queued operations: ${error}`);\n            }\n        });\n    }\n}\nexports.TezosOperationQueue = TezosOperationQueue;\n//# sourceMappingURL=TezosOperationQueue.js.map"]},"metadata":{},"sourceType":"script"}