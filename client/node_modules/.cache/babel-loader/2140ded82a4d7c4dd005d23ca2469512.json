{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bs58check_1 = __importDefault(require(\"bs58check\"));\n\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\n\nconst CryptoUtils_1 = require(\"../../utils/CryptoUtils\");\n\nconst TezosLanguageUtil_1 = require(\"./TezosLanguageUtil\");\n\nconst TezosChainTypes_1 = require(\"../../types/tezos/TezosChainTypes\");\n\nvar TezosMessageUtils;\n\n(function (TezosMessageUtils) {\n  function writeBoolean(value) {\n    return value ? \"ff\" : \"00\";\n  }\n\n  TezosMessageUtils.writeBoolean = writeBoolean;\n\n  function readBoolean(hex) {\n    return parseInt(hex, 16) > 0 ? true : false;\n  }\n\n  TezosMessageUtils.readBoolean = readBoolean;\n\n  function writeInt(value) {\n    if (value < 0) {\n      throw new Error('Use writeSignedInt to encode negative numbers');\n    }\n\n    return Buffer.from(Buffer.from(CryptoUtils_1.CryptoUtils.twoByteHex(value), 'hex').map((v, i) => {\n      return i === 0 ? v : v ^ 0x80;\n    }).reverse()).toString('hex');\n  }\n\n  TezosMessageUtils.writeInt = writeInt;\n\n  function writeSignedInt(value) {\n    if (value === 0) {\n      return '00';\n    }\n\n    const n = big_integer_1.default(value).abs();\n    const l = n.bitLength().toJSNumber();\n    let arr = [];\n    let v = n;\n\n    for (let i = 0; i < l; i += 7) {\n      let byte = big_integer_1.default.zero;\n\n      if (i === 0) {\n        byte = v.and(0x3f);\n        v = v.shiftRight(6);\n      } else {\n        byte = v.and(0x7f);\n        v = v.shiftRight(7);\n      }\n\n      if (value < 0 && i === 0) {\n        byte = byte.or(0x40);\n      }\n\n      if (i + 7 < l) {\n        byte = byte.or(0x80);\n      }\n\n      arr.push(byte.toJSNumber());\n    }\n\n    if (l % 7 === 0) {\n      arr[arr.length - 1] = arr[arr.length - 1] | 0x80;\n      arr.push(1);\n    }\n\n    return arr.map(v => ('0' + v.toString(16)).slice(-2)).join('');\n  }\n\n  TezosMessageUtils.writeSignedInt = writeSignedInt;\n\n  function readInt(hex) {\n    const h = Buffer.from(Buffer.from(hex, 'hex').reverse().map((v, i) => {\n      return i === 0 ? v : v & 0x7f;\n    })).toString('hex');\n    return CryptoUtils_1.CryptoUtils.fromByteHex(h);\n  }\n\n  TezosMessageUtils.readInt = readInt;\n\n  function readSignedInt(hex) {\n    const positive = Buffer.from(hex.slice(0, 2), 'hex')[0] & 0x40 ? false : true;\n    const arr = Buffer.from(hex, 'hex').map((v, i) => i === 0 ? v & 0x3f : v & 0x7f);\n    let n = big_integer_1.default.zero;\n\n    for (let i = arr.length - 1; i >= 0; i--) {\n      if (i === 0) {\n        n = n.or(arr[i]);\n      } else {\n        n = n.or(big_integer_1.default(arr[i]).shiftLeft(7 * i - 1));\n      }\n    }\n\n    return positive ? n.toJSNumber() : n.negate().toJSNumber();\n  }\n\n  TezosMessageUtils.readSignedInt = readSignedInt;\n\n  function findInt(hex, offset, signed = false) {\n    let buffer = \"\";\n    let i = 0;\n\n    while (offset + i * 2 < hex.length) {\n      let start = offset + i * 2;\n      let end = start + 2;\n      let part = hex.substring(start, end);\n      buffer += part;\n      i += 1;\n\n      if (parseInt(part, 16) < 127) {\n        break;\n      }\n    }\n\n    return signed ? {\n      value: readSignedInt(buffer),\n      length: i * 2\n    } : {\n      value: readInt(buffer),\n      length: i * 2\n    };\n  }\n\n  TezosMessageUtils.findInt = findInt;\n\n  function writeString(value) {\n    const len = dataLength(value.length);\n    const text = value.split('').map(c => c.charCodeAt(0).toString(16)).join('');\n    return len + text;\n  }\n\n  TezosMessageUtils.writeString = writeString;\n\n  function readString(hex) {\n    const stringLen = parseInt(hex.substring(0, 8), 16);\n\n    if (stringLen === 0) {\n      return '';\n    }\n\n    const stringHex = hex.slice(8);\n    let text = '';\n\n    for (let i = 0; i < stringHex.length; i += 2) {\n      text += String.fromCharCode(parseInt(stringHex.substring(i, i + 2), 16));\n    }\n\n    return text;\n  }\n\n  TezosMessageUtils.readString = readString;\n\n  function readAddress(hex) {\n    if (hex.length !== 44 && hex.length !== 42) {\n      throw new Error(\"Incorrect hex length to parse an address\");\n    }\n\n    let implicitHint = hex.length === 44 ? hex.substring(0, 4) : \"00\" + hex.substring(0, 2);\n    let implicitPrefixLength = hex.length === 44 ? 4 : 2;\n\n    if (implicitHint === \"0000\") {\n      return bs58check_1.default.encode(Buffer.from(\"06a19f\" + hex.substring(implicitPrefixLength), \"hex\"));\n    } else if (implicitHint === \"0001\") {\n      return bs58check_1.default.encode(Buffer.from(\"06a1a1\" + hex.substring(implicitPrefixLength), \"hex\"));\n    } else if (implicitHint === \"0002\") {\n      return bs58check_1.default.encode(Buffer.from(\"06a1a4\" + hex.substring(implicitPrefixLength), \"hex\"));\n    } else if (hex.substring(0, 2) === \"01\" && hex.length === 44) {\n      return bs58check_1.default.encode(Buffer.from(\"025a79\" + hex.substring(2, 42), \"hex\"));\n    } else {\n      throw new Error(\"Unrecognized address type\");\n    }\n  }\n\n  TezosMessageUtils.readAddress = readAddress;\n\n  function readAddressWithHint(b, hint) {\n    const address = !(b instanceof Buffer) ? Buffer.from(b) : b;\n\n    if (hint === 'tz1') {\n      return readAddress(`0000${address.toString('hex')}`);\n    } else if (hint === 'tz2') {\n      return readAddress(`0001${address.toString('hex')}`);\n    } else if (hint === 'tz3') {\n      return readAddress(`0002${address.toString('hex')}`);\n    } else if (hint === 'kt1') {\n      return readAddress(`01${address.toString('hex')}00`);\n    } else {\n      throw new Error(`Unrecognized address hint, '${hint}'`);\n    }\n  }\n\n  TezosMessageUtils.readAddressWithHint = readAddressWithHint;\n\n  function writeAddress(address) {\n    const hex = bs58check_1.default.decode(address).slice(3).toString(\"hex\");\n\n    if (address.startsWith(\"tz1\")) {\n      return \"0000\" + hex;\n    } else if (address.startsWith(\"tz2\")) {\n      return \"0001\" + hex;\n    } else if (address.startsWith(\"tz3\")) {\n      return \"0002\" + hex;\n    } else if (address.startsWith(\"KT1\")) {\n      return \"01\" + hex + \"00\";\n    } else {\n      throw new Error(`Unrecognized address prefix: ${address.substring(0, 3)}`);\n    }\n  }\n\n  TezosMessageUtils.writeAddress = writeAddress;\n\n  function readBranch(hex) {\n    if (hex.length !== 64) {\n      throw new Error('Incorrect hex length to parse a branch hash');\n    }\n\n    return bs58check_1.default.encode(Buffer.from('0134' + hex, 'hex'));\n  }\n\n  TezosMessageUtils.readBranch = readBranch;\n\n  function writeBranch(branch) {\n    return bs58check_1.default.decode(branch).slice(2).toString(\"hex\");\n  }\n\n  TezosMessageUtils.writeBranch = writeBranch;\n\n  function readPublicKey(hex) {\n    if (hex.length !== 66 && hex.length !== 68) {\n      throw new Error(`Incorrect hex length, ${hex.length} to parse a key`);\n    }\n\n    let hint = hex.substring(0, 2);\n\n    if (hint === \"00\") {\n      return bs58check_1.default.encode(Buffer.from(\"0d0f25d9\" + hex.substring(2), \"hex\"));\n    } else if (hint === \"01\" && hex.length === 68) {\n      return bs58check_1.default.encode(Buffer.from(\"03fee256\" + hex.substring(2), \"hex\"));\n    } else if (hint === \"02\" && hex.length === 68) {\n      return bs58check_1.default.encode(Buffer.from(\"03b28b7f\" + hex.substring(2), \"hex\"));\n    } else {\n      throw new Error('Unrecognized key type');\n    }\n  }\n\n  TezosMessageUtils.readPublicKey = readPublicKey;\n\n  function writePublicKey(publicKey) {\n    if (publicKey.startsWith(\"edpk\")) {\n      return \"00\" + bs58check_1.default.decode(publicKey).slice(4).toString(\"hex\");\n    } else if (publicKey.startsWith(\"sppk\")) {\n      return \"01\" + bs58check_1.default.decode(publicKey).slice(4).toString(\"hex\");\n    } else if (publicKey.startsWith(\"p2pk\")) {\n      return \"02\" + bs58check_1.default.decode(publicKey).slice(4).toString(\"hex\");\n    } else {\n      throw new Error('Unrecognized key type');\n    }\n  }\n\n  TezosMessageUtils.writePublicKey = writePublicKey;\n\n  function readKeyWithHint(b, hint) {\n    const key = !(b instanceof Buffer) ? Buffer.from(b) : b;\n\n    if (hint === 'edsk') {\n      return bs58check_1.default.encode(Buffer.from('2bf64e07' + key.toString('hex'), 'hex'));\n    } else if (hint === 'edpk') {\n      return readPublicKey(`00${key.toString('hex')}`);\n    } else {\n      throw new Error(`Unrecognized key hint, '${hint}'`);\n    }\n  }\n\n  TezosMessageUtils.readKeyWithHint = readKeyWithHint;\n\n  function writeKeyWithHint(key, hint) {\n    if (hint === 'edsk' || hint === 'edpk') {\n      return bs58check_1.default.decode(key).slice(4);\n    } else {\n      throw new Error(`Unrecognized key hint, '${hint}'`);\n    }\n  }\n\n  TezosMessageUtils.writeKeyWithHint = writeKeyWithHint;\n\n  function readSignatureWithHint(b, hint) {\n    const sig = !(b instanceof Buffer) ? Buffer.from(b) : b;\n\n    if (hint === 'edsig') {\n      return bs58check_1.default.encode(Buffer.from('09f5cd8612' + sig.toString('hex'), 'hex'));\n    } else {\n      throw new Error(`Unrecognized signature hint, '${hint}'`);\n    }\n  }\n\n  TezosMessageUtils.readSignatureWithHint = readSignatureWithHint;\n\n  function writeSignatureWithHint(sig, hint) {\n    if (hint === 'edsig') {\n      return bs58check_1.default.decode(sig).slice(5);\n    } else {\n      throw new Error(`Unrecognized key hint, '${hint}'`);\n    }\n  }\n\n  TezosMessageUtils.writeSignatureWithHint = writeSignatureWithHint;\n\n  function readBufferWithHint(b, hint) {\n    const buffer = !(b instanceof Buffer) ? Buffer.from(b) : b;\n\n    if (hint === 'op') {\n      return bs58check_1.default.encode(Buffer.from('0574' + buffer.toString('hex'), 'hex'));\n    } else if (hint === 'p') {\n      return bs58check_1.default.encode(Buffer.from('02aa' + buffer.toString('hex'), 'hex'));\n    } else if (hint === 'expr') {\n      return bs58check_1.default.encode(Buffer.from('0d2c401b' + buffer.toString('hex'), 'hex'));\n    } else if (hint === '') {\n      return bs58check_1.default.encode(buffer);\n    } else {\n      throw new Error(`Unsupported hint, '${hint}'`);\n    }\n  }\n\n  TezosMessageUtils.readBufferWithHint = readBufferWithHint;\n\n  function writeBufferWithHint(b) {\n    return bs58check_1.default.decode(b);\n  }\n\n  TezosMessageUtils.writeBufferWithHint = writeBufferWithHint;\n\n  function computeOperationHash(signedOpGroup) {\n    const hash = CryptoUtils_1.CryptoUtils.simpleHash(signedOpGroup.bytes, 32);\n    return readBufferWithHint(hash, \"op\");\n  }\n\n  TezosMessageUtils.computeOperationHash = computeOperationHash;\n\n  function computeKeyHash(key, prefix = 'tz1') {\n    const hash = CryptoUtils_1.CryptoUtils.simpleHash(key, 20);\n    return readAddressWithHint(hash, prefix);\n  }\n\n  TezosMessageUtils.computeKeyHash = computeKeyHash;\n\n  function dataLength(value) {\n    return ('0000000' + value.toString(16)).slice(-8);\n  }\n\n  function writePackedData(value, type, format = TezosChainTypes_1.TezosParameterFormat.Micheline) {\n    switch (type) {\n      case 'int':\n        {\n          return '0500' + writeSignedInt(value);\n        }\n\n      case 'nat':\n        {\n          return '0500' + writeInt(value);\n        }\n\n      case 'string':\n        {\n          return '0501' + writeString(value);\n        }\n\n      case 'key_hash':\n        {\n          const address = writeAddress(value).slice(2);\n          return `050a${dataLength(address.length / 2)}${address}`;\n        }\n\n      case 'address':\n        {\n          const address = writeAddress(value);\n          return `050a${dataLength(address.length / 2)}${address}`;\n        }\n\n      case 'bytes':\n        {\n          const buffer = value.toString('hex');\n          return `050a${dataLength(buffer.length / 2)}${buffer}`;\n        }\n\n      default:\n        {\n          try {\n            if (format === TezosChainTypes_1.TezosParameterFormat.Micheline) {\n              return `05${TezosLanguageUtil_1.TezosLanguageUtil.translateMichelineToHex(value)}`;\n            } else if (format === TezosChainTypes_1.TezosParameterFormat.Michelson) {\n              const micheline = TezosLanguageUtil_1.TezosLanguageUtil.translateMichelsonToMicheline(value);\n              return `05${TezosLanguageUtil_1.TezosLanguageUtil.translateMichelineToHex(micheline)}`;\n            } else {\n              throw new Error(`Unsupported format, ${format}, provided`);\n            }\n          } catch (e) {\n            throw new Error(`Unrecognized data type or format: '${type}', '${format}': ${e}`);\n          }\n        }\n    }\n  }\n\n  TezosMessageUtils.writePackedData = writePackedData;\n\n  function readPackedData(hex, type) {\n    switch (type) {\n      case 'int':\n        {\n          return readSignedInt(hex.slice(4));\n        }\n\n      case 'nat':\n        {\n          return readInt(hex.slice(4));\n        }\n\n      case 'string':\n        {\n          return readString(hex.slice(4));\n        }\n\n      case 'key_hash':\n        {\n          return readAddress(`00${hex.slice(4 + 8)}`);\n        }\n\n      case 'address':\n        {\n          return readAddress(hex.slice(4 + 8));\n        }\n\n      case 'bytes':\n        {\n          return hex.slice(4 + 8);\n        }\n\n      default:\n        {\n          return TezosLanguageUtil_1.TezosLanguageUtil.hexToMicheline(hex.slice(2)).code;\n        }\n    }\n  }\n\n  TezosMessageUtils.readPackedData = readPackedData;\n\n  function encodeBigMapKey(key) {\n    return readBufferWithHint(CryptoUtils_1.CryptoUtils.simpleHash(key, 32), 'expr');\n  }\n\n  TezosMessageUtils.encodeBigMapKey = encodeBigMapKey;\n})(TezosMessageUtils = exports.TezosMessageUtils || (exports.TezosMessageUtils = {}));","map":{"version":3,"sources":["../../../src/chain/tezos/TezosMessageUtil.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,MAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,MAAA,aAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AAGA,MAAA,aAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;AACA,MAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;;AAKA,IAAiB,iBAAjB;;AAAA,CAAA,UAAiB,iBAAjB,EAAkC;AAK9B,WAAgB,YAAhB,CAA6B,KAA7B,EAA2C;AACvC,WAAO,KAAK,GAAG,IAAH,GAAU,IAAtB;AACH;;AAFe,EAAA,iBAAA,CAAA,YAAA,GAAY,YAAZ;;AAQhB,WAAgB,WAAhB,CAA4B,GAA5B,EAAuC;AACnC,WAAO,QAAQ,CAAC,GAAD,EAAM,EAAN,CAAR,GAAoB,CAApB,GAAwB,IAAxB,GAA+B,KAAtC;AACH;;AAFe,EAAA,iBAAA,CAAA,WAAA,GAAW,WAAX;;AAQhB,WAAgB,QAAhB,CAAyB,KAAzB,EAAsC;AAClC,QAAI,KAAK,GAAG,CAAZ,EAAe;AAAE,YAAM,IAAI,KAAJ,CAAU,+CAAV,CAAN;AAAmE;;AAEpF,WAAO,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,IAAP,CAAY,aAAA,CAAA,WAAA,CAAY,UAAZ,CAAuB,KAAvB,CAAZ,EAA2C,KAA3C,EAAkD,GAAlD,CAAsD,CAAC,CAAD,EAAI,CAAJ,KAAS;AAAG,aAAO,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAAC,GAAG,IAAzB;AAAgC,KAAlG,EAAoG,OAApG,EAAZ,EAA2H,QAA3H,CAAoI,KAApI,CAAP;AACH;;AAJe,EAAA,iBAAA,CAAA,QAAA,GAAQ,QAAR;;AAUhB,WAAgB,cAAhB,CAA+B,KAA/B,EAA4C;AACxC,QAAI,KAAK,KAAK,CAAd,EAAiB;AAAE,aAAO,IAAP;AAAc;;AAEjC,UAAM,CAAC,GAAG,aAAA,CAAA,OAAA,CAAO,KAAP,EAAc,GAAd,EAAV;AACA,UAAM,CAAC,GAAG,CAAC,CAAC,SAAF,GAAc,UAAd,EAAV;AACA,QAAI,GAAG,GAAa,EAApB;AACA,QAAI,CAAC,GAAG,CAAR;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,IAAI,CAA5B,EAA+B;AAC3B,UAAI,IAAI,GAAG,aAAA,CAAA,OAAA,CAAO,IAAlB;;AAEA,UAAI,CAAC,KAAK,CAAV,EAAa;AACT,QAAA,IAAI,GAAG,CAAC,CAAC,GAAF,CAAM,IAAN,CAAP;AACA,QAAA,CAAC,GAAG,CAAC,CAAC,UAAF,CAAa,CAAb,CAAJ;AACH,OAHD,MAGO;AACH,QAAA,IAAI,GAAG,CAAC,CAAC,GAAF,CAAM,IAAN,CAAP;AACA,QAAA,CAAC,GAAG,CAAC,CAAC,UAAF,CAAa,CAAb,CAAJ;AACH;;AAED,UAAI,KAAK,GAAG,CAAR,IAAa,CAAC,KAAK,CAAvB,EAA0B;AAAE,QAAA,IAAI,GAAG,IAAI,CAAC,EAAL,CAAQ,IAAR,CAAP;AAAuB;;AAEnD,UAAI,CAAC,GAAG,CAAJ,GAAQ,CAAZ,EAAe;AAAE,QAAA,IAAI,GAAG,IAAI,CAAC,EAAL,CAAQ,IAAR,CAAP;AAAuB;;AACxC,MAAA,GAAG,CAAC,IAAJ,CAAS,IAAI,CAAC,UAAL,EAAT;AACH;;AAED,QAAI,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiB;AACb,MAAA,GAAG,CAAC,GAAG,CAAC,MAAJ,GAAa,CAAd,CAAH,GAAsB,GAAG,CAAC,GAAG,CAAC,MAAJ,GAAa,CAAd,CAAH,GAAsB,IAA5C;AACA,MAAA,GAAG,CAAC,IAAJ,CAAS,CAAT;AACH;;AAED,WAAO,GAAG,CAAC,GAAJ,CAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,QAAF,CAAW,EAAX,CAAP,EAAuB,KAAvB,CAA6B,CAAC,CAA9B,CAAb,EAA+C,IAA/C,CAAoD,EAApD,CAAP;AACH;;AA9Be,EAAA,iBAAA,CAAA,cAAA,GAAc,cAAd;;AAoChB,WAAgB,OAAhB,CAAwB,GAAxB,EAAmC;AAE/B,UAAM,CAAC,GAAG,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,KAAjB,EAAwB,OAAxB,GAAkC,GAAlC,CAAsC,CAAC,CAAD,EAAI,CAAJ,KAAS;AAAG,aAAO,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAAC,GAAG,IAAzB;AAAgC,KAAlF,CAAZ,EAAiG,QAAjG,CAA0G,KAA1G,CAAV;AACA,WAAO,aAAA,CAAA,WAAA,CAAY,WAAZ,CAAwB,CAAxB,CAAP;AACH;;AAJe,EAAA,iBAAA,CAAA,OAAA,GAAO,OAAP;;AAMhB,WAAgB,aAAhB,CAA8B,GAA9B,EAAyC;AACrC,UAAM,QAAQ,GAAI,MAAM,CAAC,IAAP,CAAY,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAZ,EAA6B,KAA7B,EAAoC,CAApC,IAAyC,IAA1C,GAAkD,KAAlD,GAA0D,IAA3E;AAEA,UAAM,GAAG,GAAG,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,KAAjB,EAAwB,GAAxB,CAA4B,CAAC,CAAD,EAAI,CAAJ,KAAU,CAAC,KAAK,CAAN,GAAU,CAAC,GAAG,IAAd,GAAqB,CAAC,GAAG,IAA/D,CAAZ;AACA,QAAI,CAAC,GAAG,aAAA,CAAA,OAAA,CAAO,IAAf;;AACA,SAAK,IAAI,CAAC,GAAG,GAAG,CAAC,MAAJ,GAAa,CAA1B,EAA6B,CAAC,IAAI,CAAlC,EAAqC,CAAC,EAAtC,EAA0C;AACtC,UAAI,CAAC,KAAK,CAAV,EAAa;AACT,QAAA,CAAC,GAAG,CAAC,CAAC,EAAF,CAAK,GAAG,CAAC,CAAD,CAAR,CAAJ;AACH,OAFD,MAEO;AACH,QAAA,CAAC,GAAG,CAAC,CAAC,EAAF,CAAK,aAAA,CAAA,OAAA,CAAO,GAAG,CAAC,CAAD,CAAV,EAAe,SAAf,CAAyB,IAAI,CAAJ,GAAQ,CAAjC,CAAL,CAAJ;AACH;AACJ;;AAED,WAAO,QAAQ,GAAG,CAAC,CAAC,UAAF,EAAH,GAAoB,CAAC,CAAC,MAAF,GAAW,UAAX,EAAnC;AACH;;AAde,EAAA,iBAAA,CAAA,aAAA,GAAa,aAAb;;AAqBhB,WAAgB,OAAhB,CAAwB,GAAxB,EAAqC,MAArC,EAAqD,MAAA,GAAkB,KAAvE,EAA4E;AACxE,QAAI,MAAM,GAAG,EAAb;AACA,QAAI,CAAC,GAAG,CAAR;;AACA,WAAO,MAAM,GAAG,CAAC,GAAG,CAAb,GAAiB,GAAG,CAAC,MAA5B,EAAoC;AAChC,UAAI,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,CAAzB;AACA,UAAI,GAAG,GAAG,KAAK,GAAG,CAAlB;AACA,UAAI,IAAI,GAAG,GAAG,CAAC,SAAJ,CAAc,KAAd,EAAqB,GAArB,CAAX;AACA,MAAA,MAAM,IAAI,IAAV;AACA,MAAA,CAAC,IAAI,CAAL;;AAEA,UAAI,QAAQ,CAAC,IAAD,EAAO,EAAP,CAAR,GAAqB,GAAzB,EAA8B;AAAE;AAAQ;AAC3C;;AAED,WAAO,MAAM,GAAG;AAAE,MAAA,KAAK,EAAE,aAAa,CAAC,MAAD,CAAtB;AAAgC,MAAA,MAAM,EAAE,CAAC,GAAG;AAA5C,KAAH,GAAqD;AAAE,MAAA,KAAK,EAAE,OAAO,CAAC,MAAD,CAAhB;AAA0B,MAAA,MAAM,EAAE,CAAC,GAAG;AAAtC,KAAlE;AACH;;AAde,EAAA,iBAAA,CAAA,OAAA,GAAO,OAAP;;AAgBhB,WAAgB,WAAhB,CAA4B,KAA5B,EAAyC;AACrC,UAAM,GAAG,GAAG,UAAU,CAAC,KAAK,CAAC,MAAP,CAAtB;AACA,UAAM,IAAI,GAAG,KAAK,CAAC,KAAN,CAAY,EAAZ,EAAgB,GAAhB,CAAoB,CAAC,IAAI,CAAC,CAAC,UAAF,CAAa,CAAb,EAAgB,QAAhB,CAAyB,EAAzB,CAAzB,EAAuD,IAAvD,CAA4D,EAA5D,CAAb;AAEA,WAAO,GAAG,GAAG,IAAb;AACH;;AALe,EAAA,iBAAA,CAAA,WAAA,GAAW,WAAX;;AAOhB,WAAgB,UAAhB,CAA2B,GAA3B,EAAsC;AAClC,UAAM,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAD,EAAsB,EAAtB,CAA1B;;AACA,QAAI,SAAS,KAAK,CAAlB,EAAqB;AAAE,aAAO,EAAP;AAAY;;AAEnC,UAAM,SAAS,GAAG,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAlB;AAEA,QAAI,IAAI,GAAG,EAAX;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,IAAI,CAA3C,EAA8C;AAC1C,MAAA,IAAI,IAAI,MAAM,CAAC,YAAP,CAAoB,QAAQ,CAAC,SAAS,CAAC,SAAV,CAAoB,CAApB,EAAuB,CAAC,GAAG,CAA3B,CAAD,EAAgC,EAAhC,CAA5B,CAAR;AACH;;AAED,WAAO,IAAP;AACH;;AAZe,EAAA,iBAAA,CAAA,UAAA,GAAU,UAAV;;AAoBhB,WAAgB,WAAhB,CAA4B,GAA5B,EAAuC;AACnC,QAAI,GAAG,CAAC,MAAJ,KAAe,EAAf,IAAqB,GAAG,CAAC,MAAJ,KAAe,EAAxC,EAA4C;AAAE,YAAM,IAAI,KAAJ,CAAU,0CAAV,CAAN;AAA8D;;AAE5G,QAAI,YAAY,GAAG,GAAG,CAAC,MAAJ,KAAe,EAAf,GAAoB,GAAG,CAAC,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAApB,GAA0C,OAAO,GAAG,CAAC,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAApE;AACA,QAAI,oBAAoB,GAAG,GAAG,CAAC,MAAJ,KAAe,EAAf,GAAoB,CAApB,GAAwB,CAAnD;;AAEA,QAAI,YAAY,KAAK,MAArB,EAA6B;AACzB,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,WAAW,GAAG,CAAC,SAAJ,CAAc,oBAAd,CAAvB,EAA4D,KAA5D,CAAnB,CAAP;AACH,KAFD,MAEO,IAAI,YAAY,KAAK,MAArB,EAA6B;AAChC,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,WAAW,GAAG,CAAC,SAAJ,CAAc,oBAAd,CAAvB,EAA4D,KAA5D,CAAnB,CAAP;AACH,KAFM,MAEA,IAAI,YAAY,KAAK,MAArB,EAA6B;AAChC,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,WAAW,GAAG,CAAC,SAAJ,CAAc,oBAAd,CAAvB,EAA4D,KAA5D,CAAnB,CAAP;AACH,KAFM,MAEA,IAAI,GAAG,CAAC,SAAJ,CAAc,CAAd,EAAiB,CAAjB,MAAwB,IAAxB,IAAgC,GAAG,CAAC,MAAJ,KAAe,EAAnD,EAAuD;AAC1D,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,WAAW,GAAG,CAAC,SAAJ,CAAc,CAAd,EAAiB,EAAjB,CAAvB,EAA6C,KAA7C,CAAnB,CAAP;AACH,KAFM,MAEA;AACH,YAAM,IAAI,KAAJ,CAAU,2BAAV,CAAN;AACH;AACJ;;AAjBe,EAAA,iBAAA,CAAA,WAAA,GAAW,WAAX;;AA2BhB,WAAgB,mBAAhB,CAAoC,CAApC,EAA4D,IAA5D,EAAwE;AACpE,UAAM,OAAO,GAAG,EAAE,CAAC,YAAY,MAAf,IAAyB,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAzB,GAA0C,CAA1D;;AAEA,QAAI,IAAI,KAAK,KAAb,EAAoB;AAChB,aAAO,WAAW,CAAC,OAAO,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAuB,EAA/B,CAAlB;AACH,KAFD,MAEO,IAAI,IAAI,KAAK,KAAb,EAAoB;AACvB,aAAO,WAAW,CAAC,OAAO,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAuB,EAA/B,CAAlB;AACH,KAFM,MAEA,IAAI,IAAI,KAAK,KAAb,EAAoB;AACvB,aAAO,WAAW,CAAC,OAAO,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAuB,EAA/B,CAAlB;AACH,KAFM,MAEA,IAAI,IAAI,KAAK,KAAb,EAAoB;AACvB,aAAO,WAAW,CAAC,KAAK,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAuB,IAA7B,CAAlB;AACH,KAFM,MAEA;AACH,YAAM,IAAI,KAAJ,CAAU,+BAA+B,IAAI,GAA7C,CAAN;AACH;AACJ;;AAde,EAAA,iBAAA,CAAA,mBAAA,GAAmB,mBAAnB;;AAwBhB,WAAgB,YAAhB,CAA6B,OAA7B,EAA4C;AACxC,UAAM,GAAG,GAAG,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,OAAnB,EAA4B,KAA5B,CAAkC,CAAlC,EAAqC,QAArC,CAA8C,KAA9C,CAAZ;;AACA,QAAI,OAAO,CAAC,UAAR,CAAmB,KAAnB,CAAJ,EAA+B;AAC3B,aAAO,SAAS,GAAhB;AACH,KAFD,MAEO,IAAI,OAAO,CAAC,UAAR,CAAmB,KAAnB,CAAJ,EAA+B;AAClC,aAAO,SAAS,GAAhB;AACH,KAFM,MAEA,IAAI,OAAO,CAAC,UAAR,CAAmB,KAAnB,CAAJ,EAA+B;AAClC,aAAO,SAAS,GAAhB;AACH,KAFM,MAEA,IAAI,OAAO,CAAC,UAAR,CAAmB,KAAnB,CAAJ,EAA+B;AAClC,aAAO,OAAO,GAAP,GAAa,IAApB;AACH,KAFM,MAEA;AACH,YAAM,IAAI,KAAJ,CAAU,gCAAgC,OAAO,CAAC,SAAR,CAAkB,CAAlB,EAAqB,CAArB,CAAuB,EAAjE,CAAN;AACH;AACJ;;AAbe,EAAA,iBAAA,CAAA,YAAA,GAAY,YAAZ;;AAmBhB,WAAgB,UAAhB,CAA2B,GAA3B,EAAsC;AAClC,QAAI,GAAG,CAAC,MAAJ,KAAe,EAAnB,EAAuB;AAAE,YAAM,IAAI,KAAJ,CAAU,6CAAV,CAAN;AAAiE;;AAC1F,WAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,SAAS,GAArB,EAA0B,KAA1B,CAAnB,CAAP;AACH;;AAHe,EAAA,iBAAA,CAAA,UAAA,GAAU,UAAV;;AAWhB,WAAgB,WAAhB,CAA4B,MAA5B,EAA0C;AACtC,WAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAnB,EAA2B,KAA3B,CAAiC,CAAjC,EAAoC,QAApC,CAA6C,KAA7C,CAAP;AACH;;AAFe,EAAA,iBAAA,CAAA,WAAA,GAAW,WAAX;;AAUhB,WAAgB,aAAhB,CAA8B,GAA9B,EAAyC;AACrC,QAAI,GAAG,CAAC,MAAJ,KAAe,EAAf,IAAqB,GAAG,CAAC,MAAJ,KAAe,EAAxC,EAA4C;AAAE,YAAM,IAAI,KAAJ,CAAU,yBAAyB,GAAG,CAAC,MAAM,iBAA7C,CAAN;AAAwE;;AAEtH,QAAI,IAAI,GAAG,GAAG,CAAC,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAX;;AACA,QAAI,IAAI,KAAK,IAAb,EAAmB;AACf,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,aAAa,GAAG,CAAC,SAAJ,CAAc,CAAd,CAAzB,EAA2C,KAA3C,CAAnB,CAAP;AACH,KAFD,MAEO,IAAI,IAAI,KAAK,IAAT,IAAiB,GAAG,CAAC,MAAJ,KAAe,EAApC,EAAwC;AAC3C,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,aAAa,GAAG,CAAC,SAAJ,CAAc,CAAd,CAAzB,EAA2C,KAA3C,CAAnB,CAAP;AACH,KAFM,MAEA,IAAI,IAAI,KAAK,IAAT,IAAiB,GAAG,CAAC,MAAJ,KAAe,EAApC,EAAwC;AAC3C,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,aAAa,GAAG,CAAC,SAAJ,CAAc,CAAd,CAAzB,EAA2C,KAA3C,CAAnB,CAAP;AACH,KAFM,MAEA;AACH,YAAM,IAAI,KAAJ,CAAU,uBAAV,CAAN;AACH;AACJ;;AAbe,EAAA,iBAAA,CAAA,aAAA,GAAa,aAAb;;AAkBhB,WAAgB,cAAhB,CAA+B,SAA/B,EAAgD;AAC5C,QAAI,SAAS,CAAC,UAAV,CAAqB,MAArB,CAAJ,EAAkC;AAC9B,aAAO,OAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,SAAnB,EAA8B,KAA9B,CAAoC,CAApC,EAAuC,QAAvC,CAAgD,KAAhD,CAAd;AACH,KAFD,MAEO,IAAI,SAAS,CAAC,UAAV,CAAqB,MAArB,CAAJ,EAAkC;AACrC,aAAO,OAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,SAAnB,EAA8B,KAA9B,CAAoC,CAApC,EAAuC,QAAvC,CAAgD,KAAhD,CAAd;AACH,KAFM,MAEA,IAAI,SAAS,CAAC,UAAV,CAAqB,MAArB,CAAJ,EAAkC;AACrC,aAAO,OAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,SAAnB,EAA8B,KAA9B,CAAoC,CAApC,EAAuC,QAAvC,CAAgD,KAAhD,CAAd;AACH,KAFM,MAEA;AACH,YAAM,IAAI,KAAJ,CAAU,uBAAV,CAAN;AACH;AACJ;;AAVe,EAAA,iBAAA,CAAA,cAAA,GAAc,cAAd;;AAkBhB,WAAgB,eAAhB,CAAgC,CAAhC,EAAwD,IAAxD,EAAoE;AAChE,UAAM,GAAG,GAAG,EAAE,CAAC,YAAY,MAAf,IAAyB,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAzB,GAA0C,CAAtD;;AAEA,QAAI,IAAI,KAAK,MAAb,EAAqB;AACjB,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,aAAa,GAAG,CAAC,QAAJ,CAAa,KAAb,CAAzB,EAA8C,KAA9C,CAAnB,CAAP;AACH,KAFD,MAEO,IAAI,IAAI,KAAK,MAAb,EAAqB;AACxB,aAAO,aAAa,CAAC,KAAK,GAAG,CAAC,QAAJ,CAAa,KAAb,CAAmB,EAAzB,CAApB;AACH,KAFM,MAEA;AACH,YAAM,IAAI,KAAJ,CAAU,2BAA2B,IAAI,GAAzC,CAAN;AACH;AACJ;;AAVe,EAAA,iBAAA,CAAA,eAAA,GAAe,eAAf;;AAkBhB,WAAgB,gBAAhB,CAAiC,GAAjC,EAA8C,IAA9C,EAA0D;AACtD,QAAI,IAAI,KAAK,MAAT,IAAmB,IAAI,KAAK,MAAhC,EAAwC;AACpC,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,GAAnB,EAAwB,KAAxB,CAA8B,CAA9B,CAAP;AAGH,KAJD,MAIO;AACH,YAAM,IAAI,KAAJ,CAAU,2BAA2B,IAAI,GAAzC,CAAN;AACH;AACJ;;AARe,EAAA,iBAAA,CAAA,gBAAA,GAAgB,gBAAhB;;AAgBhB,WAAgB,qBAAhB,CAAsC,CAAtC,EAA8D,IAA9D,EAA0E;AACtE,UAAM,GAAG,GAAG,EAAE,CAAC,YAAY,MAAf,IAAyB,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAzB,GAA0C,CAAtD;;AAEA,QAAI,IAAI,KAAK,OAAb,EAAsB;AAClB,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,eAAe,GAAG,CAAC,QAAJ,CAAa,KAAb,CAA3B,EAAgD,KAAhD,CAAnB,CAAP;AACH,KAFD,MAEO;AACH,YAAM,IAAI,KAAJ,CAAU,iCAAiC,IAAI,GAA/C,CAAN;AACH;AACJ;;AARe,EAAA,iBAAA,CAAA,qBAAA,GAAqB,qBAArB;;AAgBhB,WAAgB,sBAAhB,CAAuC,GAAvC,EAAoD,IAApD,EAAgE;AAC5D,QAAI,IAAI,KAAK,OAAb,EAAsB;AAClB,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,GAAnB,EAAwB,KAAxB,CAA8B,CAA9B,CAAP;AACH,KAFD,MAEO;AACH,YAAM,IAAI,KAAJ,CAAU,2BAA2B,IAAI,GAAzC,CAAN;AACH;AACJ;;AANe,EAAA,iBAAA,CAAA,sBAAA,GAAsB,sBAAtB;;AAchB,WAAgB,kBAAhB,CAAmC,CAAnC,EAA2D,IAA3D,EAAuE;AACnE,UAAM,MAAM,GAAG,EAAE,CAAC,YAAY,MAAf,IAAyB,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAzB,GAA0C,CAAzD;;AAEA,QAAI,IAAI,KAAK,IAAb,EAAmB;AACf,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,SAAS,MAAM,CAAC,QAAP,CAAgB,KAAhB,CAArB,EAA6C,KAA7C,CAAnB,CAAP;AACH,KAFD,MAEO,IAAI,IAAI,KAAK,GAAb,EAAkB;AACrB,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,SAAS,MAAM,CAAC,QAAP,CAAgB,KAAhB,CAArB,EAA6C,KAA7C,CAAnB,CAAP;AACH,KAFM,MAEA,IAAI,IAAI,KAAK,MAAb,EAAqB;AACxB,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAM,CAAC,IAAP,CAAY,aAAa,MAAM,CAAC,QAAP,CAAgB,KAAhB,CAAzB,EAAiD,KAAjD,CAAnB,CAAP;AACH,KAFM,MAEA,IAAI,IAAI,KAAK,EAAb,EAAiB;AACpB,aAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,MAAnB,CAAP;AACH,KAFM,MAEA;AACH,YAAM,IAAI,KAAJ,CAAU,sBAAsB,IAAI,GAApC,CAAN;AACH;AACJ;;AAde,EAAA,iBAAA,CAAA,kBAAA,GAAkB,kBAAlB;;AAqBhB,WAAgB,mBAAhB,CAAoC,CAApC,EAA6C;AACzC,WAAO,WAAA,CAAA,OAAA,CAAY,MAAZ,CAAmB,CAAnB,CAAP;AACH;;AAFe,EAAA,iBAAA,CAAA,mBAAA,GAAmB,mBAAnB;;AAUhB,WAAgB,oBAAhB,CAAqC,aAArC,EAAwE;AACpE,UAAM,IAAI,GAAG,aAAA,CAAA,WAAA,CAAY,UAAZ,CAAuB,aAAa,CAAC,KAArC,EAA4C,EAA5C,CAAb;AACA,WAAO,kBAAkB,CAAC,IAAD,EAAO,IAAP,CAAzB;AACH;;AAHe,EAAA,iBAAA,CAAA,oBAAA,GAAoB,oBAApB;;AAYhB,WAAgB,cAAhB,CAA+B,GAA/B,EAA4C,MAAA,GAAiB,KAA7D,EAAkE;AAC9D,UAAM,IAAI,GAAG,aAAA,CAAA,WAAA,CAAY,UAAZ,CAAuB,GAAvB,EAA4B,EAA5B,CAAb;AACA,WAAO,mBAAmB,CAAC,IAAD,EAAO,MAAP,CAA1B;AACH;;AAHe,EAAA,iBAAA,CAAA,cAAA,GAAc,cAAd;;AAKhB,WAAS,UAAT,CAAoB,KAApB,EAAiC;AAC7B,WAAO,CAAC,YAAa,KAAD,CAAQ,QAAR,CAAiB,EAAjB,CAAb,EAAmC,KAAnC,CAAyC,CAAC,CAA1C,CAAP;AACH;;AASD,WAAgB,eAAhB,CAAgC,KAAhC,EAAiE,IAAjE,EAA+E,MAAA,GAA+B,iBAAA,CAAA,oBAAA,CAAqB,SAAnI,EAA4I;AACxI,YAAO,IAAP;AACI,WAAK,KAAL;AAAY;AACR,iBAAO,SAAS,cAAc,CAAC,KAAD,CAA9B;AACH;;AACD,WAAK,KAAL;AAAY;AACR,iBAAO,SAAS,QAAQ,CAAC,KAAD,CAAxB;AACH;;AACD,WAAK,QAAL;AAAe;AACX,iBAAO,SAAS,WAAW,CAAC,KAAD,CAA3B;AACH;;AACD,WAAK,UAAL;AAAiB;AACb,gBAAM,OAAO,GAAG,YAAY,CAAC,KAAD,CAAZ,CAA8B,KAA9B,CAAoC,CAApC,CAAhB;AACA,iBAAO,OAAO,UAAU,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAAoB,GAAG,OAAO,EAAtD;AACH;;AACD,WAAK,SAAL;AAAgB;AACZ,gBAAM,OAAO,GAAG,YAAY,CAAC,KAAD,CAA5B;AACA,iBAAO,OAAO,UAAU,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAAoB,GAAG,OAAO,EAAtD;AACH;;AACD,WAAK,OAAL;AAAc;AACV,gBAAM,MAAM,GAAI,KAAgB,CAAC,QAAjB,CAA0B,KAA1B,CAAhB;AACA,iBAAO,OAAO,UAAU,CAAC,MAAM,CAAC,MAAP,GAAgB,CAAjB,CAAmB,GAAG,MAAM,EAApD;AACH;;AACD;AAAS;AACL,cAAI;AACA,gBAAI,MAAM,KAAK,iBAAA,CAAA,oBAAA,CAAqB,SAApC,EAA+C;AAC3C,qBAAO,KAAK,mBAAA,CAAA,iBAAA,CAAkB,uBAAlB,CAA0C,KAA1C,CAA0D,EAAtE;AACH,aAFD,MAEO,IAAI,MAAM,KAAK,iBAAA,CAAA,oBAAA,CAAqB,SAApC,EAA+C;AAClD,oBAAM,SAAS,GAAG,mBAAA,CAAA,iBAAA,CAAkB,6BAAlB,CAAgD,KAAhD,CAAlB;AACA,qBAAO,KAAK,mBAAA,CAAA,iBAAA,CAAkB,uBAAlB,CAA0C,SAA1C,CAAoD,EAAhE;AACH,aAHM,MAGA;AACH,oBAAM,IAAI,KAAJ,CAAU,uBAAuB,MAAM,YAAvC,CAAN;AACH;AACJ,WATD,CASE,OAAO,CAAP,EAAU;AACR,kBAAM,IAAI,KAAJ,CAAU,sCAAsC,IAAI,OAAO,MAAM,MAAM,CAAC,EAAxE,CAAN;AACH;AACJ;AAnCL;AAqCH;;AAtCe,EAAA,iBAAA,CAAA,eAAA,GAAe,eAAf;;AA6ChB,WAAgB,cAAhB,CAA+B,GAA/B,EAA4C,IAA5C,EAAwD;AACpD,YAAO,IAAP;AACI,WAAK,KAAL;AAAY;AACR,iBAAO,aAAa,CAAC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAD,CAApB;AACH;;AACD,WAAK,KAAL;AAAY;AACR,iBAAO,OAAO,CAAC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAD,CAAd;AACH;;AACD,WAAK,QAAL;AAAe;AACX,iBAAO,UAAU,CAAC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAD,CAAjB;AACH;;AACD,WAAK,UAAL;AAAiB;AACb,iBAAO,WAAW,CAAC,KAAK,GAAG,CAAC,KAAJ,CAAU,IAAI,CAAd,CAAgB,EAAtB,CAAlB;AACH;;AACD,WAAK,SAAL;AAAgB;AACZ,iBAAO,WAAW,CAAC,GAAG,CAAC,KAAJ,CAAU,IAAI,CAAd,CAAD,CAAlB;AACH;;AACD,WAAK,OAAL;AAAc;AACV,iBAAO,GAAG,CAAC,KAAJ,CAAU,IAAI,CAAd,CAAP;AACH;;AACD;AAAS;AACL,iBAAO,mBAAA,CAAA,iBAAA,CAAkB,cAAlB,CAAiC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAjC,EAA+C,IAAtD;AACH;AArBL;AAuBH;;AAxBe,EAAA,iBAAA,CAAA,cAAA,GAAc,cAAd;;AA6BhB,WAAgB,eAAhB,CAAgC,GAAhC,EAA2C;AACvC,WAAO,kBAAkB,CAAC,aAAA,CAAA,WAAA,CAAY,UAAZ,CAAuB,GAAvB,EAA4B,EAA5B,CAAD,EAAkC,MAAlC,CAAzB;AACH;;AAFe,EAAA,iBAAA,CAAA,eAAA,GAAe,eAAf;AAGnB,CAhdD,EAAiB,iBAAiB,GAAjB,OAAA,CAAA,iBAAA,KAAA,OAAA,CAAA,iBAAA,GAAiB,EAAjB,CAAjB","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bs58check_1 = __importDefault(require(\"bs58check\"));\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst CryptoUtils_1 = require(\"../../utils/CryptoUtils\");\nconst TezosLanguageUtil_1 = require(\"./TezosLanguageUtil\");\nconst TezosChainTypes_1 = require(\"../../types/tezos/TezosChainTypes\");\nvar TezosMessageUtils;\n(function (TezosMessageUtils) {\n    function writeBoolean(value) {\n        return value ? \"ff\" : \"00\";\n    }\n    TezosMessageUtils.writeBoolean = writeBoolean;\n    function readBoolean(hex) {\n        return parseInt(hex, 16) > 0 ? true : false;\n    }\n    TezosMessageUtils.readBoolean = readBoolean;\n    function writeInt(value) {\n        if (value < 0) {\n            throw new Error('Use writeSignedInt to encode negative numbers');\n        }\n        return Buffer.from(Buffer.from(CryptoUtils_1.CryptoUtils.twoByteHex(value), 'hex').map((v, i) => { return i === 0 ? v : v ^ 0x80; }).reverse()).toString('hex');\n    }\n    TezosMessageUtils.writeInt = writeInt;\n    function writeSignedInt(value) {\n        if (value === 0) {\n            return '00';\n        }\n        const n = big_integer_1.default(value).abs();\n        const l = n.bitLength().toJSNumber();\n        let arr = [];\n        let v = n;\n        for (let i = 0; i < l; i += 7) {\n            let byte = big_integer_1.default.zero;\n            if (i === 0) {\n                byte = v.and(0x3f);\n                v = v.shiftRight(6);\n            }\n            else {\n                byte = v.and(0x7f);\n                v = v.shiftRight(7);\n            }\n            if (value < 0 && i === 0) {\n                byte = byte.or(0x40);\n            }\n            if (i + 7 < l) {\n                byte = byte.or(0x80);\n            }\n            arr.push(byte.toJSNumber());\n        }\n        if (l % 7 === 0) {\n            arr[arr.length - 1] = arr[arr.length - 1] | 0x80;\n            arr.push(1);\n        }\n        return arr.map(v => ('0' + v.toString(16)).slice(-2)).join('');\n    }\n    TezosMessageUtils.writeSignedInt = writeSignedInt;\n    function readInt(hex) {\n        const h = Buffer.from(Buffer.from(hex, 'hex').reverse().map((v, i) => { return i === 0 ? v : v & 0x7f; })).toString('hex');\n        return CryptoUtils_1.CryptoUtils.fromByteHex(h);\n    }\n    TezosMessageUtils.readInt = readInt;\n    function readSignedInt(hex) {\n        const positive = (Buffer.from(hex.slice(0, 2), 'hex')[0] & 0x40) ? false : true;\n        const arr = Buffer.from(hex, 'hex').map((v, i) => i === 0 ? v & 0x3f : v & 0x7f);\n        let n = big_integer_1.default.zero;\n        for (let i = arr.length - 1; i >= 0; i--) {\n            if (i === 0) {\n                n = n.or(arr[i]);\n            }\n            else {\n                n = n.or(big_integer_1.default(arr[i]).shiftLeft(7 * i - 1));\n            }\n        }\n        return positive ? n.toJSNumber() : n.negate().toJSNumber();\n    }\n    TezosMessageUtils.readSignedInt = readSignedInt;\n    function findInt(hex, offset, signed = false) {\n        let buffer = \"\";\n        let i = 0;\n        while (offset + i * 2 < hex.length) {\n            let start = offset + i * 2;\n            let end = start + 2;\n            let part = hex.substring(start, end);\n            buffer += part;\n            i += 1;\n            if (parseInt(part, 16) < 127) {\n                break;\n            }\n        }\n        return signed ? { value: readSignedInt(buffer), length: i * 2 } : { value: readInt(buffer), length: i * 2 };\n    }\n    TezosMessageUtils.findInt = findInt;\n    function writeString(value) {\n        const len = dataLength(value.length);\n        const text = value.split('').map(c => c.charCodeAt(0).toString(16)).join('');\n        return len + text;\n    }\n    TezosMessageUtils.writeString = writeString;\n    function readString(hex) {\n        const stringLen = parseInt(hex.substring(0, 8), 16);\n        if (stringLen === 0) {\n            return '';\n        }\n        const stringHex = hex.slice(8);\n        let text = '';\n        for (let i = 0; i < stringHex.length; i += 2) {\n            text += String.fromCharCode(parseInt(stringHex.substring(i, i + 2), 16));\n        }\n        return text;\n    }\n    TezosMessageUtils.readString = readString;\n    function readAddress(hex) {\n        if (hex.length !== 44 && hex.length !== 42) {\n            throw new Error(\"Incorrect hex length to parse an address\");\n        }\n        let implicitHint = hex.length === 44 ? hex.substring(0, 4) : \"00\" + hex.substring(0, 2);\n        let implicitPrefixLength = hex.length === 44 ? 4 : 2;\n        if (implicitHint === \"0000\") {\n            return bs58check_1.default.encode(Buffer.from(\"06a19f\" + hex.substring(implicitPrefixLength), \"hex\"));\n        }\n        else if (implicitHint === \"0001\") {\n            return bs58check_1.default.encode(Buffer.from(\"06a1a1\" + hex.substring(implicitPrefixLength), \"hex\"));\n        }\n        else if (implicitHint === \"0002\") {\n            return bs58check_1.default.encode(Buffer.from(\"06a1a4\" + hex.substring(implicitPrefixLength), \"hex\"));\n        }\n        else if (hex.substring(0, 2) === \"01\" && hex.length === 44) {\n            return bs58check_1.default.encode(Buffer.from(\"025a79\" + hex.substring(2, 42), \"hex\"));\n        }\n        else {\n            throw new Error(\"Unrecognized address type\");\n        }\n    }\n    TezosMessageUtils.readAddress = readAddress;\n    function readAddressWithHint(b, hint) {\n        const address = !(b instanceof Buffer) ? Buffer.from(b) : b;\n        if (hint === 'tz1') {\n            return readAddress(`0000${address.toString('hex')}`);\n        }\n        else if (hint === 'tz2') {\n            return readAddress(`0001${address.toString('hex')}`);\n        }\n        else if (hint === 'tz3') {\n            return readAddress(`0002${address.toString('hex')}`);\n        }\n        else if (hint === 'kt1') {\n            return readAddress(`01${address.toString('hex')}00`);\n        }\n        else {\n            throw new Error(`Unrecognized address hint, '${hint}'`);\n        }\n    }\n    TezosMessageUtils.readAddressWithHint = readAddressWithHint;\n    function writeAddress(address) {\n        const hex = bs58check_1.default.decode(address).slice(3).toString(\"hex\");\n        if (address.startsWith(\"tz1\")) {\n            return \"0000\" + hex;\n        }\n        else if (address.startsWith(\"tz2\")) {\n            return \"0001\" + hex;\n        }\n        else if (address.startsWith(\"tz3\")) {\n            return \"0002\" + hex;\n        }\n        else if (address.startsWith(\"KT1\")) {\n            return \"01\" + hex + \"00\";\n        }\n        else {\n            throw new Error(`Unrecognized address prefix: ${address.substring(0, 3)}`);\n        }\n    }\n    TezosMessageUtils.writeAddress = writeAddress;\n    function readBranch(hex) {\n        if (hex.length !== 64) {\n            throw new Error('Incorrect hex length to parse a branch hash');\n        }\n        return bs58check_1.default.encode(Buffer.from('0134' + hex, 'hex'));\n    }\n    TezosMessageUtils.readBranch = readBranch;\n    function writeBranch(branch) {\n        return bs58check_1.default.decode(branch).slice(2).toString(\"hex\");\n    }\n    TezosMessageUtils.writeBranch = writeBranch;\n    function readPublicKey(hex) {\n        if (hex.length !== 66 && hex.length !== 68) {\n            throw new Error(`Incorrect hex length, ${hex.length} to parse a key`);\n        }\n        let hint = hex.substring(0, 2);\n        if (hint === \"00\") {\n            return bs58check_1.default.encode(Buffer.from(\"0d0f25d9\" + hex.substring(2), \"hex\"));\n        }\n        else if (hint === \"01\" && hex.length === 68) {\n            return bs58check_1.default.encode(Buffer.from(\"03fee256\" + hex.substring(2), \"hex\"));\n        }\n        else if (hint === \"02\" && hex.length === 68) {\n            return bs58check_1.default.encode(Buffer.from(\"03b28b7f\" + hex.substring(2), \"hex\"));\n        }\n        else {\n            throw new Error('Unrecognized key type');\n        }\n    }\n    TezosMessageUtils.readPublicKey = readPublicKey;\n    function writePublicKey(publicKey) {\n        if (publicKey.startsWith(\"edpk\")) {\n            return \"00\" + bs58check_1.default.decode(publicKey).slice(4).toString(\"hex\");\n        }\n        else if (publicKey.startsWith(\"sppk\")) {\n            return \"01\" + bs58check_1.default.decode(publicKey).slice(4).toString(\"hex\");\n        }\n        else if (publicKey.startsWith(\"p2pk\")) {\n            return \"02\" + bs58check_1.default.decode(publicKey).slice(4).toString(\"hex\");\n        }\n        else {\n            throw new Error('Unrecognized key type');\n        }\n    }\n    TezosMessageUtils.writePublicKey = writePublicKey;\n    function readKeyWithHint(b, hint) {\n        const key = !(b instanceof Buffer) ? Buffer.from(b) : b;\n        if (hint === 'edsk') {\n            return bs58check_1.default.encode(Buffer.from('2bf64e07' + key.toString('hex'), 'hex'));\n        }\n        else if (hint === 'edpk') {\n            return readPublicKey(`00${key.toString('hex')}`);\n        }\n        else {\n            throw new Error(`Unrecognized key hint, '${hint}'`);\n        }\n    }\n    TezosMessageUtils.readKeyWithHint = readKeyWithHint;\n    function writeKeyWithHint(key, hint) {\n        if (hint === 'edsk' || hint === 'edpk') {\n            return bs58check_1.default.decode(key).slice(4);\n        }\n        else {\n            throw new Error(`Unrecognized key hint, '${hint}'`);\n        }\n    }\n    TezosMessageUtils.writeKeyWithHint = writeKeyWithHint;\n    function readSignatureWithHint(b, hint) {\n        const sig = !(b instanceof Buffer) ? Buffer.from(b) : b;\n        if (hint === 'edsig') {\n            return bs58check_1.default.encode(Buffer.from('09f5cd8612' + sig.toString('hex'), 'hex'));\n        }\n        else {\n            throw new Error(`Unrecognized signature hint, '${hint}'`);\n        }\n    }\n    TezosMessageUtils.readSignatureWithHint = readSignatureWithHint;\n    function writeSignatureWithHint(sig, hint) {\n        if (hint === 'edsig') {\n            return bs58check_1.default.decode(sig).slice(5);\n        }\n        else {\n            throw new Error(`Unrecognized key hint, '${hint}'`);\n        }\n    }\n    TezosMessageUtils.writeSignatureWithHint = writeSignatureWithHint;\n    function readBufferWithHint(b, hint) {\n        const buffer = !(b instanceof Buffer) ? Buffer.from(b) : b;\n        if (hint === 'op') {\n            return bs58check_1.default.encode(Buffer.from('0574' + buffer.toString('hex'), 'hex'));\n        }\n        else if (hint === 'p') {\n            return bs58check_1.default.encode(Buffer.from('02aa' + buffer.toString('hex'), 'hex'));\n        }\n        else if (hint === 'expr') {\n            return bs58check_1.default.encode(Buffer.from('0d2c401b' + buffer.toString('hex'), 'hex'));\n        }\n        else if (hint === '') {\n            return bs58check_1.default.encode(buffer);\n        }\n        else {\n            throw new Error(`Unsupported hint, '${hint}'`);\n        }\n    }\n    TezosMessageUtils.readBufferWithHint = readBufferWithHint;\n    function writeBufferWithHint(b) {\n        return bs58check_1.default.decode(b);\n    }\n    TezosMessageUtils.writeBufferWithHint = writeBufferWithHint;\n    function computeOperationHash(signedOpGroup) {\n        const hash = CryptoUtils_1.CryptoUtils.simpleHash(signedOpGroup.bytes, 32);\n        return readBufferWithHint(hash, \"op\");\n    }\n    TezosMessageUtils.computeOperationHash = computeOperationHash;\n    function computeKeyHash(key, prefix = 'tz1') {\n        const hash = CryptoUtils_1.CryptoUtils.simpleHash(key, 20);\n        return readAddressWithHint(hash, prefix);\n    }\n    TezosMessageUtils.computeKeyHash = computeKeyHash;\n    function dataLength(value) {\n        return ('0000000' + (value).toString(16)).slice(-8);\n    }\n    function writePackedData(value, type, format = TezosChainTypes_1.TezosParameterFormat.Micheline) {\n        switch (type) {\n            case 'int': {\n                return '0500' + writeSignedInt(value);\n            }\n            case 'nat': {\n                return '0500' + writeInt(value);\n            }\n            case 'string': {\n                return '0501' + writeString(value);\n            }\n            case 'key_hash': {\n                const address = writeAddress(value).slice(2);\n                return `050a${dataLength(address.length / 2)}${address}`;\n            }\n            case 'address': {\n                const address = writeAddress(value);\n                return `050a${dataLength(address.length / 2)}${address}`;\n            }\n            case 'bytes': {\n                const buffer = value.toString('hex');\n                return `050a${dataLength(buffer.length / 2)}${buffer}`;\n            }\n            default: {\n                try {\n                    if (format === TezosChainTypes_1.TezosParameterFormat.Micheline) {\n                        return `05${TezosLanguageUtil_1.TezosLanguageUtil.translateMichelineToHex(value)}`;\n                    }\n                    else if (format === TezosChainTypes_1.TezosParameterFormat.Michelson) {\n                        const micheline = TezosLanguageUtil_1.TezosLanguageUtil.translateMichelsonToMicheline(value);\n                        return `05${TezosLanguageUtil_1.TezosLanguageUtil.translateMichelineToHex(micheline)}`;\n                    }\n                    else {\n                        throw new Error(`Unsupported format, ${format}, provided`);\n                    }\n                }\n                catch (e) {\n                    throw new Error(`Unrecognized data type or format: '${type}', '${format}': ${e}`);\n                }\n            }\n        }\n    }\n    TezosMessageUtils.writePackedData = writePackedData;\n    function readPackedData(hex, type) {\n        switch (type) {\n            case 'int': {\n                return readSignedInt(hex.slice(4));\n            }\n            case 'nat': {\n                return readInt(hex.slice(4));\n            }\n            case 'string': {\n                return readString(hex.slice(4));\n            }\n            case 'key_hash': {\n                return readAddress(`00${hex.slice(4 + 8)}`);\n            }\n            case 'address': {\n                return readAddress(hex.slice(4 + 8));\n            }\n            case 'bytes': {\n                return hex.slice(4 + 8);\n            }\n            default: {\n                return TezosLanguageUtil_1.TezosLanguageUtil.hexToMicheline(hex.slice(2)).code;\n            }\n        }\n    }\n    TezosMessageUtils.readPackedData = readPackedData;\n    function encodeBigMapKey(key) {\n        return readBufferWithHint(CryptoUtils_1.CryptoUtils.simpleHash(key, 32), 'expr');\n    }\n    TezosMessageUtils.encodeBigMapKey = encodeBigMapKey;\n})(TezosMessageUtils = exports.TezosMessageUtils || (exports.TezosMessageUtils = {}));\n//# sourceMappingURL=TezosMessageUtil.js.map"]},"metadata":{},"sourceType":"script"}