{"ast":null,"code":"import { OpKind, RpcClient } from '@taquito/rpc';\nexport { OpKind } from '@taquito/rpc';\nimport { importKey } from '@taquito/signer';\nimport { combineLatest, ReplaySubject, from, defer, timer, throwError, of, range, concat, Subject, Observable } from 'rxjs';\nimport { distinctUntilChanged, map, takeWhile, tap, shareReplay, filter, first, switchMap, distinctUntilKeyChanged, timeoutWith, startWith, concatMap, mapTo, switchMapTo, takeUntil, pluck, publishReplay, refCount } from 'rxjs/operators';\nimport BigNumber from 'bignumber.js';\nimport { Schema, ParameterSchema } from '@taquito/michelson-encoder';\nexport { MichelsonMap, UnitValue } from '@taquito/michelson-encoder';\nimport { Parser } from '@taquito/michel-codec';\nimport { encodeExpr } from '@taquito/utils';\nimport { HttpResponseError, STATUS_CODE } from '@taquito/http-utils';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\nvar RpcForger =\n/** @class */\nfunction () {\n  function RpcForger(context) {\n    this.context = context;\n  }\n\n  RpcForger.prototype.forge = function (_a) {\n    var branch = _a.branch,\n        contents = _a.contents;\n    return this.context.rpc.forgeOperations({\n      branch: branch,\n      contents: contents\n    });\n  };\n\n  return RpcForger;\n}();\n\nvar RpcInjector =\n/** @class */\nfunction () {\n  function RpcInjector(context) {\n    this.context = context;\n  }\n\n  RpcInjector.prototype.inject = function (signedOperationBytes) {\n    return this.context.rpc.injectOperation(signedOperationBytes);\n  };\n\n  return RpcInjector;\n}();\n\nvar UnconfiguredSignerError =\n/** @class */\nfunction () {\n  function UnconfiguredSignerError() {\n    this.name = 'UnconfiguredSignerError';\n    this.message = 'No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.';\n  }\n\n  return UnconfiguredSignerError;\n}();\n/**\r\n * @description Default signer implementation which does nothing and produce invalid signature\r\n */\n\n\nvar NoopSigner =\n/** @class */\nfunction () {\n  function NoopSigner() {}\n\n  NoopSigner.prototype.publicKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  NoopSigner.prototype.publicKeyHash = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  NoopSigner.prototype.secretKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  NoopSigner.prototype.sign = function (_bytes, _watermark) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  return NoopSigner;\n}();\n\nvar attachKind = function (op, kind) {\n  return __assign(__assign({}, op), {\n    kind: kind\n  });\n};\n\nvar findWithKind = function (arr, kind) {\n  if (Array.isArray(arr)) {\n    var found = arr.find(function (op) {\n      return op.kind === kind;\n    });\n\n    if (found && isKind(found, kind)) {\n      return found;\n    }\n  }\n};\n\nvar isKind = function (op, kind) {\n  return op.kind === kind;\n};\n\nvar isOpWithFee = function (op) {\n  return ['transaction', 'delegation', 'origination', 'reveal'].indexOf(op.kind) !== -1;\n};\n\nvar isOpRequireReveal = function (op) {\n  return ['transaction', 'delegation', 'origination'].indexOf(op.kind) !== -1;\n};\n\nvar hasMetadata = function (op) {\n  return 'metadata' in op;\n};\n\nvar hasMetadataWithResult = function (op) {\n  return hasMetadata(op) && 'operation_result' in op.metadata;\n};\n\nvar hasMetadataWithInternalOperationResult = function (op) {\n  return hasMetadata(op) && 'internal_operation_results' in op.metadata;\n};\n\nvar isErrorWithMessage = function (error) {\n  return 'with' in error;\n};\n\nvar TezosOperationError =\n/** @class */\nfunction () {\n  function TezosOperationError(errors) {\n    this.errors = errors;\n    this.name = 'TezosOperationError'; // Last error is 'often' the one with more detail\n\n    var lastError = errors[errors.length - 1];\n    this.id = lastError.id;\n    this.kind = lastError.kind;\n    this.message = \"(\" + this.kind + \") \" + this.id;\n\n    if (isErrorWithMessage(lastError) && lastError.with.string) {\n      this.message = lastError.with.string;\n    }\n  }\n\n  return TezosOperationError;\n}();\n\nvar TezosPreapplyFailureError =\n/** @class */\nfunction () {\n  function TezosPreapplyFailureError(result) {\n    this.result = result;\n    this.name = 'TezosPreapplyFailureError';\n    this.message = 'Preapply returned an unexpected result';\n  }\n\n  return TezosPreapplyFailureError;\n}(); // Flatten all operation content results and internal operation results into a single array\n// Some cases where we can have multiple operation results or internal operation results are:\n// - When an operation includes a reveal operation\n// - When an operation is made using the batch API\n// - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts\n\n\nvar flattenOperationResult = function (response) {\n  var results = Array.isArray(response) ? response : [response];\n  var returnedResults = [];\n\n  for (var i = 0; i < results.length; i++) {\n    for (var j = 0; j < results[i].contents.length; j++) {\n      var content = results[i].contents[j];\n\n      if (hasMetadataWithResult(content)) {\n        returnedResults.push(__assign({\n          fee: content.fee\n        }, content.metadata.operation_result));\n\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          content.metadata.internal_operation_results.forEach(function (x) {\n            return returnedResults.push(x.result);\n          });\n        }\n      }\n    }\n  }\n\n  return returnedResults;\n};\n/***\r\n * @description Flatten all error from preapply response (including internal error)\r\n */\n\n\nvar flattenErrors = function (response, status) {\n  var e_1, _a;\n\n  if (status === void 0) {\n    status = 'failed';\n  }\n\n  var results = Array.isArray(response) ? response : [response];\n  var errors = []; // Transaction that do not fail will be backtracked in case one failure occur\n\n  for (var i = 0; i < results.length; i++) {\n    for (var j = 0; j < results[i].contents.length; j++) {\n      var content = results[i].contents[j];\n\n      if (hasMetadata(content)) {\n        if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {\n          errors = errors.concat(content.metadata.operation_result.errors || []);\n        }\n\n        if (hasMetadataWithInternalOperationResult(content) && Array.isArray(content.metadata.internal_operation_results)) {\n          try {\n            for (var _b = (e_1 = void 0, __values(content.metadata.internal_operation_results)), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var internalResult = _c.value;\n\n              if ('result' in internalResult && internalResult.result.status === status) {\n                errors = errors.concat(internalResult.result.errors || []);\n              }\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n\nvar receiptFromOperation = function (op, _a) {\n  var _b = _a === void 0 ? {\n    ALLOCATION_BURN: 257,\n    ORIGINATION_BURN: 257\n  } : _a,\n      ALLOCATION_BURN = _b.ALLOCATION_BURN,\n      ORIGINATION_BURN = _b.ORIGINATION_BURN;\n\n  var operationResults = flattenOperationResult({\n    contents: op\n  });\n  var totalGas = new BigNumber(0);\n  var totalStorage = new BigNumber(0);\n  var totalFee = new BigNumber(0);\n  var totalOriginationBurn = new BigNumber(0);\n  var totalAllocationBurn = new BigNumber(0);\n  var totalPaidStorageDiff = new BigNumber(0);\n  operationResults.forEach(function (result) {\n    totalFee = totalFee.plus(result.fee || 0);\n    totalOriginationBurn = totalOriginationBurn.plus(Array.isArray(result.originated_contracts) ? result.originated_contracts.length * ORIGINATION_BURN : 0);\n    totalAllocationBurn = totalAllocationBurn.plus('allocated_destination_contract' in result ? ALLOCATION_BURN : 0);\n    totalGas = totalGas.plus(result.consumed_gas || 0);\n    totalPaidStorageDiff = totalPaidStorageDiff.plus('paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0);\n  });\n  totalStorage = totalStorage.plus(totalAllocationBurn).plus(totalOriginationBurn).plus(totalPaidStorageDiff);\n  return {\n    totalFee: totalFee,\n    totalGas: totalGas,\n    totalStorage: totalStorage,\n    totalAllocationBurn: totalAllocationBurn,\n    totalOriginationBurn: totalOriginationBurn,\n    totalPaidStorageDiff: totalPaidStorageDiff,\n    totalStorageBurn: new BigNumber(totalStorage.multipliedBy(1000))\n  };\n};\n\nvar MissedBlockDuringConfirmationError =\n/** @class */\nfunction () {\n  function MissedBlockDuringConfirmationError() {\n    this.name = 'MissedBlockDuringConfirmationError';\n    this.message = 'Taquito missed a block while waiting for operation confirmation and was not able to find the operation';\n  }\n\n  return MissedBlockDuringConfirmationError;\n}();\n\nvar MAX_BRANCH_ANCESTORS = 60;\n/**\r\n * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation\r\n */\n\nvar WalletOperation =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param opHash Operation hash\r\n   * @param raw Raw operation that was injected\r\n   * @param context Taquito context allowing access to rpc and signer\r\n   */\n  function WalletOperation(opHash, context, _newHead$) {\n    var _this = this;\n\n    this.opHash = opHash;\n    this.context = context;\n    this._newHead$ = _newHead$;\n    this._operationResult = new ReplaySubject(1);\n    this._includedInBlock = new ReplaySubject(1);\n    this._included = false;\n    this.newHead$ = this._newHead$.pipe(tap(function (newHead) {\n      if (!_this._included && _this.lastHead && newHead.header.level - _this.lastHead.header.level > 1) {\n        throw new MissedBlockDuringConfirmationError();\n      }\n\n      _this.lastHead = newHead;\n    }), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    })); // Observable that emit once operation is seen in a block\n\n    this.confirmed$ = this.newHead$.pipe(map(function (head) {\n      var e_1, _a, e_2, _b;\n\n      try {\n        for (var _c = __values(head.operations), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var opGroup = _d.value;\n\n          try {\n            for (var opGroup_1 = (e_2 = void 0, __values(opGroup)), opGroup_1_1 = opGroup_1.next(); !opGroup_1_1.done; opGroup_1_1 = opGroup_1.next()) {\n              var op = opGroup_1_1.value;\n\n              if (op.hash === _this.opHash) {\n                _this._included = true;\n\n                _this._includedInBlock.next(head);\n\n                _this._operationResult.next(op.contents); // Return the block where the operation was found\n\n\n                return head;\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (opGroup_1_1 && !opGroup_1_1.done && (_b = opGroup_1.return)) _b.call(opGroup_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }), filter(function (x) {\n      return typeof x !== 'undefined';\n    }), first(), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  WalletOperation.prototype.operationResults = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this._operationResult.pipe(first()).toPromise()];\n      });\n    });\n  };\n  /**\r\n   * @description Receipt expose the total amount of tezos token burn and spent on fees\r\n   * The promise returned by receipt will resolve only once the transaction is included\r\n   */\n\n\n  WalletOperation.prototype.receipt = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = receiptFromOperation;\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.apply(void 0, [_b.sent()])];\n        }\n      });\n    });\n  };\n\n  WalletOperation.prototype.getCurrentConfirmation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!this._included) {\n          return [2\n          /*return*/\n          , 0];\n        }\n\n        return [2\n        /*return*/\n        , combineLatest([this._includedInBlock, from(this.context.rpc.getBlock())]).pipe(map(function (_a) {\n          var _b = __read(_a, 2),\n              foundAtBlock = _b[0],\n              head = _b[1];\n\n          return head.header.level - foundAtBlock.header.level + 1;\n        }), first()).toPromise()];\n      });\n    });\n  };\n\n  WalletOperation.prototype.isInCurrentBranch = function (tipBlockIdentifier) {\n    if (tipBlockIdentifier === void 0) {\n      tipBlockIdentifier = 'head';\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var tipBlockHeader, inclusionBlock, levelDiff, tipBlockLevel, blocks, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            // By default it is assumed that the operation is in the current branch\n            if (!this._included) {\n              return [2\n              /*return*/\n              , true];\n            }\n\n            return [4\n            /*yield*/\n            , this.context.rpc.getBlockHeader({\n              block: tipBlockIdentifier\n            })];\n\n          case 1:\n            tipBlockHeader = _b.sent();\n            return [4\n            /*yield*/\n            , this._includedInBlock.pipe(first()).toPromise()];\n\n          case 2:\n            inclusionBlock = _b.sent();\n            levelDiff = tipBlockHeader.level - inclusionBlock.header.level; // Block produced before the operation is included are assumed to be part of the current branch\n\n            if (levelDiff <= 0) {\n              return [2\n              /*return*/\n              , true];\n            }\n\n            tipBlockLevel = Math.min(inclusionBlock.header.level + levelDiff, inclusionBlock.header.level + MAX_BRANCH_ANCESTORS);\n            _a = Set.bind;\n            return [4\n            /*yield*/\n            , this.context.rpc.getLiveBlocks({\n              block: String(tipBlockLevel)\n            })];\n\n          case 3:\n            blocks = new (_a.apply(Set, [void 0, _b.sent()]))();\n            return [2\n            /*return*/\n            , blocks.has(inclusionBlock.hash)];\n        }\n      });\n    });\n  };\n\n  WalletOperation.prototype.confirmationObservable = function (confirmations) {\n    var _this = this;\n\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new Error('Confirmation count must be at least 1');\n    }\n\n    var defaultConfirmationCount = this.context.config.defaultConfirmationCount;\n    var conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n    return combineLatest([this._includedInBlock, this.newHead$]).pipe(distinctUntilChanged(function (_a, _b) {\n      var _c = __read(_a, 2),\n          previousHead = _c[1];\n\n      var _d = __read(_b, 2),\n          newHead = _d[1];\n\n      return previousHead.hash === newHead.hash;\n    }), map(function (_a) {\n      var _b = __read(_a, 2),\n          foundAtBlock = _b[0],\n          head = _b[1];\n\n      return {\n        block: head,\n        expectedConfirmation: conf,\n        currentConfirmation: head.header.level - foundAtBlock.header.level + 1,\n        completed: head.header.level - foundAtBlock.header.level >= conf - 1,\n        isInCurrentBranch: function () {\n          return _this.isInCurrentBranch(head.hash);\n        }\n      };\n    }), takeWhile(function (_a) {\n      var completed = _a.completed;\n      return !completed;\n    }, true));\n  };\n  /**\r\n   *\r\n   * @param confirmations [0] Number of confirmation to wait for\r\n   */\n\n\n  WalletOperation.prototype.confirmation = function (confirmations) {\n    return this.confirmationObservable(confirmations).toPromise();\n  };\n\n  return WalletOperation;\n}();\n\nvar DelegationWalletOperation =\n/** @class */\nfunction (_super) {\n  __extends(DelegationWalletOperation, _super);\n\n  function DelegationWalletOperation(opHash, context, newHead$) {\n    var _this = _super.call(this, opHash, context, newHead$) || this;\n\n    _this.opHash = opHash;\n    _this.context = context;\n    return _this;\n  }\n\n  DelegationWalletOperation.prototype.revealOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , operationResult.find(function (x) {\n              return x.kind === OpKind.REVEAL;\n            })];\n        }\n      });\n    });\n  };\n\n  DelegationWalletOperation.prototype.delegationOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , operationResult.find(function (x) {\n              return x.kind === OpKind.DELEGATION;\n            })];\n        }\n      });\n    });\n  };\n\n  DelegationWalletOperation.prototype.status = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var op;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._included) {\n              return [2\n              /*return*/\n              , 'pending'];\n            }\n\n            return [4\n            /*yield*/\n            , this.delegationOperation()];\n\n          case 1:\n            op = _a.sent();\n\n            if (!op) {\n              return [2\n              /*return*/\n              , 'unknown'];\n            }\n\n            return [2\n            /*return*/\n            , op.metadata.operation_result.status];\n        }\n      });\n    });\n  };\n\n  return DelegationWalletOperation;\n}(WalletOperation);\n\nvar OriginationWalletOperation =\n/** @class */\nfunction (_super) {\n  __extends(OriginationWalletOperation, _super);\n\n  function OriginationWalletOperation(opHash, context, newHead$) {\n    var _this = _super.call(this, opHash, context, newHead$) || this;\n\n    _this.opHash = opHash;\n    _this.context = context;\n    return _this;\n  }\n\n  OriginationWalletOperation.prototype.originationOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , findWithKind(operationResult, OpKind.ORIGINATION)];\n        }\n      });\n    });\n  };\n\n  OriginationWalletOperation.prototype.revealOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , findWithKind(operationResult, OpKind.REVEAL)];\n        }\n      });\n    });\n  };\n\n  OriginationWalletOperation.prototype.status = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var op;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._included) {\n              return [2\n              /*return*/\n              , 'pending'];\n            }\n\n            return [4\n            /*yield*/\n            , this.originationOperation()];\n\n          case 1:\n            op = _a.sent();\n\n            if (!op) {\n              return [2\n              /*return*/\n              , 'unknown'];\n            }\n\n            return [2\n            /*return*/\n            , op.metadata.operation_result.status];\n        }\n      });\n    });\n  };\n\n  OriginationWalletOperation.prototype.contract = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var op, address;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.originationOperation()];\n\n          case 1:\n            op = _a.sent();\n            address = (op.metadata.operation_result.originated_contracts || [])[0];\n            return [2\n            /*return*/\n            , this.context.wallet.at(address)];\n        }\n      });\n    });\n  };\n\n  return OriginationWalletOperation;\n}(WalletOperation);\n\nvar TransactionWalletOperation =\n/** @class */\nfunction (_super) {\n  __extends(TransactionWalletOperation, _super);\n\n  function TransactionWalletOperation(opHash, context, newHead$) {\n    var _this = _super.call(this, opHash, context, newHead$) || this;\n\n    _this.opHash = opHash;\n    _this.context = context;\n    return _this;\n  }\n\n  TransactionWalletOperation.prototype.revealOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , operationResult.find(function (x) {\n              return x.kind === OpKind.REVEAL;\n            })];\n        }\n      });\n    });\n  };\n\n  TransactionWalletOperation.prototype.transactionOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , operationResult.find(function (x) {\n              return x.kind === OpKind.TRANSACTION;\n            })];\n        }\n      });\n    });\n  };\n\n  TransactionWalletOperation.prototype.status = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var op;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._included) {\n              return [2\n              /*return*/\n              , 'pending'];\n            }\n\n            return [4\n            /*yield*/\n            , this.transactionOperation()];\n\n          case 1:\n            op = _a.sent();\n\n            if (!op) {\n              return [2\n              /*return*/\n              , 'unknown'];\n            }\n\n            return [2\n            /*return*/\n            , op.metadata.operation_result.status];\n        }\n      });\n    });\n  };\n\n  return TransactionWalletOperation;\n}(WalletOperation);\n\nvar cacheUntil = function (cacheUntilObs) {\n  return function (source) {\n    var subject = null;\n    return defer(function () {\n      if (!subject) {\n        subject = new ReplaySubject();\n        source.pipe(first()).subscribe(subject);\n        cacheUntilObs.pipe(first()).subscribe(function () {\n          subject = null;\n        });\n      }\n\n      return subject;\n    });\n  };\n};\n\nvar createNewPollingBasedHeadObservable = function (pollingTimer, sharedHeadOb, context, scheduler) {\n  return pollingTimer.pipe(switchMap(function () {\n    return sharedHeadOb;\n  }), distinctUntilKeyChanged('hash'), timeoutWith(context.config.confirmationPollingTimeoutSecond * 1000, throwError(new Error('Confirmation polling timed out')), scheduler), shareReplay({\n    refCount: true,\n    scheduler: scheduler\n  }));\n};\n\nvar OperationFactory =\n/** @class */\nfunction () {\n  function OperationFactory(context) {\n    var _this = this;\n\n    this.context = context; // Cache the last block for one second across all operations\n\n    this.sharedHeadObs = defer(function () {\n      return from(_this.context.rpc.getBlock());\n    }).pipe(cacheUntil(timer(0, 1000)));\n  }\n\n  OperationFactory.prototype.createNewHeadObservable = function () {\n    return createNewPollingBasedHeadObservable(timer(0, this.context.config.confirmationPollingIntervalSecond * 1000), this.sharedHeadObs, this.context);\n  };\n\n  OperationFactory.prototype.createPastBlockWalker = function (startBlock, count) {\n    var _this = this;\n\n    if (count === void 0) {\n      count = 1;\n    }\n\n    return from(this.context.rpc.getBlock({\n      block: startBlock\n    })).pipe(switchMap(function (block) {\n      if (count === 1) {\n        return of(block);\n      }\n\n      return range(block.header.level, count - 1).pipe(startWith(block), concatMap(function (level) {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            return [2\n            /*return*/\n            , this.context.rpc.getBlock({\n              block: String(level)\n            })];\n          });\n        });\n      }));\n    }));\n  };\n\n  OperationFactory.prototype.createHeadObservableFromConfig = function (_a) {\n    var blockIdentifier = _a.blockIdentifier;\n    var observableSequence = [];\n\n    if (blockIdentifier) {\n      observableSequence.push(this.createPastBlockWalker(blockIdentifier));\n    }\n\n    observableSequence.push(this.createNewHeadObservable());\n    return concat.apply(void 0, __spread(observableSequence));\n  };\n\n  OperationFactory.prototype.createOperation = function (hash, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    return new WalletOperation(hash, this.context.clone(), this.createHeadObservableFromConfig(config));\n  };\n\n  OperationFactory.prototype.createTransactionOperation = function (hash, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    return new TransactionWalletOperation(hash, this.context.clone(), this.createHeadObservableFromConfig(config));\n  };\n\n  OperationFactory.prototype.createDelegationOperation = function (hash, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    return new DelegationWalletOperation(hash, this.context.clone(), this.createHeadObservableFromConfig(config));\n  };\n\n  OperationFactory.prototype.createOriginationOperation = function (hash, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    return new OriginationWalletOperation(hash, this.context.clone(), this.createHeadObservableFromConfig(config));\n  };\n\n  return OperationFactory;\n}();\n\nvar DEFAULT_GAS_LIMIT;\n\n(function (DEFAULT_GAS_LIMIT) {\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"DELEGATION\"] = 10600] = \"DELEGATION\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"ORIGINATION\"] = 10600] = \"ORIGINATION\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"TRANSFER\"] = 10600] = \"TRANSFER\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"REVEAL\"] = 10600] = \"REVEAL\";\n})(DEFAULT_GAS_LIMIT || (DEFAULT_GAS_LIMIT = {}));\n\nvar DEFAULT_FEE;\n\n(function (DEFAULT_FEE) {\n  DEFAULT_FEE[DEFAULT_FEE[\"DELEGATION\"] = 1257] = \"DELEGATION\";\n  DEFAULT_FEE[DEFAULT_FEE[\"ORIGINATION\"] = 10000] = \"ORIGINATION\";\n  DEFAULT_FEE[DEFAULT_FEE[\"TRANSFER\"] = 10000] = \"TRANSFER\";\n  DEFAULT_FEE[DEFAULT_FEE[\"REVEAL\"] = 1420] = \"REVEAL\";\n})(DEFAULT_FEE || (DEFAULT_FEE = {}));\n\nvar DEFAULT_STORAGE_LIMIT;\n\n(function (DEFAULT_STORAGE_LIMIT) {\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"DELEGATION\"] = 0] = \"DELEGATION\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"ORIGINATION\"] = 257] = \"ORIGINATION\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"TRANSFER\"] = 257] = \"TRANSFER\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"REVEAL\"] = 0] = \"REVEAL\";\n})(DEFAULT_STORAGE_LIMIT || (DEFAULT_STORAGE_LIMIT = {}));\n\nvar Protocols;\n\n(function (Protocols) {\n  Protocols[\"Pt24m4xi\"] = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\";\n  Protocols[\"PsBABY5H\"] = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\";\n  Protocols[\"PsBabyM1\"] = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\";\n  Protocols[\"PsCARTHA\"] = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\";\n})(Protocols || (Protocols = {}));\n\nvar protocols = {\n  '004': [Protocols.Pt24m4xi],\n  '005': [Protocols.PsBABY5H, Protocols.PsBabyM1],\n  '006': [Protocols.PsCARTHA]\n};\n\nvar OperationEmitter =\n/** @class */\nfunction () {\n  function OperationEmitter(context) {\n    this.context = context;\n  }\n\n  Object.defineProperty(OperationEmitter.prototype, \"rpc\", {\n    get: function () {\n      return this.context.rpc;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OperationEmitter.prototype, \"signer\", {\n    get: function () {\n      return this.context.signer;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Originally from sotez (Copyright (c) 2018 Andrew Kishino)\n\n  OperationEmitter.prototype.prepareOperation = function (_a) {\n    var operation = _a.operation,\n        source = _a.source;\n    return __awaiter(this, void 0, void 0, function () {\n      var counter, counters, requiresReveal, ops, head, blockHeaderPromise, blockMetaPromise, publicKeyHash, counterPromise, managerPromise, i, counter_1, _b, header, metadata, headCounter, manager, haveManager, reveal, _c, getFee, getSource, constructOps, branch, contents, protocol;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            counters = {};\n            requiresReveal = false;\n            ops = [];\n            blockHeaderPromise = this.rpc.getBlockHeader();\n            blockMetaPromise = this.rpc.getBlockMetadata();\n\n            if (Array.isArray(operation)) {\n              ops = __spread(operation);\n            } else {\n              ops = [operation];\n            }\n\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            publicKeyHash = _d.sent();\n            counterPromise = Promise.resolve(undefined);\n            managerPromise = Promise.resolve(undefined);\n            i = 0;\n            _d.label = 2;\n\n          case 2:\n            if (!(i < ops.length)) return [3\n            /*break*/\n            , 5];\n            if (!isOpRequireReveal(ops[i])) return [3\n            /*break*/\n            , 4];\n            requiresReveal = true;\n            return [4\n            /*yield*/\n            , this.rpc.getContract(publicKeyHash)];\n\n          case 3:\n            counter_1 = _d.sent().counter;\n            counterPromise = Promise.resolve(counter_1);\n            managerPromise = this.rpc.getManagerKey(publicKeyHash);\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            i++;\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [4\n            /*yield*/\n            , Promise.all([blockHeaderPromise, blockMetaPromise, counterPromise, managerPromise])];\n\n          case 6:\n            _b = __read.apply(void 0, [_d.sent(), 4]), header = _b[0], metadata = _b[1], headCounter = _b[2], manager = _b[3];\n\n            if (!header) {\n              throw new Error('Unable to fetch latest block header');\n            }\n\n            if (!metadata) {\n              throw new Error('Unable to fetch latest metadata');\n            }\n\n            head = header;\n            if (!requiresReveal) return [3\n            /*break*/\n            , 8];\n            haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;\n            if (!!haveManager) return [3\n            /*break*/\n            , 8];\n            _c = {\n              kind: OpKind.REVEAL,\n              fee: DEFAULT_FEE.REVEAL\n            };\n            return [4\n            /*yield*/\n            , this.signer.publicKey()];\n\n          case 7:\n            reveal = (_c.public_key = _d.sent(), _c.source = publicKeyHash, _c.gas_limit = DEFAULT_GAS_LIMIT.REVEAL, _c.storage_limit = DEFAULT_STORAGE_LIMIT.REVEAL, _c);\n            ops.unshift(reveal);\n            _d.label = 8;\n\n          case 8:\n            counter = parseInt(headCounter || '0', 10);\n\n            if (!counters[publicKeyHash] || counters[publicKeyHash] < counter) {\n              counters[publicKeyHash] = counter;\n            }\n\n            getFee = function (op) {\n              var opCounter = ++counters[publicKeyHash];\n              return {\n                counter: \"\" + opCounter,\n                // tslint:disable-next-line: strict-type-predicates\n                fee: typeof op.fee === 'undefined' ? '0' : \"\" + op.fee,\n                // tslint:disable-next-line: strict-type-predicates\n                gas_limit: typeof op.gas_limit === 'undefined' ? '0' : \"\" + op.gas_limit,\n                // tslint:disable-next-line: strict-type-predicates\n                storage_limit: typeof op.storage_limit === 'undefined' ? '0' : \"\" + op.storage_limit\n              };\n            };\n\n            getSource = function (op) {\n              return {\n                source: typeof op.source === 'undefined' ? source || publicKeyHash : op.source\n              };\n            };\n\n            constructOps = function (cOps) {\n              // tslint:disable strict-type-predicates\n              return cOps.map(function (op) {\n                switch (op.kind) {\n                  case OpKind.ACTIVATION:\n                    return __assign({}, op);\n\n                  case OpKind.REVEAL:\n                    return __assign(__assign(__assign({}, op), getSource(op)), getFee(op));\n\n                  case OpKind.ORIGINATION:\n                    return __assign(__assign(__assign(__assign({}, op), {\n                      balance: typeof op.balance !== 'undefined' ? \"\" + op.balance : '0'\n                    }), getSource(op)), getFee(op));\n\n                  case OpKind.TRANSACTION:\n                    var cops = __assign(__assign(__assign(__assign({}, op), {\n                      amount: typeof op.amount !== 'undefined' ? \"\" + op.amount : '0'\n                    }), getSource(op)), getFee(op));\n\n                    if (cops.source.toLowerCase().startsWith('kt1')) {\n                      throw new Error(\"KT1 addresses are not supported as source since \" + Protocols.PsBabyM1);\n                    }\n\n                    return cops;\n\n                  case OpKind.DELEGATION:\n                    return __assign(__assign(__assign({}, op), getSource(op)), getFee(op));\n\n                  default:\n                    throw new Error('Unsupported operation');\n                }\n              });\n            };\n\n            branch = head.hash;\n            contents = constructOps(ops);\n            protocol = metadata.next_protocol;\n            return [2\n            /*return*/\n            , {\n              opOb: {\n                branch: branch,\n                contents: contents,\n                protocol: protocol\n              },\n              counter: counter\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.prepareAndForge = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var prepared;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.prepareOperation(params)];\n\n          case 1:\n            prepared = _a.sent();\n            return [2\n            /*return*/\n            , this.forge(prepared)];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.forge = function (_a) {\n    var _b = _a.opOb,\n        branch = _b.branch,\n        contents = _b.contents,\n        protocol = _b.protocol,\n        counter = _a.counter;\n    return __awaiter(this, void 0, void 0, function () {\n      var forgedBytes;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.context.forger.forge({\n              branch: branch,\n              contents: contents\n            })];\n\n          case 1:\n            forgedBytes = _c.sent();\n            return [2\n            /*return*/\n            , {\n              opbytes: forgedBytes,\n              opOb: {\n                branch: branch,\n                contents: contents,\n                protocol: protocol\n              },\n              counter: counter\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.simulate = function (op) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = {};\n            return [4\n            /*yield*/\n            , this.rpc.runOperation(op)];\n\n          case 1:\n            return [2\n            /*return*/\n            , (_a.opResponse = _b.sent(), _a.op = op, _a.context = this.context.clone(), _a)];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.estimate = function (_a, estimator) {\n    var fee = _a.fee,\n        gasLimit = _a.gasLimit,\n        storageLimit = _a.storageLimit,\n        rest = __rest(_a, [\"fee\", \"gasLimit\", \"storageLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var calculatedFee, calculatedGas, calculatedStorage, estimation;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            calculatedFee = fee;\n            calculatedGas = gasLimit;\n            calculatedStorage = storageLimit;\n            if (!(fee === undefined || gasLimit === undefined || storageLimit === undefined)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , estimator(__assign({\n              fee: fee,\n              gasLimit: gasLimit,\n              storageLimit: storageLimit\n            }, rest))];\n\n          case 1:\n            estimation = _b.sent();\n\n            if (calculatedFee === undefined) {\n              calculatedFee = estimation.suggestedFeeMutez;\n            }\n\n            if (calculatedGas === undefined) {\n              calculatedGas = estimation.gasLimit;\n            }\n\n            if (calculatedStorage === undefined) {\n              calculatedStorage = estimation.storageLimit;\n            }\n\n            _b.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , {\n              fee: calculatedFee,\n              gasLimit: calculatedGas,\n              storageLimit: calculatedStorage\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.signAndInject = function (forgedBytes) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signed, opResponse, results, i, j, errors, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]))];\n\n          case 1:\n            signed = _b.sent();\n            forgedBytes.opbytes = signed.sbytes;\n            forgedBytes.opOb.signature = signed.prefixSig;\n            opResponse = [];\n            return [4\n            /*yield*/\n            , this.rpc.preapplyOperations([forgedBytes.opOb])];\n\n          case 2:\n            results = _b.sent();\n\n            if (!Array.isArray(results)) {\n              throw new TezosPreapplyFailureError(results);\n            }\n\n            for (i = 0; i < results.length; i++) {\n              for (j = 0; j < results[i].contents.length; j++) {\n                opResponse.push(results[i].contents[j]);\n              }\n            }\n\n            errors = flattenErrors(results);\n\n            if (errors.length) {\n              // @ts-ignore\n              throw new TezosOperationError(errors);\n            }\n\n            _a = {};\n            return [4\n            /*yield*/\n            , this.context.injector.inject(forgedBytes.opbytes)];\n\n          case 3:\n            return [2\n            /*return*/\n            , (_a.hash = _b.sent(), _a.forgedBytes = forgedBytes, _a.opResponse = opResponse, _a.context = this.context.clone(), _a)];\n        }\n      });\n    });\n  };\n\n  return OperationEmitter;\n}();\n/**\r\n * @description Utility class to interact with Tezos operations\r\n */\n\n\nvar Operation =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param hash Operation hash\r\n   * @param raw Raw operation that was injected\r\n   * @param context Taquito context allowing access to rpc and signer\r\n   */\n  function Operation(hash, raw, results, context) {\n    var _this = this;\n\n    this.hash = hash;\n    this.raw = raw;\n    this.results = results;\n    this.context = context;\n    this._pollingConfig$ = new ReplaySubject(1);\n    this._currentHeadPromise = undefined; // Caching the current head for one second\n\n    this.currentHead$ = defer(function () {\n      if (!_this._currentHeadPromise) {\n        _this._currentHeadPromise = _this.context.rpc.getBlock();\n        timer(1000).pipe(first()).subscribe(function () {\n          _this._currentHeadPromise = undefined;\n        });\n      }\n\n      return from(_this._currentHeadPromise);\n    }); // Polling observable that emit until timeout is reached\n\n    this.polling$ = defer(function () {\n      return _this._pollingConfig$.pipe(tap(function (_a) {\n        var timeout = _a.timeout,\n            interval = _a.interval;\n\n        if (timeout <= 0) {\n          throw new Error('Timeout must be more than 0');\n        }\n\n        if (interval <= 0) {\n          throw new Error('Interval must be more than 0');\n        }\n      }), map(function (config) {\n        return __assign(__assign({}, config), {\n          timeoutAt: Math.ceil(config.timeout / config.interval) + 1,\n          count: 0\n        });\n      }), switchMap(function (config) {\n        return timer(0, config.interval * 1000).pipe(mapTo(config));\n      }), tap(function (config) {\n        config.count++;\n\n        if (config.count > config.timeoutAt) {\n          throw new Error(\"Confirmation polling timed out\");\n        }\n      }));\n    }); // Observable that emit once operation is seen in a block\n\n    this.confirmed$ = this.polling$.pipe(switchMapTo(this.currentHead$), map(function (head) {\n      for (var i = 3; i >= 0; i--) {\n        head.operations[i].forEach(function (op) {\n          if (op.hash === _this.hash) {\n            _this._foundAt = head.header.level;\n          }\n        });\n      }\n\n      if (head.header.level - _this._foundAt >= 0) {\n        return _this._foundAt;\n      }\n    }), filter(function (x) {\n      return x !== undefined;\n    }), first(), shareReplay());\n    this._foundAt = Number.POSITIVE_INFINITY;\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  Object.defineProperty(Operation.prototype, \"includedInBlock\", {\n    get: function () {\n      return this._foundAt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Operation.prototype, \"revealOperation\", {\n    get: function () {\n      return Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'reveal';\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Operation.prototype, \"revealStatus\", {\n    get: function () {\n      if (this.revealOperation) {\n        return this.revealOperation.metadata.operation_result.status;\n      } else {\n        return 'unknown';\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Operation.prototype, \"status\", {\n    get: function () {\n      return this.results.map(function (result) {\n        if (hasMetadataWithResult(result)) {\n          return result.metadata.operation_result.status;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   *\r\n   * @param confirmations [0] Number of confirmation to wait for\r\n   * @param interval [10] Polling interval\r\n   * @param timeout [180] Timeout\r\n   */\n\n  Operation.prototype.confirmation = function (confirmations, interval, timeout) {\n    var _this = this;\n\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new Error('Confirmation count must be at least 1');\n    }\n\n    var _a = this.context.config,\n        defaultConfirmationCount = _a.defaultConfirmationCount,\n        confirmationPollingIntervalSecond = _a.confirmationPollingIntervalSecond,\n        confirmationPollingTimeoutSecond = _a.confirmationPollingTimeoutSecond;\n\n    this._pollingConfig$.next({\n      interval: interval || confirmationPollingIntervalSecond,\n      timeout: timeout || confirmationPollingTimeoutSecond\n    });\n\n    var conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n    return new Promise(function (resolve, reject) {\n      _this.confirmed$.pipe(switchMap(function () {\n        return _this.polling$;\n      }), switchMap(function () {\n        return _this.currentHead$;\n      }), filter(function (head) {\n        return head.header.level - _this._foundAt >= conf - 1;\n      }), first()).subscribe(function (_) {\n        resolve(_this._foundAt + (conf - 1));\n      }, reject);\n    });\n  };\n\n  return Operation;\n}();\n\nvar RpcTzProvider =\n/** @class */\nfunction (_super) {\n  __extends(RpcTzProvider, _super);\n\n  function RpcTzProvider(context) {\n    return _super.call(this, context) || this;\n  }\n\n  RpcTzProvider.prototype.getBalance = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.rpc.getBalance(address)];\n      });\n    });\n  };\n\n  RpcTzProvider.prototype.getDelegate = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.rpc.getDelegate(address)];\n      });\n    });\n  };\n\n  RpcTzProvider.prototype.activate = function (pkh, secret) {\n    return __awaiter(this, void 0, void 0, function () {\n      var operation, forgedBytes, bytes, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            operation = {\n              kind: OpKind.ACTIVATION,\n              pkh: pkh,\n              secret: secret\n            };\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: [operation],\n              source: pkh\n            })];\n\n          case 1:\n            forgedBytes = _b.sent();\n            bytes = forgedBytes.opbytes + \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n            _a = Operation.bind;\n            return [4\n            /*yield*/\n            , this.rpc.injectOperation(bytes)];\n\n          case 2:\n            return [2\n            /*return*/\n            , new (_a.apply(Operation, [void 0, _b.sent(), __assign(__assign({}, forgedBytes), {\n              opbytes: bytes\n            }), [], this.context.clone()]))()];\n        }\n      });\n    });\n  };\n\n  return RpcTzProvider;\n}(OperationEmitter);\n\nvar MINIMAL_FEE_MUTEZ = 100;\nvar MINIMAL_FEE_PER_BYTE_MUTEZ = 1;\nvar MINIMAL_FEE_PER_STORAGE_BYTE_MUTEZ = 1000;\nvar MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;\nvar GAS_BUFFER = 100;\n/**\r\n * Examples of use :\r\n *\r\n *  Estimate a transfer operation :\r\n * ```\r\n * // Assuming that provider and signer are already configured...\r\n *\r\n * const amount = 2;\r\n * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';\r\n *\r\n * // Estimate gasLimit, storageLimit and fees for a transfer operation\r\n * const est = await Tezos.estimate.transfer({ to: address, amount: amount })\r\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\r\n *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\r\n *\r\n * ```\r\n *\r\n * Estimate a contract origination :\r\n * ```\r\n * // generic.json is referring to a Michelson Smart Contract\r\n *\r\n * const genericMultisigJSON = require('./generic.json')\r\n * const est = await Tezos.estimate.originate({\r\n *   code: genericMultisigJSON,\r\n *   storage: {\r\n *     stored_counter: 0,\r\n *     threshold: 1,\r\n *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']\r\n *   }\r\n * })\r\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\r\n *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\r\n *\r\n * ```\r\n */\n\nvar Estimate =\n/** @class */\nfunction () {\n  function Estimate(_gasLimit, _storageLimit, opSize,\n  /**\r\n   * @description Base fee in mutez (1 mutez = 1e106 tez)\r\n   */\n  baseFeeMutez) {\n    if (baseFeeMutez === void 0) {\n      baseFeeMutez = MINIMAL_FEE_MUTEZ;\n    }\n\n    this._gasLimit = _gasLimit;\n    this._storageLimit = _storageLimit;\n    this.opSize = opSize;\n    this.baseFeeMutez = baseFeeMutez;\n  }\n\n  Object.defineProperty(Estimate.prototype, \"burnFeeMutez\", {\n    /**\r\n     * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations).\r\n     */\n    get: function () {\n      return this.roundUp(Number(this.storageLimit) * MINIMAL_FEE_PER_STORAGE_BYTE_MUTEZ);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"storageLimit\", {\n    /**\r\n     * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.\r\n     */\n    get: function () {\n      var limit = Math.max(Number(this._storageLimit), 0);\n      return limit > 0 ? limit : 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"gasLimit\", {\n    /**\r\n     * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.\r\n     */\n    get: function () {\n      return Number(this._gasLimit) + GAS_BUFFER;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"operationFeeMutez\", {\n    get: function () {\n      return this.gasLimit * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Estimate.prototype.roundUp = function (nanotez) {\n    return Math.ceil(Number(nanotez));\n  };\n\n  Object.defineProperty(Estimate.prototype, \"minimalFeeMutez\", {\n    /**\r\n     * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.\r\n     */\n    get: function () {\n      return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"suggestedFeeMutez\", {\n    /**\r\n     * @description The suggested fee for the operation which includes minimal fees and a small buffer.\r\n     */\n    get: function () {\n      return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"usingBaseFeeMutez\", {\n    /**\r\n     * @description Fees according to your specified base fee will ensure that at least minimum fees are used.\r\n     */\n    get: function () {\n      return Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"totalCost\", {\n    /**\r\n     * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.\r\n     */\n    get: function () {\n      return this.minimalFeeMutez + this.burnFeeMutez;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Estimate;\n}();\n\nvar TZ_DECIMALS = 6;\nvar MTZ_DECIMALS = 3;\n\nfunction getDecimal(format) {\n  switch (format) {\n    case 'tz':\n      return TZ_DECIMALS;\n\n    case 'mtz':\n      return MTZ_DECIMALS;\n\n    case 'mutez':\n    default:\n      return 0;\n  }\n}\n\nfunction format(from, to, amount) {\n  if (from === void 0) {\n    from = 'mutez';\n  }\n\n  if (to === void 0) {\n    to = 'mutez';\n  }\n\n  var bigNum = new BigNumber(amount);\n\n  if (bigNum.isNaN()) {\n    return amount;\n  }\n\n  return bigNum.multipliedBy(Math.pow(10, getDecimal(from))).dividedBy(Math.pow(10, getDecimal(to)));\n}\n\nvar createOriginationOperation = function (_a) {\n  var code = _a.code,\n      init = _a.init,\n      _b = _a.balance,\n      balance = _b === void 0 ? \"0\" : _b,\n      delegate = _a.delegate,\n      storage = _a.storage,\n      _c = _a.fee,\n      fee = _c === void 0 ? DEFAULT_FEE.ORIGINATION : _c,\n      _d = _a.gasLimit,\n      gasLimit = _d === void 0 ? DEFAULT_GAS_LIMIT.ORIGINATION : _d,\n      _e = _a.storageLimit,\n      storageLimit = _e === void 0 ? DEFAULT_STORAGE_LIMIT.ORIGINATION : _e;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var parser, contractCode, c, c, order_1, contractStorage, storageType, schema, c, script, operation;\n    return __generator(this, function (_f) {\n      // tslint:disable-next-line: strict-type-predicates\n      if (storage !== undefined && init !== undefined) {\n        throw new Error(\"Storage and Init cannot be set a the same time. Please either use storage or init but not both.\");\n      }\n\n      parser = new Parser({\n        expandMacros: true\n      });\n\n      if (typeof code === 'string') {\n        c = parser.parseScript(code);\n\n        if (c === null) {\n          throw new Error('Empty Michelson source');\n        }\n\n        contractCode = c;\n      } else {\n        c = parser.parseJSON(code);\n\n        if (!Array.isArray(c)) {\n          throw new Error('JSON encoded Michelson script must be an array');\n        }\n\n        order_1 = ['parameter', 'storage', 'code']; // Ensure correct ordering for RPC\n\n        contractCode = c.sort(function (a, b) {\n          return order_1.indexOf(a.prim) - order_1.indexOf(b.prim);\n        });\n      }\n\n      if (storage !== undefined) {\n        storageType = contractCode.find(function (p) {\n          return 'prim' in p && p.prim === 'storage';\n        });\n\n        if ((storageType === null || storageType === void 0 ? void 0 : storageType.args) === undefined) {\n          throw new Error('Missing storage section');\n        }\n\n        schema = new Schema(storageType.args[0]);\n        contractStorage = schema.Encode(storage);\n      } else if (typeof init === 'string') {\n        c = parser.parseMichelineExpression(init);\n\n        if (c === null) {\n          throw new Error('Empty initial storage value');\n        }\n\n        contractStorage = c;\n      } else if (typeof init === 'object') {\n        contractStorage = parser.parseJSON(init);\n      }\n\n      script = {\n        code: contractCode,\n        storage: contractStorage\n      };\n      operation = {\n        kind: OpKind.ORIGINATION,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        balance: format(\"tz\", \"mutez\", balance).toString(),\n        script: script\n      };\n\n      if (delegate) {\n        operation.delegate = delegate;\n      }\n\n      return [2\n      /*return*/\n      , operation];\n    });\n  });\n};\n\nvar createTransferOperation = function (_a) {\n  var to = _a.to,\n      amount = _a.amount,\n      parameter = _a.parameter,\n      _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.TRANSFER : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.TRANSFER : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.TRANSFER : _d,\n      _e = _a.mutez,\n      mutez = _e === void 0 ? false : _e;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var operation;\n    return __generator(this, function (_f) {\n      operation = {\n        kind: OpKind.TRANSACTION,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        amount: mutez ? amount.toString() : format(\"tz\", \"mutez\", amount).toString(),\n        destination: to,\n        parameters: parameter\n      };\n      return [2\n      /*return*/\n      , operation];\n    });\n  });\n};\n\nvar createSetDelegateOperation = function (_a) {\n  var delegate = _a.delegate,\n      source = _a.source,\n      _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.DELEGATION : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.DELEGATION : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.DELEGATION : _d;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var operation;\n    return __generator(this, function (_e) {\n      operation = {\n        kind: OpKind.DELEGATION,\n        source: source,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        delegate: delegate\n      };\n      return [2\n      /*return*/\n      , operation];\n    });\n  });\n};\n\nvar createRegisterDelegateOperation = function (_a, source) {\n  var _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.DELEGATION : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.DELEGATION : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.DELEGATION : _d;\n  return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_e) {\n      return [2\n      /*return*/\n      , {\n        kind: OpKind.DELEGATION,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        delegate: source\n      }];\n    });\n  });\n};\n\nvar mergeLimits = function (userDefinedLimit, defaultLimits) {\n  return {\n    fee: typeof userDefinedLimit.fee === 'undefined' ? defaultLimits.fee : userDefinedLimit.fee,\n    gasLimit: typeof userDefinedLimit.gasLimit === 'undefined' ? defaultLimits.gasLimit : userDefinedLimit.gasLimit,\n    storageLimit: typeof userDefinedLimit.storageLimit === 'undefined' ? defaultLimits.storageLimit : userDefinedLimit.storageLimit\n  };\n}; // RPC requires a signature but does not verify it\n\n\nvar SIGNATURE_STUB = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';\n\nvar RPCEstimateProvider =\n/** @class */\nfunction (_super) {\n  __extends(RPCEstimateProvider, _super);\n\n  function RPCEstimateProvider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.ALLOCATION_STORAGE = 257;\n    _this.ORIGINATION_STORAGE = 257;\n    return _this;\n  } // Maximum values defined by the protocol\n\n\n  RPCEstimateProvider.prototype.getAccountLimits = function (pkh) {\n    return __awaiter(this, void 0, void 0, function () {\n      var balance, _a, hard_gas_limit_per_operation, hard_storage_limit_per_operation, cost_per_byte;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.rpc.getBalance(pkh)];\n\n          case 1:\n            balance = _b.sent();\n            return [4\n            /*yield*/\n            , this.rpc.getConstants()];\n\n          case 2:\n            _a = _b.sent(), hard_gas_limit_per_operation = _a.hard_gas_limit_per_operation, hard_storage_limit_per_operation = _a.hard_storage_limit_per_operation, cost_per_byte = _a.cost_per_byte;\n            return [2\n            /*return*/\n            , {\n              fee: 0,\n              gasLimit: hard_gas_limit_per_operation.toNumber(),\n              storageLimit: Math.floor(BigNumber.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber())\n            }];\n        }\n      });\n    });\n  };\n\n  RPCEstimateProvider.prototype.createEstimateFromOperationContent = function (content, size) {\n    var _this = this;\n\n    var operationResults = flattenOperationResult({\n      contents: [content]\n    });\n    var totalGas = 0;\n    var totalStorage = 0;\n    operationResults.forEach(function (result) {\n      totalStorage += 'originated_contracts' in result && typeof result.originated_contracts !== 'undefined' ? result.originated_contracts.length * _this.ORIGINATION_STORAGE : 0;\n      totalStorage += 'allocated_destination_contract' in result ? _this.ALLOCATION_STORAGE : 0;\n      totalGas += Number(result.consumed_gas) || 0;\n      totalStorage += 'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;\n    });\n\n    if (isOpWithFee(content)) {\n      return new Estimate(totalGas || 0, Number(totalStorage || 0), size);\n    } else {\n      return new Estimate(0, 0, size, 0);\n    }\n  };\n\n  RPCEstimateProvider.prototype.createEstimate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, opbytes, _b, branch, contents, operation, _c, opResponse, errors;\n\n      var _this = this;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.prepareAndForge(params)];\n\n          case 1:\n            _a = _d.sent(), opbytes = _a.opbytes, _b = _a.opOb, branch = _b.branch, contents = _b.contents;\n            _c = {\n              operation: {\n                branch: branch,\n                contents: contents,\n                signature: SIGNATURE_STUB\n              }\n            };\n            return [4\n            /*yield*/\n            , this.rpc.getChainId()];\n\n          case 2:\n            operation = (_c.chain_id = _d.sent(), _c);\n            return [4\n            /*yield*/\n            , this.simulate(operation)];\n\n          case 3:\n            opResponse = _d.sent().opResponse;\n            errors = __spread(flattenErrors(opResponse, 'backtracked'), flattenErrors(opResponse)); // Fail early in case of errors\n\n            if (errors.length) {\n              throw new TezosOperationError(errors);\n            }\n\n            while (opResponse.contents.length !== (Array.isArray(params.operation) ? params.operation.length : 1)) {\n              opResponse.contents.shift();\n            }\n\n            return [2\n            /*return*/\n            , opResponse.contents.map(function (x) {\n              return _this.createEstimateFromOperationContent(x, opbytes.length / 2 / opResponse.contents.length);\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param OriginationOperation Originate operation parameter\r\n   */\n\n\n  RPCEstimateProvider.prototype.originate = function (_a) {\n    var fee = _a.fee,\n        storageLimit = _a.storageLimit,\n        gasLimit = _a.gasLimit,\n        rest = __rest(_a, [\"fee\", \"storageLimit\", \"gasLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, DEFAULT_PARAMS, op;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _b.sent();\n            return [4\n            /*yield*/\n            , this.getAccountLimits(pkh)];\n\n          case 2:\n            DEFAULT_PARAMS = _b.sent();\n            return [4\n            /*yield*/\n            , createOriginationOperation(__assign(__assign({}, rest), mergeLimits({\n              fee: fee,\n              storageLimit: storageLimit,\n              gasLimit: gasLimit\n            }, DEFAULT_PARAMS)))];\n\n          case 3:\n            op = _b.sent();\n            return [4\n            /*yield*/\n            , this.createEstimate({\n              operation: op,\n              source: pkh\n            })];\n\n          case 4:\n            return [2\n            /*return*/\n            , _b.sent()[0]];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param TransferOperation Originate operation parameter\r\n   */\n\n\n  RPCEstimateProvider.prototype.transfer = function (_a) {\n    var fee = _a.fee,\n        storageLimit = _a.storageLimit,\n        gasLimit = _a.gasLimit,\n        rest = __rest(_a, [\"fee\", \"storageLimit\", \"gasLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, DEFAULT_PARAMS, op;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _b.sent();\n            return [4\n            /*yield*/\n            , this.getAccountLimits(pkh)];\n\n          case 2:\n            DEFAULT_PARAMS = _b.sent();\n            return [4\n            /*yield*/\n            , createTransferOperation(__assign(__assign({}, rest), mergeLimits({\n              fee: fee,\n              storageLimit: storageLimit,\n              gasLimit: gasLimit\n            }, DEFAULT_PARAMS)))];\n\n          case 3:\n            op = _b.sent();\n            return [4\n            /*yield*/\n            , this.createEstimate({\n              operation: op,\n              source: pkh\n            })];\n\n          case 4:\n            return [2\n            /*return*/\n            , _b.sent()[0]];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  RPCEstimateProvider.prototype.setDelegate = function (_a) {\n    var fee = _a.fee,\n        gasLimit = _a.gasLimit,\n        storageLimit = _a.storageLimit,\n        rest = __rest(_a, [\"fee\", \"gasLimit\", \"storageLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var sourceOrDefault, _b, DEFAULT_PARAMS, op;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _b = rest.source;\n            if (_b) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            _b = _c.sent();\n            _c.label = 2;\n\n          case 2:\n            sourceOrDefault = _b;\n            return [4\n            /*yield*/\n            , this.getAccountLimits(sourceOrDefault)];\n\n          case 3:\n            DEFAULT_PARAMS = _c.sent();\n            return [4\n            /*yield*/\n            , createSetDelegateOperation(__assign(__assign({}, rest), mergeLimits({\n              fee: fee,\n              storageLimit: storageLimit,\n              gasLimit: gasLimit\n            }, DEFAULT_PARAMS)))];\n\n          case 4:\n            op = _c.sent();\n            return [4\n            /*yield*/\n            , this.createEstimate({\n              operation: op,\n              source: sourceOrDefault\n            })];\n\n          case 5:\n            return [2\n            /*return*/\n            , _c.sent()[0]];\n        }\n      });\n    });\n  };\n\n  RPCEstimateProvider.prototype.batch = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var operations, DEFAULT_PARAMS, _a, params_1, params_1_1, param, _b, _c, _d, _e, _f, _g, _h, e_1_1;\n\n      var e_1, _j;\n\n      return __generator(this, function (_k) {\n        switch (_k.label) {\n          case 0:\n            operations = [];\n            _a = this.getAccountLimits;\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            return [4\n            /*yield*/\n            , _a.apply(this, [_k.sent()])];\n\n          case 2:\n            DEFAULT_PARAMS = _k.sent();\n            _k.label = 3;\n\n          case 3:\n            _k.trys.push([3, 15, 16, 17]);\n\n            params_1 = __values(params), params_1_1 = params_1.next();\n            _k.label = 4;\n\n          case 4:\n            if (!!params_1_1.done) return [3\n            /*break*/\n            , 14];\n            param = params_1_1.value;\n            _b = param.kind;\n\n            switch (_b) {\n              case OpKind.TRANSACTION:\n                return [3\n                /*break*/\n                , 5];\n\n              case OpKind.ORIGINATION:\n                return [3\n                /*break*/\n                , 7];\n\n              case OpKind.DELEGATION:\n                return [3\n                /*break*/\n                , 9];\n\n              case OpKind.ACTIVATION:\n                return [3\n                /*break*/\n                , 11];\n            }\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 5:\n            _d = (_c = operations).push;\n            return [4\n            /*yield*/\n            , createTransferOperation(__assign(__assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))];\n\n          case 6:\n            _d.apply(_c, [_k.sent()]);\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 7:\n            _f = (_e = operations).push;\n            return [4\n            /*yield*/\n            , createOriginationOperation(__assign(__assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))];\n\n          case 8:\n            _f.apply(_e, [_k.sent()]);\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 9:\n            _h = (_g = operations).push;\n            return [4\n            /*yield*/\n            , createSetDelegateOperation(__assign(__assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))];\n\n          case 10:\n            _h.apply(_g, [_k.sent()]);\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 11:\n            operations.push(__assign(__assign({}, param), DEFAULT_PARAMS));\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n\n          case 13:\n            params_1_1 = params_1.next();\n            return [3\n            /*break*/\n            , 4];\n\n          case 14:\n            return [3\n            /*break*/\n            , 17];\n\n          case 15:\n            e_1_1 = _k.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 17];\n\n          case 16:\n            try {\n              if (params_1_1 && !params_1_1.done && (_j = params_1.return)) _j.call(params_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 17:\n            return [2\n            /*return*/\n            , this.createEstimate({\n              operation: operations\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  RPCEstimateProvider.prototype.registerDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var DEFAULT_PARAMS, _a, op, _b, _c, _d, _e;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            _a = this.getAccountLimits;\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            return [4\n            /*yield*/\n            , _a.apply(this, [_f.sent()])];\n\n          case 2:\n            DEFAULT_PARAMS = _f.sent();\n            _b = createRegisterDelegateOperation;\n            _c = [__assign(__assign({}, params), DEFAULT_PARAMS)];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 3:\n            return [4\n            /*yield*/\n            , _b.apply(void 0, _c.concat([_f.sent()]))];\n\n          case 4:\n            op = _f.sent();\n            _d = this.createEstimate;\n            _e = {\n              operation: op\n            };\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 5:\n            return [4\n            /*yield*/\n            , _d.apply(this, [(_e.source = _f.sent(), _e)])];\n\n          case 6:\n            return [2\n            /*return*/\n            , _f.sent()[0]];\n        }\n      });\n    });\n  };\n\n  return RPCEstimateProvider;\n}(OperationEmitter);\n/**\r\n * @description Delegation operation provide utility function to fetch newly issued delegation\r\n *\r\n * @warn Currently support only one delegation per operation\r\n */\n\n\nvar DelegateOperation =\n/** @class */\nfunction (_super) {\n  __extends(DelegateOperation, _super);\n\n  function DelegateOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  Object.defineProperty(DelegateOperation.prototype, \"operationResults\", {\n    get: function () {\n      var delegationOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'delegation';\n      });\n      var result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;\n      return result ? result : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"status\", {\n    get: function () {\n      var operationResults = this.operationResults;\n\n      if (operationResults) {\n        return operationResults.status;\n      } else {\n        return 'unknown';\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"delegate\", {\n    get: function () {\n      return this.delegate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"isRegisterOperation\", {\n    get: function () {\n      return this.delegate === this.source;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"consumedGas\", {\n    get: function () {\n      var consumedGas = this.operationResults && this.operationResults.consumed_gas;\n      return consumedGas ? consumedGas : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"errors\", {\n    get: function () {\n      return this.operationResults && this.operationResults.errors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return DelegateOperation;\n}(Operation);\n/**\r\n * @description Origination operation provide utility function to fetch newly originated contract\r\n *\r\n * @warn Currently support only one origination per operation\r\n */\n\n\nvar OriginationOperation =\n/** @class */\nfunction (_super) {\n  __extends(OriginationOperation, _super);\n\n  function OriginationOperation(hash, params, raw, results, context, contractProvider) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.contractProvider = contractProvider;\n    var originatedContracts = _this.operationResults && _this.operationResults.originated_contracts;\n\n    if (Array.isArray(originatedContracts)) {\n      _this.contractAddress = originatedContracts[0];\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(OriginationOperation.prototype, \"status\", {\n    get: function () {\n      var operationResults = this.operationResults;\n\n      if (operationResults) {\n        return operationResults.status;\n      } else {\n        return 'unknown';\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"operationResults\", {\n    get: function () {\n      var originationOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'origination';\n      });\n      var result = originationOp && hasMetadataWithResult(originationOp) && originationOp.metadata.operation_result;\n      return result ? result : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"consumedGas\", {\n    get: function () {\n      var consumedGas = this.operationResults && this.operationResults.consumed_gas;\n      return consumedGas ? consumedGas : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"storageDiff\", {\n    get: function () {\n      var storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;\n      return storageDiff ? storageDiff : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"storageSize\", {\n    get: function () {\n      var storageSize = this.operationResults && this.operationResults.storage_size;\n      return storageSize ? storageSize : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"errors\", {\n    get: function () {\n      return this.operationResults && this.operationResults.errors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @description Provide the contract abstract of the newly originated contract\r\n   */\n\n  OriginationOperation.prototype.contract = function (confirmations, interval, timeout) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.contractAddress) {\n              throw new Error('No contract was originated in this operation');\n            }\n\n            return [4\n            /*yield*/\n            , this.confirmation(confirmations, interval, timeout)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.contractProvider.at(this.contractAddress)];\n        }\n      });\n    });\n  };\n\n  return OriginationOperation;\n}(Operation);\n/**\r\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\r\n *\r\n * @warn Currently supports one transaction per operation\r\n */\n\n\nvar TransactionOperation =\n/** @class */\nfunction (_super) {\n  __extends(TransactionOperation, _super);\n\n  function TransactionOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  Object.defineProperty(TransactionOperation.prototype, \"operationResults\", {\n    get: function () {\n      var transactionOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'transaction';\n      });\n      return transactionOp ? [transactionOp] : [];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"status\", {\n    get: function () {\n      var operationResults = this.operationResults;\n      var txResult = operationResults[0];\n\n      if (txResult) {\n        return txResult.metadata.operation_result.status;\n      } else {\n        return 'unknown';\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"amount\", {\n    get: function () {\n      return new BigNumber(this.params.amount);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"destination\", {\n    get: function () {\n      return this.params.destination;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TransactionOperation.prototype.sumProp = function (arr, prop) {\n    return arr.reduce(function (prev, current) {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  };\n\n  Object.defineProperty(TransactionOperation.prototype, \"consumedGas\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'consumed_gas'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"storageDiff\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'paid_storage_size_diff'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"storageSize\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'storage_size'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"errors\", {\n    get: function () {\n      return flattenErrors({\n        contents: this.operationResults\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return TransactionOperation;\n}(Operation);\n\nvar InvalidParameterError =\n/** @class */\nfunction () {\n  function InvalidParameterError(smartContractMethodName, sigs, args) {\n    this.smartContractMethodName = smartContractMethodName;\n    this.sigs = sigs;\n    this.args = args;\n    this.name = 'Invalid parameters error';\n    this.message = smartContractMethodName + \" Received \" + args.length + \" arguments while expecting one of the following signatures (\" + JSON.stringify(sigs) + \")\";\n  }\n\n  return InvalidParameterError;\n}();\n\nvar InvalidDelegationSource =\n/** @class */\nfunction () {\n  function InvalidDelegationSource(source) {\n    this.source = source;\n    this.name = 'Invalid delegation source error';\n    this.message = \"Since Babylon delegation source can no longer be a contract address \" + source + \". Please use the smart contract abstraction to set your delegate.\";\n  }\n\n  return InvalidDelegationSource;\n}();\n\nvar setDelegate = function (key) {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'key_hash'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'SOME'\n  }, {\n    prim: 'SET_DELEGATE'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar transferImplicit = function (key, mutez) {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'key_hash'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'IMPLICIT_ACCOUNT'\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'mutez'\n    }, {\n      int: \"\" + mutez\n    }]\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'TRANSFER_TOKENS'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar removeDelegate = function () {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'NONE',\n    args: [{\n      prim: 'key_hash'\n    }]\n  }, {\n    prim: 'SET_DELEGATE'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar transferToContract = function (key, amount) {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'address'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'CONTRACT',\n    args: [{\n      prim: 'unit'\n    }]\n  }, [{\n    prim: 'IF_NONE',\n    args: [[[{\n      prim: 'UNIT'\n    }, {\n      prim: 'FAILWITH'\n    }]], []]\n  }], {\n    prim: 'PUSH',\n    args: [{\n      prim: 'mutez'\n    }, {\n      int: \"\" + amount\n    }]\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'TRANSFER_TOKENS'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar MANAGER_LAMBDA = {\n  setDelegate: setDelegate,\n  removeDelegate: removeDelegate,\n  transferImplicit: transferImplicit,\n  transferToContract: transferToContract\n};\n\nvar WalletOperationBatch =\n/** @class */\nfunction () {\n  function WalletOperationBatch(walletProvider, operationFactory) {\n    this.walletProvider = walletProvider;\n    this.operationFactory = operationFactory;\n    this.operations = [];\n  }\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.withTransfer = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.TRANSACTION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.withContractCall = function (params) {\n    return this.withTransfer(params.toTransferParams());\n  };\n  /**\r\n   *\r\n   * @description Add a delegation operation to the batch\r\n   *\r\n   * @param params Delegation operation parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.withDelegation = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.DELEGATION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add an origination operation to the batch\r\n   *\r\n   * @param params Origination operation parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.withOrigination = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.ORIGINATION\n    }, params));\n    return this;\n  };\n\n  WalletOperationBatch.prototype.mapOperation = function (param) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (param.kind) {\n          case OpKind.TRANSACTION:\n            return [2\n            /*return*/\n            , this.walletProvider.mapTransferParamsToWalletParams(__assign({}, param))];\n\n          case OpKind.ORIGINATION:\n            return [2\n            /*return*/\n            , this.walletProvider.mapOriginateParamsToWalletParams(__assign({}, param))];\n\n          case OpKind.DELEGATION:\n            return [2\n            /*return*/\n            , this.walletProvider.mapDelegateParamsToWalletParams(__assign({}, param))];\n\n          default:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\r\n   *\r\n   * @param params Operations parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.with = function (params) {\n    var e_1, _a;\n\n    try {\n      for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {\n        var param = params_1_1.value;\n\n        switch (param.kind) {\n          case OpKind.TRANSACTION:\n            this.withTransfer(param);\n            break;\n\n          case OpKind.ORIGINATION:\n            this.withOrigination(param);\n            break;\n\n          case OpKind.DELEGATION:\n            this.withDelegation(param);\n            break;\n\n          default:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Submit batch operation to wallet\r\n   *\r\n   */\n\n\n  WalletOperationBatch.prototype.send = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ops, _a, _b, op, _c, _d, e_2_1, opHash;\n\n      var e_2, _e;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            ops = [];\n            _f.label = 1;\n\n          case 1:\n            _f.trys.push([1, 6, 7, 8]);\n\n            _a = __values(this.operations), _b = _a.next();\n            _f.label = 2;\n\n          case 2:\n            if (!!_b.done) return [3\n            /*break*/\n            , 5];\n            op = _b.value;\n            _d = (_c = ops).push;\n            return [4\n            /*yield*/\n            , this.mapOperation(op)];\n\n          case 3:\n            _d.apply(_c, [_f.sent()]);\n\n            _f.label = 4;\n\n          case 4:\n            _b = _a.next();\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            e_2_1 = _f.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            try {\n              if (_b && !_b.done && (_e = _a.return)) _e.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [4\n            /*yield*/\n            , this.walletProvider.sendOperations(ops)];\n\n          case 9:\n            opHash = _f.sent();\n            return [2\n            /*return*/\n            , this.operationFactory.createOperation(opHash)];\n        }\n      });\n    });\n  };\n\n  return WalletOperationBatch;\n}();\n\nvar Wallet =\n/** @class */\nfunction () {\n  function Wallet(context) {\n    this.context = context;\n\n    this.walletCommand = function (send) {\n      return {\n        send: send\n      };\n    };\n  }\n\n  Object.defineProperty(Wallet.prototype, \"walletProvider\", {\n    get: function () {\n      return this.context.walletProvider;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @description Retrieve the PKH of the account that is currently in use by the wallet\r\n   *\r\n   * @param option Option to use while fetching the PKH.\r\n   * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet\r\n   */\n\n  Wallet.prototype.pkh = function (_a) {\n    var forceRefetch = (_a === void 0 ? {} : _a).forceRefetch;\n    return __awaiter(this, void 0, void 0, function () {\n      var _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(!this._pkh || forceRefetch)) return [3\n            /*break*/\n            , 2];\n            _b = this;\n            return [4\n            /*yield*/\n            , this.walletProvider.getPKH()];\n\n          case 1:\n            _b._pkh = _c.sent();\n            _c.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , this._pkh];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Originate a new contract according to the script in parameters.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param originateParams Originate operation parameter\r\n   */\n\n\n  Wallet.prototype.originate = function (params) {\n    var _this = this;\n\n    return this.walletCommand(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var mappedParams, opHash;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.walletProvider.mapOriginateParamsToWalletParams(__assign({}, params))];\n\n            case 1:\n              mappedParams = _a.sent();\n              return [4\n              /*yield*/\n              , this.walletProvider.sendOperations([mappedParams])];\n\n            case 2:\n              opHash = _a.sent();\n              return [2\n              /*return*/\n              , this.context.operationFactory.createOriginationOperation(opHash)];\n          }\n        });\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Set the delegate for a contract.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param delegateParams operation parameter\r\n   */\n\n\n  Wallet.prototype.setDelegate = function (params) {\n    var _this = this;\n\n    return this.walletCommand(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var mappedParams, opHash;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.walletProvider.mapDelegateParamsToWalletParams(__assign({}, params))];\n\n            case 1:\n              mappedParams = _a.sent();\n              return [4\n              /*yield*/\n              , this.walletProvider.sendOperations([mappedParams])];\n\n            case 2:\n              opHash = _a.sent();\n              return [2\n              /*return*/\n              , this.context.operationFactory.createDelegationOperation(opHash)];\n          }\n        });\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Register the current address as delegate.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   */\n\n\n  Wallet.prototype.registerDelegate = function () {\n    var _this = this;\n\n    return this.walletCommand(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var mappedParams, _a, _b, _c, opHash;\n\n        return __generator(this, function (_d) {\n          switch (_d.label) {\n            case 0:\n              _b = (_a = this.walletProvider).mapDelegateParamsToWalletParams;\n              _c = {};\n              return [4\n              /*yield*/\n              , this.pkh()];\n\n            case 1:\n              return [4\n              /*yield*/\n              , _b.apply(_a, [(_c.delegate = _d.sent(), _c)])];\n\n            case 2:\n              mappedParams = _d.sent();\n              return [4\n              /*yield*/\n              , this.walletProvider.sendOperations([mappedParams])];\n\n            case 3:\n              opHash = _d.sent();\n              return [2\n              /*return*/\n              , this.context.operationFactory.createDelegationOperation(opHash)];\n          }\n        });\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Transfer tezos tokens from current address to a specific address or call a smart contract.\r\n   *\r\n   * @returns A wallet command from which we can send the operation to the wallet\r\n   *\r\n   * @param params operation parameter\r\n   */\n\n\n  Wallet.prototype.transfer = function (params) {\n    var _this = this;\n\n    return this.walletCommand(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var mappedParams, opHash;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.walletProvider.mapTransferParamsToWalletParams(params)];\n\n            case 1:\n              mappedParams = _a.sent();\n              return [4\n              /*yield*/\n              , this.walletProvider.sendOperations([mappedParams])];\n\n            case 2:\n              opHash = _a.sent();\n              return [2\n              /*return*/\n              , this.context.operationFactory.createTransactionOperation(opHash)];\n          }\n        });\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Create a batch of operation\r\n   *\r\n   * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch\r\n   *\r\n   * @param params List of operation to initialize the batch with\r\n   */\n\n\n  Wallet.prototype.batch = function (params) {\n    var batch = new WalletOperationBatch(this.walletProvider, this.context.operationFactory);\n    batch.with(params);\n    return batch;\n  };\n  /**\r\n   *\r\n   * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned\r\n   * smart contract abstraction will leverage the wallet provider to make smart contract calls\r\n   *\r\n   * @param address Smart contract address\r\n   */\n\n\n  Wallet.prototype.at = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var script, entrypoints;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.context.rpc.getScript(address)];\n\n          case 1:\n            script = _a.sent();\n            return [4\n            /*yield*/\n            , this.context.rpc.getEntrypoints(address)];\n\n          case 2:\n            entrypoints = _a.sent();\n            return [2\n            /*return*/\n            , new ContractAbstraction(address, script, this, this.context.contract, entrypoints)];\n        }\n      });\n    });\n  };\n\n  return Wallet;\n}();\n\nvar LegacyWalletProvider =\n/** @class */\nfunction () {\n  function LegacyWalletProvider(context) {\n    this.context = context;\n  }\n\n  LegacyWalletProvider.prototype.getPKH = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.context.signer.publicKeyHash()];\n      });\n    });\n  };\n\n  LegacyWalletProvider.prototype.mapTransferParamsToWalletParams = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , attachKind(params, OpKind.TRANSACTION)];\n      });\n    });\n  };\n\n  LegacyWalletProvider.prototype.mapOriginateParamsToWalletParams = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , attachKind(params, OpKind.ORIGINATION)];\n      });\n    });\n  };\n\n  LegacyWalletProvider.prototype.mapDelegateParamsToWalletParams = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , attachKind(params, OpKind.DELEGATION)];\n      });\n    });\n  };\n\n  LegacyWalletProvider.prototype.sendOperations = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var op;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.context.batch.batch(params).send()];\n\n          case 1:\n            op = _a.sent();\n            return [2\n            /*return*/\n            , op.hash];\n        }\n      });\n    });\n  };\n\n  return LegacyWalletProvider;\n}();\n\nvar DEFAULT_SMART_CONTRACT_METHOD_NAME = 'main';\n/**\r\n * @description Utility class to send smart contract operation\r\n */\n\nvar ContractMethod =\n/** @class */\nfunction () {\n  function ContractMethod(provider, address, parameterSchema, name, args, isMultipleEntrypoint, isAnonymous) {\n    if (isMultipleEntrypoint === void 0) {\n      isMultipleEntrypoint = true;\n    }\n\n    if (isAnonymous === void 0) {\n      isAnonymous = false;\n    }\n\n    this.provider = provider;\n    this.address = address;\n    this.parameterSchema = parameterSchema;\n    this.name = name;\n    this.args = args;\n    this.isMultipleEntrypoint = isMultipleEntrypoint;\n    this.isAnonymous = isAnonymous;\n  }\n\n  Object.defineProperty(ContractMethod.prototype, \"schema\", {\n    /**\r\n     * @description Get the schema of the smart contract method\r\n     */\n    get: function () {\n      return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   *\r\n   * @description Send the smart contract operation\r\n   *\r\n   * @param Options generic operation parameter\r\n   */\n\n  ContractMethod.prototype.send = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    if (this.provider instanceof Wallet) {\n      // TODO got around TS2352: Conversion of type 'T & Wallet' to type 'Wallet' by adding `as unknown`. Needs clarification\n      return this.provider.transfer(this.toTransferParams(params)).send();\n    } else {\n      return this.provider.transfer(this.toTransferParams(params));\n    }\n  };\n  /**\r\n   *\r\n   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\r\n   *\r\n   * @param Options generic transfer operation parameters\r\n   */\n\n\n  ContractMethod.prototype.toTransferParams = function (_a) {\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        fee = _d.fee,\n        gasLimit = _d.gasLimit,\n        storageLimit = _d.storageLimit,\n        source = _d.source,\n        _e = _d.amount,\n        amount = _e === void 0 ? 0 : _e,\n        _f = _d.mutez,\n        mutez = _f === void 0 ? false : _f;\n\n    var fullTransferParams = {\n      to: this.address,\n      amount: amount,\n      fee: fee,\n      mutez: mutez,\n      source: source,\n      gasLimit: gasLimit,\n      storageLimit: storageLimit,\n      parameter: {\n        entrypoint: this.isMultipleEntrypoint ? this.name : 'default',\n        value: this.isAnonymous ? (_b = this.parameterSchema).Encode.apply(_b, __spread([this.name], this.args)) : (_c = this.parameterSchema).Encode.apply(_c, __spread(this.args))\n      }\n    };\n    return fullTransferParams;\n  };\n\n  return ContractMethod;\n}();\n\nvar validateArgs = function (args, schema, name) {\n  var sigs = schema.ExtractSignatures();\n\n  if (!sigs.find(function (x) {\n    return x.length === args.length;\n  })) {\n    throw new InvalidParameterError(name, sigs, args);\n  }\n};\n/**\r\n * @description Smart contract abstraction\r\n */\n\n\nvar ContractAbstraction =\n/** @class */\nfunction () {\n  function ContractAbstraction(address, script, provider, storageProvider, entrypoints) {\n    this.address = address;\n    this.script = script;\n    this.storageProvider = storageProvider;\n    this.entrypoints = entrypoints;\n    /**\r\n     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\r\n     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\r\n     *\r\n     */\n\n    this.methods = {};\n    this.schema = Schema.fromRPCResponse({\n      script: this.script\n    });\n    this.parameterSchema = ParameterSchema.fromRPCResponse({\n      script: this.script\n    });\n\n    this._initializeMethods(address, provider, this.entrypoints.entrypoints);\n  }\n\n  ContractAbstraction.prototype._initializeMethods = function (address, provider, entrypoints) {\n    var _this = this;\n\n    var parameterSchema = this.parameterSchema;\n    var keys = Object.keys(entrypoints);\n\n    if (parameterSchema.isMultipleEntryPoint) {\n      keys.forEach(function (smartContractMethodName) {\n        var method = function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          var smartContractMethodSchema = new ParameterSchema(entrypoints[smartContractMethodName]);\n          validateArgs(args, smartContractMethodSchema, smartContractMethodName);\n          return new ContractMethod(provider, address, smartContractMethodSchema, smartContractMethodName, args);\n        };\n\n        _this.methods[smartContractMethodName] = method;\n      }); // Deal with methods with no annotations which were not discovered by the RPC endpoint\n      // Methods with no annotations are discovered using parameter schema\n\n      var anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter(function (key) {\n        return Object.keys(entrypoints).indexOf(key) === -1;\n      });\n      anonymousMethods.forEach(function (smartContractMethodName) {\n        var method = function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          validateArgs(__spread([smartContractMethodName], args), parameterSchema, smartContractMethodName);\n          return new ContractMethod(provider, address, parameterSchema, smartContractMethodName, args, false, true);\n        };\n\n        _this.methods[smartContractMethodName] = method;\n      });\n    } else {\n      var smartContractMethodSchema_1 = this.parameterSchema;\n\n      var method = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        validateArgs(args, parameterSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME);\n        return new ContractMethod(provider, address, smartContractMethodSchema_1, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);\n      };\n\n      this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = method;\n    }\n  };\n  /**\r\n   * @description Return a friendly representation of the smart contract storage\r\n   */\n\n\n  ContractAbstraction.prototype.storage = function () {\n    return this.storageProvider.getStorage(this.address, this.schema);\n  };\n  /**\r\n   *\r\n   * @description Return a friendly representation of the smart contract big map value\r\n   *\r\n   * @param key BigMap key to fetch\r\n   *\r\n   * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n   */\n\n\n  ContractAbstraction.prototype.bigMap = function (key) {\n    // tslint:disable-next-line: deprecation\n    return this.storageProvider.getBigMapKey(this.address, key, this.schema);\n  };\n\n  return ContractAbstraction;\n}();\n\nvar BigMapAbstraction =\n/** @class */\nfunction () {\n  function BigMapAbstraction(id, schema, provider) {\n    this.id = id;\n    this.schema = schema;\n    this.provider = provider;\n  }\n\n  BigMapAbstraction.prototype.get = function (keyToEncode) {\n    return __awaiter(this, void 0, void 0, function () {\n      var id, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema)];\n\n          case 1:\n            id = _a.sent();\n            return [2\n            /*return*/\n            , id];\n\n          case 2:\n            e_1 = _a.sent();\n\n            if (e_1 instanceof HttpResponseError && e_1.status === STATUS_CODE.NOT_FOUND) {\n              return [2\n              /*return*/\n              , undefined];\n            } else {\n              throw e_1;\n            }\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  BigMapAbstraction.prototype.toJSON = function () {\n    return this.id.toString();\n  };\n\n  BigMapAbstraction.prototype.toString = function () {\n    return this.id.toString();\n  };\n\n  return BigMapAbstraction;\n}(); // Override the default michelson encoder semantic to provide richer abstraction over storage properties\n\n\nvar smartContractAbstractionSemantic = function (provider) {\n  return {\n    // Provide a specific abstraction for BigMaps\n    big_map: function (val, code) {\n      if (!val || !('int' in val) || val.int === undefined) {\n        // Return an empty object in case of missing big map ID\n        return {};\n      } else {\n        var schema = new Schema(code);\n        return new BigMapAbstraction(new BigNumber(val.int), schema, provider);\n      }\n    }\n  };\n};\n\nvar RpcContractProvider =\n/** @class */\nfunction (_super) {\n  __extends(RpcContractProvider, _super);\n\n  function RpcContractProvider(context, estimator) {\n    var _this = _super.call(this, context) || this;\n\n    _this.estimator = estimator;\n    return _this;\n  }\n  /**\r\n   *\r\n   * @description Return a well formatted json object of the contract storage\r\n   *\r\n   * @param contract contract address you want to get the storage from\r\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n   */\n\n\n  RpcContractProvider.prototype.getStorage = function (contract, schema) {\n    return __awaiter(this, void 0, void 0, function () {\n      var contractSchema, storage;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!schema) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.rpc.getScript(contract)];\n\n          case 1:\n            schema = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            if (Schema.isSchema(schema)) {\n              contractSchema = schema;\n            } else {\n              contractSchema = Schema.fromRPCResponse({\n                script: schema\n              });\n            }\n\n            return [4\n            /*yield*/\n            , this.rpc.getStorage(contract)];\n\n          case 3:\n            storage = _a.sent();\n            return [2\n            /*return*/\n            , contractSchema.Execute(storage, smartContractAbstractionSemantic(this))];\n          // Cast into T because only the caller can know the true type of the storage\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Return a well formatted json object of the contract big map storage\r\n   *\r\n   * @param contract contract address you want to get the storage from\r\n   * @param key contract big map key to fetch value from\r\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n   *\r\n   * @deprecated Deprecated in favor of getBigMapKeyByID\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n   */\n\n\n  RpcContractProvider.prototype.getBigMapKey = function (contract, key, schema) {\n    return __awaiter(this, void 0, void 0, function () {\n      var contractSchema, encodedKey, val;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!schema) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.rpc.getScript(contract)];\n\n          case 1:\n            schema = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            if (Schema.isSchema(schema)) {\n              contractSchema = schema;\n            } else {\n              contractSchema = Schema.fromRPCResponse({\n                script: schema\n              });\n            }\n\n            encodedKey = contractSchema.EncodeBigMapKey(key);\n            return [4\n            /*yield*/\n            , this.rpc.getBigMapKey(contract, encodedKey)];\n\n          case 3:\n            val = _a.sent();\n            return [2\n            /*return*/\n            , contractSchema.ExecuteOnBigMapValue(val)];\n          // Cast into T because only the caller can know the true type of the storage\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Return a well formatted json object of a big map value\r\n   *\r\n   * @param id Big Map ID\r\n   * @param keyToEncode key to query (will be encoded properly according to the schema)\r\n   * @param schema Big Map schema (can be determined using your contract type)\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\r\n   */\n\n\n  RpcContractProvider.prototype.getBigMapKeyByID = function (id, keyToEncode, schema) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, key, type, packed, encodedExpr, bigMapValue;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = schema.EncodeBigMapKey(keyToEncode), key = _a.key, type = _a.type;\n            return [4\n            /*yield*/\n            , this.context.rpc.packData({\n              data: key,\n              type: type\n            })];\n\n          case 1:\n            packed = _b.sent().packed;\n            encodedExpr = encodeExpr(packed);\n            return [4\n            /*yield*/\n            , this.context.rpc.getBigMapExpr(id.toString(), encodedExpr)];\n\n          case 2:\n            bigMapValue = _b.sent();\n            return [2\n            /*return*/\n            , schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this))];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\r\n   *\r\n   * @param OriginationOperation Originate operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.originate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, publicKeyHash, operation, preparedOrigination, forgedOrigination, _a, hash, context, forgedBytes, opResponse;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.originate.bind(this.estimator))];\n\n          case 1:\n            estimate = _b.sent();\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 2:\n            publicKeyHash = _b.sent();\n            return [4\n            /*yield*/\n            , createOriginationOperation(__assign(__assign({}, params), estimate))];\n\n          case 3:\n            operation = _b.sent();\n            return [4\n            /*yield*/\n            , this.prepareOperation({\n              operation: operation,\n              source: publicKeyHash\n            })];\n\n          case 4:\n            preparedOrigination = _b.sent();\n            return [4\n            /*yield*/\n            , this.forge(preparedOrigination)];\n\n          case 5:\n            forgedOrigination = _b.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(forgedOrigination)];\n\n          case 6:\n            _a = _b.sent(), hash = _a.hash, context = _a.context, forgedBytes = _a.forgedBytes, opResponse = _a.opResponse;\n            return [2\n            /*return*/\n            , new OriginationOperation(hash, operation, forgedBytes, opResponse, context, this)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Set the delegate for a contract. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param SetDelegate operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.setDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, operation, sourceOrDefault, _a, opBytes, _b, hash, context, forgedBytes, opResponse;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            // Since babylon delegation source cannot smart contract\n            if (/kt1/i.test(params.source)) {\n              throw new InvalidDelegationSource(params.source);\n            }\n\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.setDelegate.bind(this.estimator))];\n\n          case 1:\n            estimate = _c.sent();\n            return [4\n            /*yield*/\n            , createSetDelegateOperation(__assign(__assign({}, params), estimate))];\n\n          case 2:\n            operation = _c.sent();\n            _a = params.source;\n            if (_a) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 3:\n            _a = _c.sent();\n            _c.label = 4;\n\n          case 4:\n            sourceOrDefault = _a;\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: operation,\n              source: sourceOrDefault\n            })];\n\n          case 5:\n            opBytes = _c.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(opBytes)];\n\n          case 6:\n            _b = _c.sent(), hash = _b.hash, context = _b.context, forgedBytes = _b.forgedBytes, opResponse = _b.opResponse;\n            return [2\n            /*return*/\n            , new DelegateOperation(hash, operation, sourceOrDefault, forgedBytes, opResponse, context)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Register the current address as delegate. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param RegisterDelegate operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.registerDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, source, operation, opBytes, _a, hash, context, forgedBytes, opResponse;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.registerDelegate.bind(this.estimator))];\n\n          case 1:\n            estimate = _b.sent();\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 2:\n            source = _b.sent();\n            return [4\n            /*yield*/\n            , createRegisterDelegateOperation(__assign(__assign({}, params), estimate), source)];\n\n          case 3:\n            operation = _b.sent();\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: operation\n            })];\n\n          case 4:\n            opBytes = _b.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(opBytes)];\n\n          case 5:\n            _a = _b.sent(), hash = _a.hash, context = _a.context, forgedBytes = _a.forgedBytes, opResponse = _a.opResponse;\n            return [2\n            /*return*/\n            , new DelegateOperation(hash, operation, source, forgedBytes, opResponse, context)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param Transfer operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.transfer = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, operation, source, _a, opBytes, _b, hash, context, forgedBytes, opResponse;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.transfer.bind(this.estimator))];\n\n          case 1:\n            estimate = _c.sent();\n            return [4\n            /*yield*/\n            , createTransferOperation(__assign(__assign({}, params), estimate))];\n\n          case 2:\n            operation = _c.sent();\n            _a = params.source;\n            if (_a) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 3:\n            _a = _c.sent();\n            _c.label = 4;\n\n          case 4:\n            source = _a;\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: operation,\n              source: params.source\n            })];\n\n          case 5:\n            opBytes = _c.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(opBytes)];\n\n          case 6:\n            _b = _c.sent(), hash = _b.hash, context = _b.context, forgedBytes = _b.forgedBytes, opResponse = _b.opResponse;\n            return [2\n            /*return*/\n            , new TransactionOperation(hash, operation, source, forgedBytes, opResponse, context)];\n        }\n      });\n    });\n  };\n\n  RpcContractProvider.prototype.at = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var script, entrypoints;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.rpc.getScript(address)];\n\n          case 1:\n            script = _a.sent();\n            return [4\n            /*yield*/\n            , this.rpc.getEntrypoints(address)];\n\n          case 2:\n            entrypoints = _a.sent();\n            return [2\n            /*return*/\n            , new ContractAbstraction(address, script, this, this, entrypoints)];\n        }\n      });\n    });\n  };\n\n  return RpcContractProvider;\n}(OperationEmitter);\n\nvar BatchOperation =\n/** @class */\nfunction (_super) {\n  __extends(BatchOperation, _super);\n\n  function BatchOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  BatchOperation.prototype.sumProp = function (arr, prop) {\n    return arr.reduce(function (prev, current) {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  };\n\n  Object.defineProperty(BatchOperation.prototype, \"status\", {\n    get: function () {\n      return this.results.filter(function (result) {\n        return BATCH_KINDS.indexOf(result.kind) !== -1;\n      }).map(function (result) {\n        if (hasMetadataWithResult(result)) {\n          return result.metadata.operation_result.status;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"fee\", {\n    get: function () {\n      return this.sumProp(this.params, 'fee');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.sumProp(this.params, 'gas_limit');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.sumProp(this.params, 'storage_limit');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"consumedGas\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.results\n      }), 'consumed_gas'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"storageDiff\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.results\n      }), 'paid_storage_size_diff'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"errors\", {\n    get: function () {\n      return flattenErrors({\n        contents: this.results\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return BatchOperation;\n}(Operation);\n\nvar BATCH_KINDS = [OpKind.ACTIVATION, OpKind.ORIGINATION, OpKind.TRANSACTION, OpKind.DELEGATION];\n\nvar OperationBatch =\n/** @class */\nfunction (_super) {\n  __extends(OperationBatch, _super);\n\n  function OperationBatch(context, estimator) {\n    var _this = _super.call(this, context) || this;\n\n    _this.estimator = estimator;\n    _this.operations = [];\n    return _this;\n  }\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withTransfer = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.TRANSACTION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withContractCall = function (params) {\n    return this.withTransfer(params.toTransferParams());\n  };\n  /**\r\n   *\r\n   * @description Add a delegation operation to the batch\r\n   *\r\n   * @param params Delegation operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withDelegation = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.DELEGATION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add an activation operation to the batch\r\n   *\r\n   * @param params Activation operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withActivation = function (_a) {\n    var pkh = _a.pkh,\n        secret = _a.secret;\n    this.operations.push({\n      kind: OpKind.ACTIVATION,\n      pkh: pkh,\n      secret: secret\n    });\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add an origination operation to the batch\r\n   *\r\n   * @param params Origination operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withOrigination = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.ORIGINATION\n    }, params));\n    return this;\n  };\n\n  OperationBatch.prototype.getRPCOp = function (param) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (param.kind) {\n          case OpKind.TRANSACTION:\n            return [2\n            /*return*/\n            , createTransferOperation(__assign({}, param))];\n\n          case OpKind.ORIGINATION:\n            return [2\n            /*return*/\n            , createOriginationOperation(__assign({}, param))];\n\n          case OpKind.DELEGATION:\n            return [2\n            /*return*/\n            , createSetDelegateOperation(__assign({}, param))];\n\n          case OpKind.ACTIVATION:\n            return [2\n            /*return*/\n            , __assign({}, param)];\n\n          default:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\r\n   *\r\n   * @param params Operations parameter\r\n   */\n\n\n  OperationBatch.prototype.with = function (params) {\n    var e_1, _a;\n\n    try {\n      for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {\n        var param = params_1_1.value;\n\n        switch (param.kind) {\n          case OpKind.TRANSACTION:\n            this.withTransfer(param);\n            break;\n\n          case OpKind.ORIGINATION:\n            this.withOrigination(param);\n            break;\n\n          case OpKind.DELEGATION:\n            this.withDelegation(param);\n            break;\n\n          case OpKind.ACTIVATION:\n            this.withActivation(param);\n            break;\n\n          default:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Forge and Inject the operation batch\r\n   *\r\n   * @param params Optionally specify the source of the operation\r\n   */\n\n\n  OperationBatch.prototype.send = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimates, ops, i, _a, _b, op, estimated, _c, _d, e_2_1, source, _e, opBytes, _f, hash, context, forgedBytes, opResponse;\n\n      var e_2, _g;\n\n      var _this = this;\n\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimator.batch(this.operations)];\n\n          case 1:\n            estimates = _h.sent();\n            ops = [];\n            i = 0;\n            _h.label = 2;\n\n          case 2:\n            _h.trys.push([2, 10, 11, 12]);\n\n            _a = __values(this.operations), _b = _a.next();\n            _h.label = 3;\n\n          case 3:\n            if (!!_b.done) return [3\n            /*break*/\n            , 9];\n            op = _b.value;\n            if (!isOpWithFee(op)) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.estimate(op, function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , estimates[i]];\n                });\n              });\n            })];\n\n          case 4:\n            estimated = _h.sent();\n            _d = (_c = ops).push;\n            return [4\n            /*yield*/\n            , this.getRPCOp(__assign(__assign({}, op), estimated))];\n\n          case 5:\n            _d.apply(_c, [_h.sent()]);\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            ops.push(__assign({}, op));\n            _h.label = 7;\n\n          case 7:\n            i++;\n            _h.label = 8;\n\n          case 8:\n            _b = _a.next();\n            return [3\n            /*break*/\n            , 3];\n\n          case 9:\n            return [3\n            /*break*/\n            , 12];\n\n          case 10:\n            e_2_1 = _h.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            try {\n              if (_b && !_b.done && (_g = _a.return)) _g.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 12:\n            _e = params && params.source;\n            if (_e) return [3\n            /*break*/\n            , 14];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 13:\n            _e = _h.sent();\n            _h.label = 14;\n\n          case 14:\n            source = _e;\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: ops,\n              source: source\n            })];\n\n          case 15:\n            opBytes = _h.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(opBytes)];\n\n          case 16:\n            _f = _h.sent(), hash = _f.hash, context = _f.context, forgedBytes = _f.forgedBytes, opResponse = _f.opResponse;\n            return [2\n            /*return*/\n            , new BatchOperation(hash, ops, source, forgedBytes, opResponse, context)];\n        }\n      });\n    });\n  };\n\n  return OperationBatch;\n}(OperationEmitter);\n\nvar RPCBatchProvider =\n/** @class */\nfunction () {\n  function RPCBatchProvider(context, estimator) {\n    this.context = context;\n    this.estimator = estimator;\n  }\n  /***\r\n   *\r\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\r\n   *\r\n   * @param params List of operation to batch together\r\n   */\n\n\n  RPCBatchProvider.prototype.batch = function (params) {\n    var batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  };\n\n  return RPCBatchProvider;\n}();\n\nvar defaultConfig = {\n  confirmationPollingIntervalSecond: 10,\n  defaultConfirmationCount: 1,\n  confirmationPollingTimeoutSecond: 180\n};\n/**\r\n * @description Encapsulate common service used throughout different part of the library\r\n */\n\nvar Context =\n/** @class */\nfunction () {\n  function Context(_rpcClient, _signer, _proto, _config, forger, injector, wallet) {\n    if (_rpcClient === void 0) {\n      _rpcClient = new RpcClient();\n    }\n\n    if (_signer === void 0) {\n      _signer = new NoopSigner();\n    }\n\n    this._rpcClient = _rpcClient;\n    this._signer = _signer;\n    this._proto = _proto;\n    this._config = _config;\n    this.tz = new RpcTzProvider(this);\n    this.estimate = new RPCEstimateProvider(this);\n    this.contract = new RpcContractProvider(this, this.estimate);\n    this.batch = new RPCBatchProvider(this, this.estimate);\n    this.wallet = new Wallet(this);\n    this.config = _config;\n    this._forger = forger ? forger : new RpcForger(this);\n    this._injector = injector ? injector : new RpcInjector(this);\n    this.operationFactory = new OperationFactory(this);\n    this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);\n  }\n\n  Object.defineProperty(Context.prototype, \"config\", {\n    get: function () {\n      return this._config;\n    },\n    set: function (value) {\n      this._config = __assign(__assign({}, defaultConfig), value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"rpc\", {\n    get: function () {\n      return this._rpcClient;\n    },\n    set: function (value) {\n      this._rpcClient = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"injector\", {\n    get: function () {\n      return this._injector;\n    },\n    set: function (value) {\n      this._injector = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"forger\", {\n    get: function () {\n      return this._forger;\n    },\n    set: function (value) {\n      this._forger = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"signer\", {\n    get: function () {\n      return this._signer;\n    },\n    set: function (value) {\n      this._signer = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"walletProvider\", {\n    get: function () {\n      return this._walletProvider;\n    },\n    set: function (value) {\n      this._walletProvider = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"proto\", {\n    get: function () {\n      return this._proto;\n    },\n    set: function (value) {\n      this._proto = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Context.prototype.isAnyProtocolActive = function (protocol) {\n    if (protocol === void 0) {\n      protocol = [];\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var next_protocol;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._proto) return [3\n            /*break*/\n            , 1];\n            return [2\n            /*return*/\n            , protocol.includes(this._proto)];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.rpc.getBlockMetadata()];\n\n          case 2:\n            next_protocol = _a.sent().next_protocol;\n            return [2\n            /*return*/\n            , protocol.includes(next_protocol)];\n        }\n      });\n    });\n  };\n  /**\r\n   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\r\n   */\n\n\n  Context.prototype.clone = function () {\n    return new Context(this.rpc, this.signer, this.proto, this.config, this.forger, this._injector);\n  };\n\n  return Context;\n}();\n\nvar opHashFilter = function (op, filter) {\n  return op.hash === filter.opHash;\n};\n\nvar sourceFilter = function (x, filter) {\n  switch (x.kind) {\n    case 'endorsement':\n      return 'metadata' in x && x.metadata.delegate === filter.source;\n\n    case 'activate_account':\n      return 'metadata' in x && x.pkh === filter.source;\n\n    default:\n      return 'source' in x && x.source === filter.source;\n  }\n};\n\nvar kindFilter = function (x, filter) {\n  return 'kind' in x && x.kind === filter.kind;\n};\n\nvar destinationFilter = function (x, filter) {\n  switch (x.kind) {\n    case 'delegation':\n      return x.delegate === filter.destination;\n\n    case 'origination':\n      if ('metadata' in x && 'operation_result' in x.metadata && 'originated_contracts' in x.metadata.operation_result && Array.isArray(x.metadata.operation_result.originated_contracts)) {\n        return x.metadata.operation_result.originated_contracts.some(function (contract) {\n          return contract === filter.destination;\n        });\n      }\n\n      break;\n\n    case 'transaction':\n      return x.destination === filter.destination;\n\n    default:\n      return false;\n  }\n};\n\nvar evaluateOpFilter = function (op, filter) {\n  if ('opHash' in filter) {\n    return opHashFilter(op, filter);\n  } else if ('source' in filter) {\n    return sourceFilter(op, filter);\n  } else if ('kind' in filter) {\n    return kindFilter(op, filter);\n  } else if ('destination' in filter) {\n    return destinationFilter(op, filter);\n  }\n\n  return false;\n};\n\nvar evaluateExpression = function (op, exp) {\n  if (Array.isArray(exp.and)) {\n    return exp.and.every(function (x) {\n      return evaluateFilter(op, x);\n    });\n  } else if (Array.isArray(exp.or)) {\n    return exp.or.some(function (x) {\n      return evaluateFilter(op, x);\n    });\n  } else {\n    throw new Error('Filter expression must contains either and/or property');\n  }\n};\n\nvar evaluateFilter = function (op, filter) {\n  var filters = [];\n\n  if (!Array.isArray(filter)) {\n    filters.push(filter);\n  } else {\n    filters.push.apply(filters, __spread(filter));\n  }\n\n  return filters.every(function (filterOrExp) {\n    if ('and' in filterOrExp || 'or' in filterOrExp) {\n      return evaluateExpression(op, filterOrExp);\n    } else {\n      return evaluateOpFilter(op, filterOrExp);\n    }\n  });\n};\n\nvar ObservableSubscription =\n/** @class */\nfunction () {\n  function ObservableSubscription(obs) {\n    var _this = this;\n\n    this.errorListeners = [];\n    this.messageListeners = [];\n    this.closeListeners = [];\n    this.completed$ = new Subject();\n    obs.pipe(takeUntil(this.completed$)).subscribe(function (data) {\n      _this.call(_this.messageListeners, data);\n    }, function (error) {\n      _this.call(_this.errorListeners, error);\n    }, function () {\n      _this.call(_this.closeListeners);\n    });\n  }\n\n  ObservableSubscription.prototype.call = function (listeners, value) {\n    var e_1, _a;\n\n    try {\n      for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {\n        var l = listeners_1_1.value;\n\n        try {\n          l(value);\n        } catch (ex) {\n          console.error(ex);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  ObservableSubscription.prototype.remove = function (listeners, value) {\n    var idx = listeners.indexOf(value);\n\n    if (idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  };\n\n  ObservableSubscription.prototype.on = function (type, cb) {\n    switch (type) {\n      case 'data':\n        this.messageListeners.push(cb);\n        break;\n\n      case 'error':\n        this.errorListeners.push(cb);\n        break;\n\n      case 'close':\n        this.closeListeners.push(cb);\n        break;\n\n      default:\n        throw new Error(\"Trying to register on an unsupported event: \" + type);\n    }\n  };\n\n  ObservableSubscription.prototype.off = function (type, cb) {\n    switch (type) {\n      case 'data':\n        this.remove(this.messageListeners, cb);\n        break;\n\n      case 'error':\n        this.remove(this.errorListeners, cb);\n        break;\n\n      case 'close':\n        this.remove(this.closeListeners, cb);\n        break;\n\n      default:\n        throw new Error(\"Trying to unregister on an unsupported event: \" + type);\n    }\n  };\n\n  ObservableSubscription.prototype.close = function () {\n    this.completed$.next();\n  };\n\n  return ObservableSubscription;\n}();\n\nvar getLastBlock = function (context) {\n  return from(context.rpc.getBlock()).pipe(first());\n};\n\nvar applyFilter = function (filter) {\n  return concatMap(function (block) {\n    return new Observable(function (sub) {\n      var e_1, _a, e_2, _b, e_3, _c;\n\n      try {\n        for (var _d = __values(block.operations), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var ops = _e.value;\n\n          try {\n            for (var ops_1 = (e_2 = void 0, __values(ops)), ops_1_1 = ops_1.next(); !ops_1_1.done; ops_1_1 = ops_1.next()) {\n              var op = ops_1_1.value;\n\n              try {\n                for (var _f = (e_3 = void 0, __values(op.contents)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                  var content = _g.value;\n\n                  if (evaluateFilter(__assign({\n                    hash: op.hash\n                  }, content), filter)) {\n                    sub.next(__assign({\n                      hash: op.hash\n                    }, content));\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (ops_1_1 && !ops_1_1.done && (_b = ops_1.return)) _b.call(ops_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      sub.complete();\n    });\n  });\n};\n\nvar PollingSubscribeProvider =\n/** @class */\nfunction () {\n  function PollingSubscribeProvider(context, POLL_INTERVAL) {\n    var _this = this;\n\n    if (POLL_INTERVAL === void 0) {\n      POLL_INTERVAL = 20000;\n    }\n\n    this.context = context;\n    this.POLL_INTERVAL = POLL_INTERVAL;\n    this.newBlock$ = timer(0, this.POLL_INTERVAL).pipe(map(function () {\n      return _this.context;\n    }), switchMap(getLastBlock), distinctUntilKeyChanged('hash'), publishReplay(), refCount());\n  }\n\n  PollingSubscribeProvider.prototype.subscribe = function (_filter) {\n    return new ObservableSubscription(this.newBlock$.pipe(pluck('hash')));\n  };\n\n  PollingSubscribeProvider.prototype.subscribeOperation = function (filter) {\n    return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)));\n  };\n\n  return PollingSubscribeProvider;\n}();\n\nvar ForgingMismatchError =\n/** @class */\nfunction () {\n  function ForgingMismatchError(results) {\n    this.results = results;\n    this.name = 'ForgingMismatchError';\n    this.message = 'Forging mismatch error';\n  }\n\n  return ForgingMismatchError;\n}();\n\nvar CompositeForger =\n/** @class */\nfunction () {\n  function CompositeForger(forgers) {\n    this.forgers = forgers;\n\n    if (forgers.length === 0) {\n      throw new Error('At least one forger must be specified');\n    }\n  }\n\n  CompositeForger.prototype.forge = function (_a) {\n    var branch = _a.branch,\n        contents = _a.contents;\n    return __awaiter(this, void 0, void 0, function () {\n      var results, lastResult, currentResult;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all(this.forgers.map(function (forger) {\n              return forger.forge({\n                branch: branch,\n                contents: contents\n              });\n            }))];\n\n          case 1:\n            results = _b.sent();\n\n            if (results.length === 0) {\n              throw new Error('At least one forger must be specified');\n            }\n\n            lastResult = results.pop();\n\n            while (results.length) {\n              currentResult = results.pop();\n\n              if (currentResult !== lastResult) {\n                throw new ForgingMismatchError([lastResult, currentResult]);\n              }\n\n              lastResult = currentResult;\n            }\n\n            return [2\n            /*return*/\n            , lastResult];\n        }\n      });\n    });\n  };\n\n  return CompositeForger;\n}();\n/**\r\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\r\n */\n\n\nvar TezosToolkit =\n/** @class */\nfunction () {\n  function TezosToolkit() {\n    this._rpcClient = new RpcClient();\n    this._options = {};\n    this._context = new Context();\n    this._wallet = new Wallet(this._context);\n    this.format = format;\n    this.batch = this._context.batch.batch.bind(this._context.batch);\n    this.setProvider({\n      rpc: this._rpcClient\n    });\n  }\n  /**\r\n   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\r\n   *\r\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setProvider({rpc: 'https://api.tez.ie/rpc/mainnet', signer: new InMemorySigner.fromSecretKey(edsk...)})\r\n   * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setProvider = function (_a) {\n    var rpc = _a.rpc,\n        stream = _a.stream,\n        signer = _a.signer,\n        protocol = _a.protocol,\n        config = _a.config,\n        forger = _a.forger,\n        wallet = _a.wallet;\n    this.setRpcProvider(rpc);\n    this.setStreamProvider(stream);\n    this.setSignerProvider(signer);\n    this.setForgerProvider(forger);\n    this.setWalletProvider(wallet);\n    this._context.proto = protocol;\n    this._context.config = config;\n  };\n  /**\r\n   * @description Sets signer provider on the Tezos Taquito instance.\r\n   *\r\n   * @param options signer to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setSignerProvider = function (signer) {\n    if (!this._options.signer && typeof signer === 'undefined') {\n      this._context.signer = new NoopSigner();\n      this._options.signer = signer;\n    } else if (typeof signer !== 'undefined') {\n      this._context.signer = signer;\n      this._options.signer = signer;\n    }\n  };\n  /**\r\n   * @description Sets rpc provider on the Tezos Taquito instance\r\n   *\r\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setRpcProvider('https://api.tez.ie/rpc/mainnet')\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setRpcProvider = function (rpc) {\n    if (typeof rpc === 'string') {\n      this._rpcClient = new RpcClient(rpc);\n    } else if (rpc instanceof RpcClient) {\n      this._rpcClient = rpc;\n    } else if (this._options.rpc === undefined) {\n      this._rpcClient = new RpcClient();\n    }\n\n    this._options.rpc = this._rpcClient;\n    this._context.rpc = this._rpcClient;\n  };\n  /**\r\n   * @description Sets forger provider on the Tezos Taquito instance\r\n   *\r\n   * @param options forger to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setForgerProvider(localForger)\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setForgerProvider = function (forger) {\n    var f = typeof forger === 'undefined' ? this.getFactory(RpcForger)() : forger;\n    this._options.forger = f;\n    this._context.forger = f;\n  };\n  /**\r\n   * @description Sets stream provider on the Tezos Taquito instance\r\n   *\r\n   * @param options stream to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setStreamProvider(...)\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setStreamProvider = function (stream) {\n    if (typeof stream === 'string') {\n      this._stream = new PollingSubscribeProvider(new Context(new RpcClient(stream)));\n    } else if (typeof stream !== 'undefined') {\n      this._stream = stream;\n    } else if (this._options.stream === undefined) {\n      this._stream = this.getFactory(PollingSubscribeProvider)();\n    }\n\n    this._options.stream = stream;\n  };\n  /**\r\n   * @description Sets wallet provider on the Tezos Taquito instance\r\n   *\r\n   * @param options wallet to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setWalletProvider(...)\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setWalletProvider = function (wallet) {\n    if (!this._options.wallet && typeof wallet === 'undefined') {\n      var w = this.getFactory(LegacyWalletProvider)();\n      this._options.wallet = w;\n      this._context.walletProvider = w;\n    } else if (typeof wallet !== 'undefined') {\n      this._options.wallet = wallet;\n      this._context.walletProvider = wallet;\n    }\n  };\n\n  Object.defineProperty(TezosToolkit.prototype, \"tz\", {\n    /**\r\n     * @description Provide access to tezos account management\r\n     */\n    get: function () {\n      return this._context.tz;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"contract\", {\n    /**\r\n     * @description Provide access to smart contract utilities\r\n     */\n    get: function () {\n      return this._context.contract;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"wallet\", {\n    get: function () {\n      return this._wallet;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"operation\", {\n    get: function () {\n      return this._context.operationFactory;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"estimate\", {\n    /**\r\n     * @description Provide access to operation estimation utilities\r\n     */\n    get: function () {\n      return this._context.estimate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"stream\", {\n    /**\r\n     * @description Provide access to streaming utilities backed by an streamer implementation\r\n     */\n    get: function () {\n      return this._stream;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"rpc\", {\n    /**\r\n     * @description Provide access to the currently used rpc client\r\n     */\n    get: function () {\n      return this._context.rpc;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"signer\", {\n    /**\r\n     * @description Provide access to the currently used signer\r\n     */\n    get: function () {\n      return this._context.signer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @deprecated Deprecated in favor of setting the signer provider with @taquito/signer importKey\r\n   */\n\n  TezosToolkit.prototype.importKey = function (privateKeyOrEmail, passphrase, mnemonic, secret) {\n    return importKey(this, privateKeyOrEmail, passphrase, mnemonic, secret);\n  };\n\n  TezosToolkit.prototype.getFactory = function (ctor) {\n    var _this = this;\n\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return new (ctor.bind.apply(ctor, __spread([void 0, _this._context], args)))();\n    };\n  };\n\n  return TezosToolkit;\n}();\n/**\r\n * @description Default Tezos toolkit instance\r\n */\n\n\nvar Tezos = new TezosToolkit();\nexport { BigMapAbstraction, CompositeForger, Context, ContractAbstraction, ContractMethod, DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT, DelegationWalletOperation, InvalidDelegationSource, InvalidParameterError, LegacyWalletProvider, MANAGER_LAMBDA, MissedBlockDuringConfirmationError, OriginationWalletOperation, PollingSubscribeProvider, Protocols, RpcForger, Tezos, TezosOperationError, TezosPreapplyFailureError, TezosToolkit, TransactionWalletOperation, Wallet, WalletOperation, WalletOperationBatch, createOriginationOperation, createRegisterDelegateOperation, createSetDelegateOperation, createTransferOperation, defaultConfig, protocols };","map":{"version":3,"sources":["../src/forger/rpc-forger.ts","../src/injector/rpc-injector.ts","../src/signer/noop.ts","../src/operations/types.ts","../src/operations/operation-errors.ts","../src/wallet/receipt.ts","../src/wallet/operation.ts","../src/wallet/delegation-operation.ts","../src/wallet/origination-operation.ts","../src/wallet/transaction-operation.ts","../src/wallet/opreation-factory.ts","../src/constants.ts","../src/operations/operation-emitter.ts","../src/operations/operations.ts","../src/tz/rpc-tz-provider.ts","../src/contract/estimate.ts","../src/format.ts","../src/contract/prepare.ts","../src/contract/rpc-estimate-provider.ts","../src/operations/delegate-operation.ts","../src/operations/origination-operation.ts","../src/operations/transaction-operation.ts","../src/contract/errors.ts","../src/contract/manager-lambda.ts","../src/wallet/wallet.ts","../src/wallet/legacy.ts","../src/contract/contract.ts","../src/contract/big-map.ts","../src/contract/semantic.ts","../src/contract/rpc-contract-provider.ts","../src/operations/batch-operation.ts","../src/batch/rpc-batch-provider.ts","../src/context.ts","../src/subscribe/filters.ts","../src/subscribe/observable-subscription.ts","../src/subscribe/polling-provider.ts","../src/forger/composite-forger.ts","../src/taquito.ts"],"names":[],"mappings":"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","sourcesContent":["import { Forger, ForgeParams, ForgeResponse } from './interface';\nimport { Context } from '../context';\n\nexport class RpcForger implements Forger {\n  constructor(private context: Context) {}\n\n  forge({ branch, contents }: ForgeParams): Promise<ForgeResponse> {\n    return this.context.rpc.forgeOperations({ branch, contents });\n  }\n}\n","import { Injector } from './interface';\nimport { Context } from '../context';\n\nexport class RpcInjector implements Injector {\n  constructor(private context: Context) {}\n  inject(signedOperationBytes: string): Promise<string> {\n    return this.context.rpc.injectOperation(signedOperationBytes);\n  }\n}\n","import { Signer } from './interface';\n\nexport class UnconfiguredSignerError implements Error {\n  name = 'UnconfiguredSignerError';\n  message =\n    'No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.';\n}\n\n/**\n * @description Default signer implementation which does nothing and produce invalid signature\n */\nexport class NoopSigner implements Signer {\n  async publicKey(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async publicKeyHash(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async secretKey(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async sign(_bytes: string, _watermark?: Uint8Array): Promise<any> {\n    throw new UnconfiguredSignerError();\n  }\n}\n","import {\n  OperationObject,\n  InternalOperationResultKindEnum,\n  OpKind,\n  TransactionOperationParameter,\n} from '@taquito/rpc';\n\nexport { OpKind } from '@taquito/rpc';\n\nexport type withKind<T, K extends OpKind> = T & { kind: K };\n\nexport type ParamsWithKind =\n  | withKind<OriginateParams, OpKind.ORIGINATION>\n  | withKind<DelegateParams, OpKind.DELEGATION>\n  | withKind<TransferParams, OpKind.TRANSACTION>\n  | withKind<ActivationParams, OpKind.ACTIVATION>;\n\nexport const attachKind = <T, K extends OpKind>(op: T, kind: K) => {\n  return { ...op, kind } as withKind<T, K>;\n};\n\nexport const findWithKind = <T extends { kind: OpKind }, K extends OpKind>(\n  arr: T[],\n  kind: K\n): (T & { kind: K }) | undefined => {\n  if (Array.isArray(arr)) {\n    const found = arr.find(op => op.kind === kind);\n\n    if (found && isKind(found, kind)) {\n      return found;\n    }\n  }\n};\n\nexport const isKind = <T extends { kind: OpKind }, K extends OpKind>(\n  op: T,\n  kind: K\n): op is withKind<T, K> => {\n  return op.kind === kind;\n};\n\nexport type RPCOpWithFee =\n  | RPCTransferOperation\n  | RPCOriginationOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation;\nexport type RPCOpWithSource =\n  | RPCTransferOperation\n  | RPCOriginationOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation;\n\nexport const isOpWithFee = <T extends { kind: OpKind }>(\n  op: T\n): op is withKind<T, InternalOperationResultKindEnum> => {\n  return ['transaction', 'delegation', 'origination', 'reveal'].indexOf(op.kind) !== -1;\n};\n\nexport const isOpRequireReveal = <T extends { kind: OpKind }>(\n  op: T\n): op is withKind<T, Exclude<InternalOperationResultKindEnum, OpKind.REVEAL>> => {\n  return ['transaction', 'delegation', 'origination'].indexOf(op.kind) !== -1;\n};\n\nexport type SourceKinds = InternalOperationResultKindEnum;\n\nexport const isSourceOp = <T extends { kind: OpKind }>(op: T): op is withKind<T, SourceKinds> => {\n  return ['transaction', 'delegation', 'origination', 'reveal', 'ballot'].indexOf(op.kind) !== -1;\n};\n\nexport const hasMetadata = <T extends { kind: OpKind }, K>(\n  op: T\n): op is T & {\n  metadata: K;\n} => {\n  return 'metadata' in op;\n};\n\nexport const hasMetadataWithResult = <T extends { kind: OpKind }, K>(\n  op: T\n): op is T & {\n  metadata: {\n    operation_result: K;\n  };\n} => {\n  return hasMetadata<T, any>(op) && 'operation_result' in op.metadata;\n};\n\nexport const hasMetadataWithInternalOperationResult = <T extends { kind: OpKind }, K>(\n  op: T\n): op is T & {\n  metadata: {\n    internal_operation_results?: K;\n  };\n} => {\n  return hasMetadata<T, any>(op) && 'internal_operation_results' in op.metadata;\n};\n\nexport interface GasConsumingOperation {\n  consumedGas?: string;\n  gasLimit: number;\n}\n\nexport interface StorageConsumingOperation {\n  storageDiff?: string;\n  storageSize?: string;\n  storageLimit: number;\n}\n\nexport interface FeeConsumingOperation {\n  fee: number;\n}\n\nexport type OriginateParamsBase = {\n  balance?: string;\n  code: string | object[];\n  delegate?: string;\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n};\n\n/**\n * @description Parameters for originate method\n */\nexport type OriginateParams = OriginateParamsBase &\n  (\n    | {\n      init?: never;\n      /** JS representation of a storage object */\n      storage: any;\n    }\n    | {\n      /** Initial storage object value. Either Micheline or JSON encoded */\n      init: string | object;\n      storage?: never;\n    }\n  );\n\nexport interface ActivationParams {\n  pkh: string;\n  secret: string;\n}\n\n/**\n * @description RPC origination operation\n */\nexport interface RPCOriginationOperation {\n  kind: OpKind.ORIGINATION;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  balance: string;\n  delegate?: string;\n  source?: string;\n  script: {\n    code: any;\n    storage: any;\n  };\n}\n\n/**\n * @description RPC reveal operation\n */\nexport interface RPCRevealOperation {\n  kind: OpKind.REVEAL;\n  fee: number;\n  public_key: string;\n  source?: string;\n  gas_limit: number;\n  storage_limit: number;\n}\n\n/**\n * @description Result of a forge operation contains the operation plus its encoded version\n */\nexport interface ForgedBytes {\n  opbytes: string;\n  opOb: OperationObject;\n  counter: number;\n}\n\n/**\n * @description Parameters for setDelegate method\n */\nexport interface DelegateParams {\n  source: string;\n  delegate: string;\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description Parameters for registerDelegate method\n */\nexport interface RegisterDelegateParams {\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description RPC delegation operation\n */\nexport interface RPCDelegateOperation {\n  kind: OpKind.DELEGATION;\n  source?: string;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  delegate: string;\n}\n\n/**\n * @description Parameters for transfer method\n */\nexport interface TransferParams {\n  to: string;\n  source?: string;\n  amount: number;\n  fee?: number;\n  parameter?: TransactionOperationParameter;\n  gasLimit?: number;\n  storageLimit?: number;\n  mutez?: boolean;\n}\n\n/**\n * @description RPC transfer operation\n */\nexport interface RPCTransferOperation {\n  kind: OpKind.TRANSACTION;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  amount: string;\n  source?: string;\n  destination: string;\n  parameters?: TransactionOperationParameter;\n}\n\n/**\n * @description RPC activate account operation\n */\nexport interface RPCActivateOperation {\n  kind: OpKind.ACTIVATION;\n  pkh: string;\n  secret: string;\n}\n\nexport type RPCOperation =\n  | RPCOriginationOperation\n  | RPCTransferOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation\n  | RPCActivateOperation;\n\nexport type PrepareOperationParams = {\n  operation: RPCOperation | RPCOperation[];\n  source?: string;\n};\n","import {\n  MichelsonV1ExpressionBase,\n  OperationResultDelegation,\n  OperationResultOrigination,\n  OperationResultReveal,\n  OperationResultTransaction,\n  PreapplyResponse,\n  TezosGenericOperationError,\n} from '@taquito/rpc';\nimport {\n  hasMetadata,\n  hasMetadataWithInternalOperationResult,\n  hasMetadataWithResult,\n} from './types';\n\nexport interface TezosOperationErrorWithMessage extends TezosGenericOperationError {\n  with: MichelsonV1ExpressionBase;\n}\n\nconst isErrorWithMessage = (error: any): error is TezosOperationErrorWithMessage => {\n  return 'with' in error;\n};\n\nexport class TezosOperationError implements Error {\n  name: string = 'TezosOperationError';\n  id: string;\n  kind: string;\n  message: string;\n\n  constructor(public errors: TezosGenericOperationError[]) {\n    // Last error is 'often' the one with more detail\n    const lastError = errors[errors.length - 1];\n\n    this.id = lastError.id;\n    this.kind = lastError.kind;\n\n    this.message = `(${this.kind}) ${this.id}`;\n\n    if (isErrorWithMessage(lastError) && lastError.with.string) {\n      this.message = lastError.with.string;\n    }\n  }\n}\n\nexport class TezosPreapplyFailureError implements Error {\n  name: string = 'TezosPreapplyFailureError';\n  message: string = 'Preapply returned an unexpected result';\n\n  constructor(public result: any) {}\n}\n\nexport type MergedOperationResult = OperationResultDelegation &\n  OperationResultOrigination &\n  OperationResultTransaction &\n  OperationResultReveal & {\n    fee?: string;\n  };\n\n// Flatten all operation content results and internal operation results into a single array\n// Some cases where we can have multiple operation results or internal operation results are:\n// - When an operation includes a reveal operation\n// - When an operation is made using the batch API\n// - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts\nexport const flattenOperationResult = (response: PreapplyResponse | PreapplyResponse[]) => {\n  let results = Array.isArray(response) ? response : [response];\n\n  let returnedResults: MergedOperationResult[] = [];\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n      if (hasMetadataWithResult(content)) {\n        returnedResults.push({\n          fee: content.fee,\n          ...content.metadata.operation_result,\n        });\n\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          content.metadata.internal_operation_results.forEach(x => returnedResults.push(x.result));\n        }\n      }\n    }\n  }\n\n  return returnedResults;\n};\n\n/***\n * @description Flatten all error from preapply response (including internal error)\n */\nexport const flattenErrors = (\n  response: PreapplyResponse | PreapplyResponse[],\n  status = 'failed'\n) => {\n  let results = Array.isArray(response) ? response : [response];\n\n  let errors: TezosGenericOperationError[] = [];\n  // Transaction that do not fail will be backtracked in case one failure occur\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n      if (hasMetadata(content)) {\n        if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {\n          errors = errors.concat(content.metadata.operation_result.errors || []);\n        }\n        if (\n          hasMetadataWithInternalOperationResult(content) &&\n          Array.isArray(content.metadata.internal_operation_results)\n        ) {\n          for (const internalResult of content.metadata.internal_operation_results) {\n            if ('result' in internalResult && internalResult.result.status === status) {\n              errors = errors.concat(internalResult.result.errors || []);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n","import { OperationContentsAndResult } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { flattenOperationResult } from '../operations/operation-errors';\n\nexport interface Receipt {\n  totalFee: BigNumber;\n  totalGas: BigNumber;\n  totalStorage: BigNumber;\n  totalAllocationBurn: BigNumber;\n  totalOriginationBurn: BigNumber;\n  totalPaidStorageDiff: BigNumber;\n  totalStorageBurn: BigNumber;\n}\n\nexport const receiptFromOperation = (\n  op: OperationContentsAndResult[],\n  { ALLOCATION_BURN, ORIGINATION_BURN } = {\n    ALLOCATION_BURN: 257,\n    ORIGINATION_BURN: 257,\n  }\n): Receipt => {\n  const operationResults = flattenOperationResult({ contents: op });\n  let totalGas = new BigNumber(0);\n  let totalStorage = new BigNumber(0);\n  let totalFee = new BigNumber(0);\n  let totalOriginationBurn = new BigNumber(0);\n  let totalAllocationBurn = new BigNumber(0);\n  let totalPaidStorageDiff = new BigNumber(0);\n  operationResults.forEach(result => {\n    totalFee = totalFee.plus(result.fee || 0);\n    totalOriginationBurn = totalOriginationBurn.plus(\n      Array.isArray(result.originated_contracts)\n        ? result.originated_contracts.length * ORIGINATION_BURN\n        : 0\n    );\n    totalAllocationBurn = totalAllocationBurn.plus(\n      'allocated_destination_contract' in result ? ALLOCATION_BURN : 0\n    );\n    totalGas = totalGas.plus(result.consumed_gas || 0);\n    totalPaidStorageDiff = totalPaidStorageDiff.plus(\n      'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0\n    );\n  });\n\n  totalStorage = totalStorage\n    .plus(totalAllocationBurn)\n    .plus(totalOriginationBurn)\n    .plus(totalPaidStorageDiff);\n\n  return {\n    totalFee,\n    totalGas,\n    totalStorage,\n    totalAllocationBurn,\n    totalOriginationBurn,\n    totalPaidStorageDiff,\n    totalStorageBurn: new BigNumber(totalStorage.multipliedBy(1000)),\n  };\n};\n","import { BlockResponse, OperationContentsAndResult, OperationResultStatusEnum } from '@taquito/rpc';\nimport { combineLatest, from, Observable, ReplaySubject } from 'rxjs';\nimport {\n  distinctUntilChanged,\n  filter,\n  first,\n  map,\n  shareReplay,\n  takeWhile,\n  tap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { Receipt, receiptFromOperation } from './receipt';\n\nexport type OperationStatus = 'pending' | 'unknown' | OperationResultStatusEnum;\n\nexport class MissedBlockDuringConfirmationError implements Error {\n  name: string = 'MissedBlockDuringConfirmationError';\n  message: string =\n    'Taquito missed a block while waiting for operation confirmation and was not able to find the operation';\n}\n\nconst MAX_BRANCH_ANCESTORS = 60;\n\n/**\n * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation\n */\nexport class WalletOperation {\n  protected _operationResult = new ReplaySubject<OperationContentsAndResult[]>(1);\n  protected _includedInBlock = new ReplaySubject<BlockResponse>(1);\n  protected _included = false;\n\n  private lastHead: BlockResponse | undefined;\n  protected newHead$: Observable<BlockResponse> = this._newHead$.pipe(\n    tap(newHead => {\n      if (\n        !this._included &&\n        this.lastHead &&\n        newHead.header.level - this.lastHead.header.level > 1\n      ) {\n        throw new MissedBlockDuringConfirmationError();\n      }\n\n      this.lastHead = newHead;\n    }),\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n\n  // Observable that emit once operation is seen in a block\n  private confirmed$ = this.newHead$.pipe(\n    map(head => {\n      for (const opGroup of head.operations) {\n        for (const op of opGroup) {\n          if (op.hash === this.opHash) {\n            this._included = true;\n            this._includedInBlock.next(head);\n            this._operationResult.next(op.contents as OperationContentsAndResult[]);\n\n            // Return the block where the operation was found\n            return head;\n          }\n        }\n      }\n    }),\n    filter<BlockResponse | undefined, BlockResponse>((x): x is BlockResponse => {\n      return typeof x !== 'undefined';\n    }),\n    first(),\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n\n  async operationResults() {\n    return this._operationResult.pipe(first()).toPromise();\n  }\n\n  /**\n   * @description Receipt expose the total amount of tezos token burn and spent on fees\n   * The promise returned by receipt will resolve only once the transaction is included\n   */\n  async receipt(): Promise<Receipt> {\n    return receiptFromOperation(await this.operationResults());\n  }\n\n  /**\n   *\n   * @param opHash Operation hash\n   * @param raw Raw operation that was injected\n   * @param context Taquito context allowing access to rpc and signer\n   */\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    private _newHead$: Observable<BlockResponse>\n  ) {\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  async getCurrentConfirmation() {\n    if (!this._included) {\n      return 0;\n    }\n\n    return combineLatest([this._includedInBlock, from(this.context.rpc.getBlock())])\n      .pipe(\n        map(([foundAtBlock, head]) => {\n          return head.header.level - foundAtBlock.header.level + 1;\n        }),\n        first()\n      )\n      .toPromise();\n  }\n\n  async isInCurrentBranch(tipBlockIdentifier: string = 'head') {\n    // By default it is assumed that the operation is in the current branch\n    if (!this._included) {\n      return true;\n    }\n\n    const tipBlockHeader = await this.context.rpc.getBlockHeader({ block: tipBlockIdentifier });\n    const inclusionBlock = await this._includedInBlock.pipe(first()).toPromise();\n\n    const levelDiff = tipBlockHeader.level - inclusionBlock.header.level;\n\n    // Block produced before the operation is included are assumed to be part of the current branch\n    if (levelDiff <= 0) {\n      return true;\n    }\n\n    const tipBlockLevel = Math.min(\n      inclusionBlock.header.level + levelDiff,\n      inclusionBlock.header.level + MAX_BRANCH_ANCESTORS\n    );\n\n    const blocks = new Set(await this.context.rpc.getLiveBlocks({ block: String(tipBlockLevel) }));\n    return blocks.has(inclusionBlock.hash);\n  }\n\n  confirmationObservable(confirmations?: number) {\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new Error('Confirmation count must be at least 1');\n    }\n\n    const { defaultConfirmationCount } = this.context.config;\n\n    const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n    return combineLatest([this._includedInBlock, this.newHead$]).pipe(\n      distinctUntilChanged(([, previousHead], [, newHead]) => {\n        return previousHead.hash === newHead.hash;\n      }),\n      map(([foundAtBlock, head]) => {\n        return {\n          block: head,\n          expectedConfirmation: conf,\n          currentConfirmation: head.header.level - foundAtBlock.header.level + 1,\n          completed: head.header.level - foundAtBlock.header.level >= conf - 1,\n          isInCurrentBranch: () => this.isInCurrentBranch(head.hash),\n        };\n      }),\n      takeWhile(({ completed }) => !completed, true)\n    );\n  }\n\n  /**\n   *\n   * @param confirmations [0] Number of confirmation to wait for\n   */\n  confirmation(confirmations?: number) {\n    return this.confirmationObservable(confirmations).toPromise();\n  }\n}\n","import { BlockResponse, OperationContentsAndResultReveal, OpKind } from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { Context } from '../context';\nimport { WalletOperation, OperationStatus } from './operation';\n\nexport class DelegationWalletOperation extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async delegationOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.DELEGATION) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.delegationOperation();\n    if (!op) {\n      return 'unknown';\n    }\n\n    return op.metadata.operation_result.status;\n  }\n}\n","import {\n  BlockResponse,\n  OperationContentsAndResultOrigination,\n  OperationContentsAndResultReveal,\n  OpKind,\n} from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { Context } from '../context';\nimport { findWithKind } from '../operations/types';\nimport { WalletOperation, OperationStatus } from './operation';\n\nexport class OriginationWalletOperation extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async originationOperation() {\n    const operationResult = await this.operationResults();\n    return findWithKind(operationResult, OpKind.ORIGINATION) as\n      | OperationContentsAndResultOrigination\n      | undefined;\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return findWithKind(operationResult, OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.originationOperation();\n    if (!op) {\n      return 'unknown';\n    }\n\n    return op.metadata.operation_result.status;\n  }\n\n  public async contract() {\n    const op = await this.originationOperation();\n    const address = (op!.metadata.operation_result.originated_contracts || [])[0];\n    return this.context.wallet.at(address);\n  }\n}\n","import { WalletOperation, OperationStatus } from './operation';\nimport { Context } from '../context';\nimport { Observable } from 'rxjs';\nimport {\n  BlockResponse,\n  OpKind,\n  OperationContentsAndResultReveal,\n  OperationContentsAndResultTransaction,\n} from '@taquito/rpc';\n\nexport class TransactionWalletOperation extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async transactionOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.TRANSACTION) as\n      | OperationContentsAndResultTransaction\n      | undefined;\n  }\n\n  public async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.transactionOperation();\n    if (!op) {\n      return 'unknown';\n    }\n\n    return op.metadata.operation_result.status;\n  }\n}\n","import { BlockResponse } from '@taquito/rpc';\nimport {\n  concat,\n  defer,\n  from,\n  MonoTypeOperatorFunction,\n  Observable,\n  of,\n  range,\n  ReplaySubject,\n  SchedulerLike,\n  throwError,\n  timer,\n} from 'rxjs';\nimport {\n  concatMap,\n  distinctUntilKeyChanged,\n  first,\n  shareReplay,\n  startWith,\n  switchMap,\n  timeoutWith,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { DelegationWalletOperation } from './delegation-operation';\nimport { WalletOperation } from './operation';\nimport { OriginationWalletOperation } from './origination-operation';\nimport { TransactionWalletOperation } from './transaction-operation';\n\nexport const cacheUntil = <T>(\n  cacheUntilObs: Observable<any>\n): MonoTypeOperatorFunction<T> => source => {\n  let subject: ReplaySubject<T> | null = null;\n\n  return defer(() => {\n    if (!subject) {\n      subject = new ReplaySubject<T>();\n      source.pipe(first()).subscribe(subject);\n      cacheUntilObs.pipe(first()).subscribe(() => {\n        subject = null;\n      });\n    }\n\n    return subject;\n  });\n};\n\nexport const createNewPollingBasedHeadObservable = (\n  pollingTimer: Observable<number>,\n  sharedHeadOb: Observable<BlockResponse>,\n  context: Context,\n  scheduler?: SchedulerLike\n): Observable<BlockResponse> => {\n  return pollingTimer.pipe(\n    switchMap(() => sharedHeadOb),\n    distinctUntilKeyChanged('hash'),\n    timeoutWith(\n      context.config.confirmationPollingTimeoutSecond * 1000,\n      throwError(new Error('Confirmation polling timed out')),\n      scheduler\n    ),\n    shareReplay({\n      refCount: true,\n      scheduler,\n    })\n  );\n};\n\nexport interface OperationFactoryConfig {\n  blockIdentifier?: string;\n}\n\nexport class OperationFactory {\n  constructor(private context: Context) {}\n\n  // Cache the last block for one second across all operations\n  private sharedHeadObs = defer(() => from(this.context.rpc.getBlock())).pipe(\n    cacheUntil(timer(0, 1000))\n  );\n\n  private createNewHeadObservable() {\n    return createNewPollingBasedHeadObservable(\n      timer(0, this.context.config.confirmationPollingIntervalSecond * 1000),\n      this.sharedHeadObs,\n      this.context\n    );\n  }\n\n  private createPastBlockWalker(startBlock: string, count: number = 1) {\n    return from(this.context.rpc.getBlock({ block: startBlock })).pipe(\n      switchMap(block => {\n        if (count === 1) {\n          return of(block);\n        }\n\n        return range(block.header.level, count - 1).pipe(\n          startWith(block),\n          concatMap(async level => {\n            return this.context.rpc.getBlock({ block: String(level) });\n          })\n        );\n      })\n    );\n  }\n\n  private createHeadObservableFromConfig({ blockIdentifier }: OperationFactoryConfig) {\n    const observableSequence: Observable<BlockResponse>[] = [];\n\n    if (blockIdentifier) {\n      observableSequence.push(this.createPastBlockWalker(blockIdentifier));\n    }\n\n    observableSequence.push(this.createNewHeadObservable());\n\n    return concat(...observableSequence);\n  }\n\n  createOperation(hash: string, config: OperationFactoryConfig = {}): WalletOperation {\n    return new WalletOperation(\n      hash,\n      this.context.clone(),\n      this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  createTransactionOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): TransactionWalletOperation {\n    return new TransactionWalletOperation(\n      hash,\n      this.context.clone(),\n      this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  createDelegationOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): DelegationWalletOperation {\n    return new DelegationWalletOperation(\n      hash,\n      this.context.clone(),\n      this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  createOriginationOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): OriginationWalletOperation {\n    return new OriginationWalletOperation(\n      hash,\n      this.context.clone(),\n      this.createHeadObservableFromConfig(config)\n    );\n  }\n}\n","export enum DEFAULT_GAS_LIMIT {\n  DELEGATION = 10600,\n  ORIGINATION = 10600,\n  TRANSFER = 10600,\n  REVEAL = 10600,\n}\nexport enum DEFAULT_FEE {\n  DELEGATION = 1257,\n  ORIGINATION = 10000,\n  TRANSFER = 10000,\n  REVEAL = 1420,\n}\nexport enum DEFAULT_STORAGE_LIMIT {\n  DELEGATION = 0,\n  ORIGINATION = 257,\n  TRANSFER = 257,\n  REVEAL = 0,\n}\n\nexport enum Protocols {\n  Pt24m4xi = 'Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd',\n  PsBABY5H = 'PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU',\n  PsBabyM1 = 'PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS',\n  PsCARTHA = 'PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb',\n}\n\nexport const protocols = {\n  '004': [Protocols.Pt24m4xi],\n  '005': [Protocols.PsBABY5H, Protocols.PsBabyM1],\n  '006': [Protocols.PsCARTHA],\n};\n","import {\n  BlockHeaderResponse,\n  ManagerKeyResponse,\n  OperationContents,\n  OperationContentsAndResult,\n  OpKind,\n  RpcClient,\n  RPCRunOperationParam,\n} from '@taquito/rpc';\nimport { DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT, Protocols } from '../constants';\nimport { Context } from '../context';\nimport { Estimate } from '../contract/estimate';\nimport { flattenErrors, TezosOperationError, TezosPreapplyFailureError } from './operation-errors';\nimport {\n  ForgedBytes,\n  isOpRequireReveal,\n  PrepareOperationParams,\n  RPCOperation,\n  RPCOpWithFee,\n  RPCOpWithSource,\n  RPCRevealOperation,\n} from './types';\n\nexport interface PreparedOperation {\n  opOb: {\n    branch: string;\n    contents: OperationContents[];\n    protocol: string;\n  };\n  counter: number;\n}\n\nexport abstract class OperationEmitter {\n  get rpc(): RpcClient {\n    return this.context.rpc;\n  }\n\n  get signer() {\n    return this.context.signer;\n  }\n\n  constructor(protected context: Context) {}\n\n  // Originally from sotez (Copyright (c) 2018 Andrew Kishino)\n  protected async prepareOperation({\n    operation,\n    source,\n  }: PrepareOperationParams): Promise<PreparedOperation> {\n    let counter;\n    const counters: { [key: string]: number } = {};\n    let requiresReveal = false;\n    let ops: RPCOperation[] = [];\n    let head: BlockHeaderResponse;\n\n    const blockHeaderPromise = this.rpc.getBlockHeader();\n    const blockMetaPromise = this.rpc.getBlockMetadata();\n\n    if (Array.isArray(operation)) {\n      ops = [...operation];\n    } else {\n      ops = [operation];\n    }\n\n    // Implicit account who emit the operation\n    const publicKeyHash = await this.signer.publicKeyHash();\n\n    let counterPromise: Promise<string | undefined> = Promise.resolve(undefined);\n    let managerPromise: Promise<ManagerKeyResponse | undefined> = Promise.resolve(undefined);\n    for (let i = 0; i < ops.length; i++) {\n      if (isOpRequireReveal(ops[i])) {\n        requiresReveal = true;\n        const { counter } = await this.rpc.getContract(publicKeyHash);\n        counterPromise = Promise.resolve(counter);\n        managerPromise = this.rpc.getManagerKey(publicKeyHash);\n        break;\n      }\n    }\n\n    const [header, metadata, headCounter, manager] = await Promise.all([\n      blockHeaderPromise,\n      blockMetaPromise,\n      counterPromise,\n      managerPromise as any,\n    ]);\n\n    if (!header) {\n      throw new Error('Unable to fetch latest block header');\n    }\n\n    if (!metadata) {\n      throw new Error('Unable to fetch latest metadata');\n    }\n\n    head = header;\n\n    if (requiresReveal) {\n      const haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;\n      if (!haveManager) {\n        const reveal: RPCRevealOperation = {\n          kind: OpKind.REVEAL,\n          fee: DEFAULT_FEE.REVEAL,\n          public_key: await this.signer.publicKey(),\n          source: publicKeyHash,\n          gas_limit: DEFAULT_GAS_LIMIT.REVEAL,\n          storage_limit: DEFAULT_STORAGE_LIMIT.REVEAL,\n        };\n\n        ops.unshift(reveal);\n      }\n    }\n\n    counter = parseInt(headCounter || '0', 10);\n    if (!counters[publicKeyHash] || counters[publicKeyHash] < counter) {\n      counters[publicKeyHash] = counter;\n    }\n\n    const getFee = (op: RPCOpWithFee) => {\n      const opCounter = ++counters[publicKeyHash];\n      return {\n        counter: `${opCounter}`,\n        // tslint:disable-next-line: strict-type-predicates\n        fee: typeof op.fee === 'undefined' ? '0' : `${op.fee}`,\n        // tslint:disable-next-line: strict-type-predicates\n        gas_limit: typeof op.gas_limit === 'undefined' ? '0' : `${op.gas_limit}`,\n        // tslint:disable-next-line: strict-type-predicates\n        storage_limit: typeof op.storage_limit === 'undefined' ? '0' : `${op.storage_limit}`,\n      };\n    };\n\n    const getSource = (op: RPCOpWithSource) => {\n      return {\n        source: typeof op.source === 'undefined' ? source || publicKeyHash : op.source,\n      };\n    };\n\n    const constructOps = (cOps: RPCOperation[]): OperationContents[] =>\n      // tslint:disable strict-type-predicates\n      cOps.map((op: RPCOperation) => {\n        switch (op.kind) {\n          case OpKind.ACTIVATION:\n            return {\n              ...op,\n            };\n          case OpKind.REVEAL:\n            return {\n              ...op,\n              ...getSource(op),\n              ...getFee(op),\n            };\n          case OpKind.ORIGINATION:\n            return {\n              ...op,\n              balance: typeof op.balance !== 'undefined' ? `${op.balance}` : '0',\n              ...getSource(op),\n              ...getFee(op),\n            };\n          case OpKind.TRANSACTION:\n            const cops = {\n              ...op,\n              amount: typeof op.amount !== 'undefined' ? `${op.amount}` : '0',\n              ...getSource(op),\n              ...getFee(op),\n            };\n            if (cops.source.toLowerCase().startsWith('kt1')) {\n              throw new Error(\n                `KT1 addresses are not supported as source since ${Protocols.PsBabyM1}`\n              );\n            }\n            return cops;\n          case OpKind.DELEGATION:\n            return {\n              ...op,\n              ...getSource(op),\n              ...getFee(op),\n            };\n          default:\n            throw new Error('Unsupported operation');\n        }\n      });\n\n    const branch = head.hash;\n    const contents = constructOps(ops);\n    const protocol = metadata.next_protocol;\n\n    return {\n      opOb: {\n        branch,\n        contents,\n        protocol,\n      },\n      counter,\n    };\n  }\n\n  protected async prepareAndForge(params: PrepareOperationParams) {\n    const prepared = await this.prepareOperation(params);\n    return this.forge(prepared);\n  }\n\n  protected async forge({ opOb: { branch, contents, protocol }, counter }: PreparedOperation) {\n    let forgedBytes = await this.context.forger.forge({ branch, contents });\n\n    return {\n      opbytes: forgedBytes,\n      opOb: {\n        branch,\n        contents,\n        protocol,\n      },\n      counter,\n    };\n  }\n\n  protected async simulate(op: RPCRunOperationParam) {\n    return {\n      opResponse: await this.rpc.runOperation(op),\n      op,\n      context: this.context.clone(),\n    };\n  }\n\n  protected async estimate<T extends { fee?: number; gasLimit?: number; storageLimit?: number }>(\n    { fee, gasLimit, storageLimit, ...rest }: T,\n    estimator: (param: T) => Promise<Estimate>\n  ) {\n    let calculatedFee = fee;\n    let calculatedGas = gasLimit;\n    let calculatedStorage = storageLimit;\n\n    if (fee === undefined || gasLimit === undefined || storageLimit === undefined) {\n      const estimation = await estimator({ fee, gasLimit, storageLimit, ...(rest as any) });\n\n      if (calculatedFee === undefined) {\n        calculatedFee = estimation.suggestedFeeMutez;\n      }\n\n      if (calculatedGas === undefined) {\n        calculatedGas = estimation.gasLimit;\n      }\n\n      if (calculatedStorage === undefined) {\n        calculatedStorage = estimation.storageLimit;\n      }\n    }\n\n    return {\n      fee: calculatedFee!,\n      gasLimit: calculatedGas!,\n      storageLimit: calculatedStorage!,\n    };\n  }\n\n  protected async signAndInject(forgedBytes: ForgedBytes) {\n    const signed = await this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));\n    forgedBytes.opbytes = signed.sbytes;\n    forgedBytes.opOb.signature = signed.prefixSig;\n\n    const opResponse: OperationContentsAndResult[] = [];\n    const results = await this.rpc.preapplyOperations([forgedBytes.opOb]);\n\n    if (!Array.isArray(results)) {\n      throw new TezosPreapplyFailureError(results);\n    }\n\n    for (let i = 0; i < results.length; i++) {\n      for (let j = 0; j < results[i].contents.length; j++) {\n        opResponse.push(results[i].contents[j]);\n      }\n    }\n\n    const errors = flattenErrors(results);\n\n    if (errors.length) {\n      // @ts-ignore\n      throw new TezosOperationError(errors);\n    }\n\n    return {\n      hash: await this.context.injector.inject(forgedBytes.opbytes),\n      forgedBytes,\n      opResponse,\n      context: this.context.clone(),\n    };\n  }\n}\n","import {\n  BlockResponse,\n  OperationContentsAndResult,\n  OperationResultStatusEnum,\n  OperationContentsAndResultReveal,\n} from '@taquito/rpc';\nimport { defer, from, ReplaySubject, timer } from 'rxjs';\nimport {\n  filter,\n  first,\n  map,\n  mapTo,\n  shareReplay,\n  switchMap,\n  switchMapTo,\n  tap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { ForgedBytes, hasMetadataWithResult } from './types';\n\ninterface PollingConfig {\n  timeout: number;\n  interval: number;\n}\n\n/**\n * @description Utility class to interact with Tezos operations\n */\nexport class Operation {\n  private _pollingConfig$ = new ReplaySubject<PollingConfig>(1);\n\n  private _currentHeadPromise: Promise<BlockResponse> | undefined = undefined;\n\n  // Caching the current head for one second\n  private currentHead$ = defer(() => {\n    if (!this._currentHeadPromise) {\n      this._currentHeadPromise = this.context.rpc.getBlock();\n      timer(1000)\n        .pipe(first())\n        .subscribe(() => {\n          this._currentHeadPromise = undefined;\n        });\n    }\n    return from(this._currentHeadPromise);\n  });\n\n  // Polling observable that emit until timeout is reached\n  private polling$ = defer(() =>\n    this._pollingConfig$.pipe(\n      tap(({ timeout, interval }) => {\n        if (timeout <= 0) {\n          throw new Error('Timeout must be more than 0');\n        }\n\n        if (interval <= 0) {\n          throw new Error('Interval must be more than 0');\n        }\n      }),\n      map(config => ({\n        ...config,\n        timeoutAt: Math.ceil(config.timeout / config.interval) + 1,\n        count: 0,\n      })),\n      switchMap(config => timer(0, config.interval * 1000).pipe(mapTo(config))),\n      tap(config => {\n        config.count++;\n        if (config.count > config.timeoutAt) {\n          throw new Error(`Confirmation polling timed out`);\n        }\n      })\n    )\n  );\n\n  // Observable that emit once operation is seen in a block\n  private confirmed$ = this.polling$.pipe(\n    switchMapTo(this.currentHead$),\n    map(head => {\n      for (let i = 3; i >= 0; i--) {\n        head.operations[i].forEach(op => {\n          if (op.hash === this.hash) {\n            this._foundAt = head.header.level;\n          }\n        });\n      }\n\n      if (head.header.level - this._foundAt >= 0) {\n        return this._foundAt;\n      }\n    }),\n    filter(x => x !== undefined),\n    first(),\n    shareReplay()\n  );\n\n  protected _foundAt = Number.POSITIVE_INFINITY;\n  get includedInBlock() {\n    return this._foundAt;\n  }\n  /**\n   *\n   * @param hash Operation hash\n   * @param raw Raw operation that was injected\n   * @param context Taquito context allowing access to rpc and signer\n   */\n  constructor(\n    public readonly hash: string,\n    public readonly raw: ForgedBytes,\n    public readonly results: OperationContentsAndResult[],\n    protected readonly context: Context\n  ) {\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  get revealOperation() {\n    return (\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'reveal') as\n        | OperationContentsAndResultReveal\n        | undefined)\n    );\n  }\n\n  public get revealStatus() {\n    if (this.revealOperation) {\n      return this.revealOperation.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  public get status() {\n    return (\n      this.results.map(result => {\n        if (hasMetadataWithResult(result)) {\n          return result.metadata.operation_result.status;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown'\n    );\n  }\n\n  /**\n   *\n   * @param confirmations [0] Number of confirmation to wait for\n   * @param interval [10] Polling interval\n   * @param timeout [180] Timeout\n   */\n  confirmation(confirmations?: number, interval?: number, timeout?: number) {\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new Error('Confirmation count must be at least 1');\n    }\n\n    const {\n      defaultConfirmationCount,\n      confirmationPollingIntervalSecond,\n      confirmationPollingTimeoutSecond,\n    } = this.context.config;\n    this._pollingConfig$.next({\n      interval: interval || confirmationPollingIntervalSecond,\n      timeout: timeout || confirmationPollingTimeoutSecond,\n    } as Required<PollingConfig>);\n\n    const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n    return new Promise<number>((resolve, reject) => {\n      this.confirmed$\n        .pipe(\n          switchMap(() => this.polling$),\n          switchMap(() => this.currentHead$),\n          filter(head => head.header.level - this._foundAt >= conf - 1),\n          first()\n        )\n        .subscribe(_ => {\n          resolve(this._foundAt + (conf - 1));\n        }, reject);\n    });\n  }\n}\n","import BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport { Operation } from '../operations/operations';\nimport { RPCActivateOperation } from '../operations/types';\nimport { TzProvider } from './interface';\nimport { OpKind } from '@taquito/rpc';\n\nexport class RpcTzProvider extends OperationEmitter implements TzProvider {\n  constructor(context: Context) {\n    super(context);\n  }\n\n  async getBalance(address: string): Promise<BigNumber> {\n    return this.rpc.getBalance(address);\n  }\n\n  async getDelegate(address: string): Promise<string | null> {\n    return this.rpc.getDelegate(address);\n  }\n\n  async activate(pkh: string, secret: string) {\n    const operation: RPCActivateOperation = {\n      kind: OpKind.ACTIVATION,\n      pkh,\n      secret,\n    };\n\n    const forgedBytes = await this.prepareAndForge({ operation: [operation], source: pkh });\n    const bytes = `${forgedBytes.opbytes}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;\n    return new Operation(\n      await this.rpc.injectOperation(bytes),\n      { ...forgedBytes, opbytes: bytes },\n      [],\n      this.context.clone()\n    );\n  }\n}\n","const MINIMAL_FEE_MUTEZ = 100;\nconst MINIMAL_FEE_PER_BYTE_MUTEZ = 1;\nconst MINIMAL_FEE_PER_STORAGE_BYTE_MUTEZ = 1000;\nconst MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;\n\nconst GAS_BUFFER = 100;\n\n/**\n * Examples of use :\n *\n *  Estimate a transfer operation :\n * ```\n * // Assuming that provider and signer are already configured...\n *\n * const amount = 2;\n * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';\n *\n * // Estimate gasLimit, storageLimit and fees for a transfer operation\n * const est = await Tezos.estimate.transfer({ to: address, amount: amount })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n *\n * Estimate a contract origination :\n * ```\n * // generic.json is referring to a Michelson Smart Contract\n *\n * const genericMultisigJSON = require('./generic.json')\n * const est = await Tezos.estimate.originate({\n *   code: genericMultisigJSON,\n *   storage: {\n *     stored_counter: 0,\n *     threshold: 1,\n *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']\n *   }\n * })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n */\n\nexport class Estimate {\n  constructor(\n    private readonly _gasLimit: number | string,\n    private readonly _storageLimit: number | string,\n    private readonly opSize: number | string,\n    /**\n     * @description Base fee in mutez (1 mutez = 1e106 tez)\n     */\n    private readonly baseFeeMutez: number | string = MINIMAL_FEE_MUTEZ\n  ) {}\n\n  /**\n   * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations).\n   */\n  get burnFeeMutez() {\n    return this.roundUp(Number(this.storageLimit) * MINIMAL_FEE_PER_STORAGE_BYTE_MUTEZ);\n  }\n\n  /**\n   * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.\n   */\n  get storageLimit() {\n    const limit = Math.max(Number(this._storageLimit), 0);\n    return limit > 0 ? limit : 0;\n  }\n\n  /**\n   * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.\n   */\n  get gasLimit() {\n    return Number(this._gasLimit) + GAS_BUFFER;\n  }\n\n  private get operationFeeMutez() {\n    return (\n      this.gasLimit * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ\n    );\n  }\n\n  private roundUp(nanotez: number) {\n    return Math.ceil(Number(nanotez));\n  }\n\n  /**\n   * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.\n   */\n  get minimalFeeMutez() {\n    return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);\n  }\n\n  /**\n   * @description The suggested fee for the operation which includes minimal fees and a small buffer.\n   */\n  get suggestedFeeMutez() {\n    return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);\n  }\n\n  /**\n   * @description Fees according to your specified base fee will ensure that at least minimum fees are used.\n   */\n  get usingBaseFeeMutez() {\n    return (\n      Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez)\n    );\n  }\n\n  /**\n   * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.\n   */\n  get totalCost() {\n    return this.minimalFeeMutez + this.burnFeeMutez;\n  }\n}\n","import BigNumber from 'bignumber.js';\n\nconst TZ_DECIMALS = 6;\nconst MTZ_DECIMALS = 3;\n\ntype Format = 'tz' | 'mtz' | 'mutez';\n\nfunction getDecimal(format: Format) {\n  switch (format) {\n    case 'tz':\n      return TZ_DECIMALS;\n    case 'mtz':\n      return MTZ_DECIMALS;\n    case 'mutez':\n    default:\n      return 0;\n  }\n}\n\nexport function format(\n  from: Format = 'mutez',\n  to: Format = 'mutez',\n  amount: number | string | BigNumber\n) {\n  const bigNum = new BigNumber(amount);\n  if (bigNum.isNaN()) {\n    return amount;\n  }\n\n  return bigNum\n    .multipliedBy(Math.pow(10, getDecimal(from)))\n    .dividedBy(Math.pow(10, getDecimal(to)));\n}\n","import { Schema } from '@taquito/michelson-encoder';\nimport { OpKind, MichelsonV1Expression } from '@taquito/rpc';\nimport { Parser, Prim, Expr } from '@taquito/michel-codec';\nimport {\n  OriginateParams,\n  RPCOriginationOperation,\n  TransferParams,\n  RPCTransferOperation,\n  DelegateParams,\n  RPCDelegateOperation,\n  RegisterDelegateParams,\n} from '../operations/types';\nimport { DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT } from '../constants';\nimport { format } from '../format';\n\nexport const createOriginationOperation = async ({\n  code,\n  init,\n  balance = \"0\",\n  delegate,\n  storage,\n  fee = DEFAULT_FEE.ORIGINATION,\n  gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION,\n}: OriginateParams) => {\n  // tslint:disable-next-line: strict-type-predicates\n  if (storage !== undefined && init !== undefined) {\n    throw new Error(\n      \"Storage and Init cannot be set a the same time. Please either use storage or init but not both.\",\n    );\n  }\n\n  const parser = new Parser({ expandMacros: true });\n\n  let contractCode: Expr[];\n  if (typeof code === 'string') {\n    const c = parser.parseScript(code);\n    if (c === null) {\n      throw new Error('Empty Michelson source');\n    }\n    contractCode = c;\n  } else {\n    const c = parser.parseJSON(code);\n    if (!Array.isArray(c)) {\n      throw new Error('JSON encoded Michelson script must be an array');\n    }\n    const order = ['parameter', 'storage', 'code'];\n    // Ensure correct ordering for RPC\n    contractCode = (c as Prim[]).sort((a, b) => order.indexOf(a.prim) - order.indexOf(b.prim));\n  }\n\n  let contractStorage: Expr | undefined;\n  if (storage !== undefined) {\n    const storageType = contractCode.find((p): p is Prim => ('prim' in p) && p.prim === 'storage');\n    if (storageType?.args === undefined) {\n      throw new Error('Missing storage section');\n    }\n    const schema = new Schema(storageType.args[0] as MichelsonV1Expression); // TODO\n    contractStorage = schema.Encode(storage);\n  } else if (typeof init === 'string') {\n    const c = parser.parseMichelineExpression(init);\n    if (c === null) {\n      throw new Error('Empty initial storage value');\n    }\n    contractStorage = c;\n  } else if (typeof init === 'object') {\n    contractStorage = parser.parseJSON(init);\n  }\n\n  const script = {\n    code: contractCode,\n    storage: contractStorage,\n  };\n\n  const operation: RPCOriginationOperation = {\n    kind: OpKind.ORIGINATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    balance: format(\"tz\", \"mutez\", balance).toString(),\n    script,\n  };\n\n  if (delegate) {\n    operation.delegate = delegate;\n  }\n  return operation;\n};\n\nexport const createTransferOperation = async ({\n  to,\n  amount,\n  parameter,\n  fee = DEFAULT_FEE.TRANSFER,\n  gasLimit = DEFAULT_GAS_LIMIT.TRANSFER,\n  storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER,\n  mutez = false,\n}: TransferParams) => {\n  const operation: RPCTransferOperation = {\n    kind: OpKind.TRANSACTION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    amount: mutez\n      ? amount.toString()\n      : format(\"tz\", \"mutez\", amount).toString(),\n    destination: to,\n    parameters: parameter,\n  };\n  return operation;\n};\n\nexport const createSetDelegateOperation = async ({\n  delegate,\n  source,\n  fee = DEFAULT_FEE.DELEGATION,\n  gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION,\n}: DelegateParams) => {\n  const operation: RPCDelegateOperation = {\n    kind: OpKind.DELEGATION,\n    source,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate,\n  };\n  return operation;\n};\n\nexport const createRegisterDelegateOperation = async (\n  {\n    fee = DEFAULT_FEE.DELEGATION,\n    gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n    storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION,\n  }: RegisterDelegateParams,\n  source: string,\n) => {\n  return {\n    kind: OpKind.DELEGATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate: source,\n  } as RPCDelegateOperation;\n};\n","import { PreapplyResponse, RPCRunOperationParam, OpKind } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport {\n  flattenErrors,\n  flattenOperationResult,\n  TezosOperationError,\n} from '../operations/operation-errors';\nimport {\n  DelegateParams,\n  isOpWithFee,\n  OriginateParams,\n  ParamsWithKind,\n  PrepareOperationParams,\n  RegisterDelegateParams,\n  RPCOperation,\n  TransferParams,\n} from '../operations/types';\nimport { Estimate } from './estimate';\nimport { EstimationProvider } from './interface';\nimport {\n  createOriginationOperation,\n  createRegisterDelegateOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from './prepare';\n\ninterface Limits {\n  fee?: number;\n  storageLimit?: number;\n  gasLimit?: number;\n}\n\nconst mergeLimits = (\n  userDefinedLimit: Limits,\n  defaultLimits: Required<Limits>\n): Required<Limits> => {\n  return {\n    fee: typeof userDefinedLimit.fee === 'undefined' ? defaultLimits.fee : userDefinedLimit.fee,\n    gasLimit:\n      typeof userDefinedLimit.gasLimit === 'undefined'\n        ? defaultLimits.gasLimit\n        : userDefinedLimit.gasLimit,\n    storageLimit:\n      typeof userDefinedLimit.storageLimit === 'undefined'\n        ? defaultLimits.storageLimit\n        : userDefinedLimit.storageLimit,\n  };\n};\n\n// RPC requires a signature but does not verify it\nconst SIGNATURE_STUB =\n  'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';\n\nexport class RPCEstimateProvider extends OperationEmitter implements EstimationProvider {\n  private readonly ALLOCATION_STORAGE = 257;\n  private readonly ORIGINATION_STORAGE = 257;\n\n  // Maximum values defined by the protocol\n  private async getAccountLimits(pkh: string) {\n    const balance = await this.rpc.getBalance(pkh);\n    const {\n      hard_gas_limit_per_operation,\n      hard_storage_limit_per_operation,\n      cost_per_byte,\n    } = await this.rpc.getConstants();\n    return {\n      fee: 0,\n      gasLimit: hard_gas_limit_per_operation.toNumber(),\n      storageLimit: Math.floor(\n        BigNumber.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber()\n      ),\n    };\n  }\n\n  private createEstimateFromOperationContent(\n    content: PreapplyResponse['contents'][0],\n    size: number\n  ) {\n    const operationResults = flattenOperationResult({ contents: [content] });\n    let totalGas = 0;\n    let totalStorage = 0;\n    operationResults.forEach(result => {\n      totalStorage +=\n        'originated_contracts' in result && typeof result.originated_contracts !== 'undefined'\n          ? result.originated_contracts.length * this.ORIGINATION_STORAGE\n          : 0;\n      totalStorage += 'allocated_destination_contract' in result ? this.ALLOCATION_STORAGE : 0;\n      totalGas += Number(result.consumed_gas) || 0;\n      totalStorage +=\n        'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;\n    });\n\n    if (isOpWithFee(content)) {\n      return new Estimate(totalGas || 0, Number(totalStorage || 0), size);\n    } else {\n      return new Estimate(0, 0, size, 0);\n    }\n  }\n\n  private async createEstimate(params: PrepareOperationParams) {\n    const {\n      opbytes,\n      opOb: { branch, contents },\n    } = await this.prepareAndForge(params);\n\n    let operation: RPCRunOperationParam = {\n      operation: { branch, contents, signature: SIGNATURE_STUB },\n      chain_id: await this.rpc.getChainId(),\n    };\n\n    const { opResponse } = await this.simulate(operation);\n\n    const errors = [...flattenErrors(opResponse, 'backtracked'), ...flattenErrors(opResponse)];\n\n    // Fail early in case of errors\n    if (errors.length) {\n      throw new TezosOperationError(errors);\n    }\n\n    while (\n      opResponse.contents.length !== (Array.isArray(params.operation) ? params.operation.length : 1)\n    ) {\n      opResponse.contents.shift();\n    }\n\n    return opResponse.contents.map(x => {\n      return this.createEstimateFromOperationContent(\n        x,\n        opbytes.length / 2 / opResponse.contents.length\n      );\n    });\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param OriginationOperation Originate operation parameter\n   */\n  async originate({ fee, storageLimit, gasLimit, ...rest }: OriginateParams) {\n    const pkh = await this.signer.publicKeyHash();\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh);\n    const op = await createOriginationOperation({\n      ...rest,\n      ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n    });\n    return (await this.createEstimate({ operation: op, source: pkh }))[0];\n  }\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param TransferOperation Originate operation parameter\n   */\n  async transfer({ fee, storageLimit, gasLimit, ...rest }: TransferParams) {\n    const pkh = await this.signer.publicKeyHash();\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh);\n    const op = await createTransferOperation({\n      ...rest,\n      ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n    });\n    return (await this.createEstimate({ operation: op, source: pkh }))[0];\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async setDelegate({ fee, gasLimit, storageLimit, ...rest }: DelegateParams) {\n    const sourceOrDefault = rest.source || (await this.signer.publicKeyHash());\n    const DEFAULT_PARAMS = await this.getAccountLimits(sourceOrDefault);\n    const op = await createSetDelegateOperation({\n      ...rest,\n      ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n    });\n    return (await this.createEstimate({ operation: op, source: sourceOrDefault }))[0];\n  }\n\n  async batch(params: ParamsWithKind[]) {\n    const operations: RPCOperation[] = [];\n    const DEFAULT_PARAMS = await this.getAccountLimits(await this.signer.publicKeyHash());\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          operations.push(\n            await createTransferOperation({\n              ...param,\n              ...mergeLimits(param, DEFAULT_PARAMS),\n            })\n          );\n          break;\n        case OpKind.ORIGINATION:\n          operations.push(\n            await createOriginationOperation({\n              ...param,\n              ...mergeLimits(param, DEFAULT_PARAMS),\n            })\n          );\n          break;\n        case OpKind.DELEGATION:\n          operations.push(\n            await createSetDelegateOperation({\n              ...param,\n              ...mergeLimits(param, DEFAULT_PARAMS),\n            })\n          );\n          break;\n        case OpKind.ACTIVATION:\n          operations.push({\n            ...param,\n            ...DEFAULT_PARAMS,\n          });\n          break;\n        default:\n          throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n      }\n    }\n    return this.createEstimate({ operation: operations });\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async registerDelegate(params: RegisterDelegateParams) {\n    const DEFAULT_PARAMS = await this.getAccountLimits(await this.signer.publicKeyHash());\n    const op = await createRegisterDelegateOperation(\n      { ...params, ...DEFAULT_PARAMS },\n      await this.signer.publicKeyHash()\n    );\n    return (\n      await this.createEstimate({ operation: op, source: await this.signer.publicKeyHash() })\n    )[0];\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultDelegation } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCDelegateOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Delegation operation provide utility function to fetch newly issued delegation\n *\n * @warn Currently support only one delegation per operation\n */\nexport class DelegateOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCDelegateOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const delegationOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'delegation') as OperationContentsAndResultDelegation);\n    const result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    if (operationResults) {\n      return operationResults.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get delegate(): string {\n    return this.delegate;\n  }\n\n  get isRegisterOperation(): boolean {\n    return this.delegate === this.source;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n}\n","import {\n  OperationContentsAndResult,\n  OperationResultOrigination,\n  OperationContentsAndResultOrigination,\n} from '@taquito/rpc';\nimport { Context } from '../context';\nimport { RpcContractProvider } from '../contract/rpc-contract-provider';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  hasMetadataWithResult,\n  RPCOriginationOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Origination operation provide utility function to fetch newly originated contract\n *\n * @warn Currently support only one origination per operation\n */\nexport class OriginationOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  /**\n   * @description Contract address of the newly originated contract\n   */\n  public readonly contractAddress?: string;\n\n  constructor(\n    hash: string,\n    private readonly params: RPCOriginationOperation,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context,\n    private contractProvider: RpcContractProvider\n  ) {\n    super(hash, raw, results, context);\n\n    const originatedContracts = this.operationResults && this.operationResults.originated_contracts;\n    if (Array.isArray(originatedContracts)) {\n      this.contractAddress = originatedContracts[0];\n    }\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    if (operationResults) {\n      return operationResults.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get operationResults() {\n    const originationOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'origination') as\n        | OperationContentsAndResultOrigination\n        | undefined);\n\n    const result =\n      originationOp &&\n      hasMetadataWithResult(originationOp) &&\n      originationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get storageDiff() {\n    const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;\n    return storageDiff ? storageDiff : undefined;\n  }\n\n  get storageSize() {\n    const storageSize = this.operationResults && this.operationResults.storage_size;\n    return storageSize ? storageSize : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n\n  /**\n   * @description Provide the contract abstract of the newly originated contract\n   */\n  async contract(confirmations?: number, interval?: number, timeout?: number) {\n    if (!this.contractAddress) {\n      throw new Error('No contract was originated in this operation');\n    }\n\n    await this.confirmation(confirmations, interval, timeout);\n    return this.contractProvider.at(this.contractAddress);\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultTransaction } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { flattenErrors, flattenOperationResult } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCTransferOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\n *\n * @warn Currently supports one transaction per operation\n */\nexport class TransactionOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCTransferOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const transactionOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'transaction') as OperationContentsAndResultTransaction);\n    return transactionOp ? [transactionOp] : [];\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    const txResult = operationResults[0];\n    if (txResult) {\n      return txResult.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get amount() {\n    return new BigNumber(this.params.amount);\n  }\n\n  get destination() {\n    return this.params.destination;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get consumedGas() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'consumed_gas')\n    );\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(\n        flattenOperationResult({ contents: this.operationResults }),\n        'paid_storage_size_diff'\n      )\n    );\n  }\n\n  get storageSize() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'storage_size')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.operationResults });\n  }\n}\n","export class InvalidParameterError implements Error {\n  name: string = 'Invalid parameters error';\n  message: string;\n  constructor(public smartContractMethodName: string, public sigs: any[], public args: any[]) {\n    this.message = `${smartContractMethodName} Received ${\n      args.length\n    } arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`;\n  }\n}\n\nexport class InvalidDelegationSource implements Error {\n  name: string = 'Invalid delegation source error';\n  message: string;\n\n  constructor(public source: string) {\n    this.message = `Since Babylon delegation source can no longer be a contract address ${source}. Please use the smart contract abstraction to set your delegate.`;\n  }\n}\n","const setDelegate = (key: string) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'key_hash' }, { string: key }],\n    },\n    { prim: 'SOME' },\n    { prim: 'SET_DELEGATE' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst transferImplicit = (key: string, mutez: number) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'key_hash' }, { string: key }],\n    },\n    { prim: 'IMPLICIT_ACCOUNT' },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'mutez' }, { int: `${mutez}` }],\n    },\n    { prim: 'UNIT' },\n    { prim: 'TRANSFER_TOKENS' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst removeDelegate = () => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    { prim: 'NONE', args: [{ prim: 'key_hash' }] },\n    { prim: 'SET_DELEGATE' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst transferToContract = (key: string, amount: number) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'address' }, { string: key }],\n    },\n    { prim: 'CONTRACT', args: [{ prim: 'unit' }] },\n    [\n      {\n        prim: 'IF_NONE',\n        args: [[[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]], []],\n      },\n    ],\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'mutez' }, { int: `${amount}` }],\n    },\n    { prim: 'UNIT' },\n    { prim: 'TRANSFER_TOKENS' },\n    { prim: 'CONS' },\n  ];\n};\n\nexport const MANAGER_LAMBDA = {\n  setDelegate,\n  removeDelegate,\n  transferImplicit,\n  transferToContract,\n};\n","import { Context } from '../context';\nimport { ContractAbstraction, ContractMethod, WalletContract } from '../contract';\nimport { OpKind, withKind } from '../operations/types';\nimport {\n  WalletDelegateParams,\n  WalletOriginateParams,\n  WalletProvider,\n  WalletTransferParams,\n} from './interface';\nimport { OperationFactory } from './opreation-factory';\n\nexport interface PKHOption {\n  forceRefetch?: boolean;\n}\n\nexport type WalletParamsWithKind =\n  | withKind<WalletTransferParams, OpKind.TRANSACTION>\n  | withKind<WalletOriginateParams, OpKind.ORIGINATION>\n  | withKind<WalletDelegateParams, OpKind.DELEGATION>;\n\nexport class WalletOperationBatch {\n  private operations: WalletParamsWithKind[] = [];\n\n  constructor(private walletProvider: WalletProvider, private operationFactory: OperationFactory) {}\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withTransfer(params: WalletTransferParams) {\n    this.operations.push({ kind: OpKind.TRANSACTION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withContractCall(params: ContractMethod<Wallet>) {\n    return this.withTransfer(params.toTransferParams());\n  }\n\n  /**\n   *\n   * @description Add a delegation operation to the batch\n   *\n   * @param params Delegation operation parameter\n   */\n  withDelegation(params: WalletDelegateParams) {\n    this.operations.push({ kind: OpKind.DELEGATION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an origination operation to the batch\n   *\n   * @param params Origination operation parameter\n   */\n  withOrigination(params: WalletOriginateParams) {\n    this.operations.push({ kind: OpKind.ORIGINATION, ...params });\n    return this;\n  }\n\n  private async mapOperation(param: WalletParamsWithKind) {\n    switch (param.kind) {\n      case OpKind.TRANSACTION:\n        return this.walletProvider.mapTransferParamsToWalletParams({\n          ...param,\n        });\n      case OpKind.ORIGINATION:\n        return this.walletProvider.mapOriginateParamsToWalletParams({\n          ...param,\n        });\n      case OpKind.DELEGATION:\n        return this.walletProvider.mapDelegateParamsToWalletParams({\n          ...param,\n        });\n      default:\n        throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n    }\n  }\n\n  /**\n   *\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n   *\n   * @param params Operations parameter\n   */\n  with(params: WalletParamsWithKind[]) {\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          this.withTransfer(param);\n          break;\n        case OpKind.ORIGINATION:\n          this.withOrigination(param);\n          break;\n        case OpKind.DELEGATION:\n          this.withDelegation(param);\n          break;\n        default:\n          throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   *\n   * @description Submit batch operation to wallet\n   *\n   */\n  async send() {\n    const ops: WalletParamsWithKind[] = [];\n\n    for (const op of this.operations) {\n      ops.push(await this.mapOperation(op));\n    }\n\n    const opHash = await this.walletProvider.sendOperations(ops);\n\n    return this.operationFactory.createOperation(opHash);\n  }\n}\n\nexport class Wallet {\n  constructor(private context: Context) {}\n\n  private get walletProvider() {\n    return this.context.walletProvider;\n  }\n\n  private _pkh?: string;\n\n  /**\n   * @description Retrieve the PKH of the account that is currently in use by the wallet\n   *\n   * @param option Option to use while fetching the PKH.\n   * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet\n   */\n  async pkh({ forceRefetch }: PKHOption = {}) {\n    if (!this._pkh || forceRefetch) {\n      this._pkh = await this.walletProvider.getPKH();\n    }\n\n    return this._pkh;\n  }\n\n  private walletCommand = <T>(send: () => Promise<T>) => {\n    return {\n      send,\n    };\n  };\n\n  /**\n   *\n   * @description Originate a new contract according to the script in parameters.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param originateParams Originate operation parameter\n   */\n  originate(params: WalletOriginateParams) {\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapOriginateParamsToWalletParams({\n        ...params,\n      });\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createOriginationOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Set the delegate for a contract.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param delegateParams operation parameter\n   */\n  setDelegate(params: WalletDelegateParams) {\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapDelegateParamsToWalletParams({ ...params });\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createDelegationOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Register the current address as delegate.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   */\n  registerDelegate() {\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapDelegateParamsToWalletParams({\n        delegate: await this.pkh(),\n      });\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createDelegationOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Transfer tezos tokens from current address to a specific address or call a smart contract.\n   *\n   * @returns A wallet command from which we can send the operation to the wallet\n   *\n   * @param params operation parameter\n   */\n  transfer(params: WalletTransferParams) {\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapTransferParamsToWalletParams(params);\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createTransactionOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Create a batch of operation\n   *\n   * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch\n   *\n   * @param params List of operation to initialize the batch with\n   */\n  batch(params: Parameters<WalletOperationBatch['with']>[0]) {\n    const batch = new WalletOperationBatch(this.walletProvider, this.context.operationFactory);\n    batch.with(params);\n    return batch;\n  }\n\n  /**\n   *\n   * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned\n   * smart contract abstraction will leverage the wallet provider to make smart contract calls\n   *\n   * @param address Smart contract address\n   */\n  async at(address: string): Promise<WalletContract> {\n    const script = await this.context.rpc.getScript(address);\n    const entrypoints = await this.context.rpc.getEntrypoints(address);\n    return new ContractAbstraction(address, script, this, this.context.contract, entrypoints);\n  }\n}\n","import { Context } from '../context';\nimport { attachKind, OpKind } from '../operations/types';\nimport {\n  WalletDelegateParams,\n  WalletOriginateParams,\n  WalletProvider,\n  WalletTransferParams,\n} from './interface';\nimport { WalletParamsWithKind } from './wallet';\n\nexport class LegacyWalletProvider implements WalletProvider {\n  constructor(private context: Context) {}\n\n  async getPKH(): Promise<string> {\n    return this.context.signer.publicKeyHash();\n  }\n\n  async mapTransferParamsToWalletParams(params: WalletTransferParams) {\n    return attachKind(params, OpKind.TRANSACTION);\n  }\n\n  async mapOriginateParamsToWalletParams(params: WalletOriginateParams) {\n    return attachKind(params, OpKind.ORIGINATION);\n  }\n\n  async mapDelegateParamsToWalletParams(params: WalletDelegateParams) {\n    return attachKind(params, OpKind.DELEGATION);\n  }\n\n  async sendOperations(params: WalletParamsWithKind[]) {\n    const op = await this.context.batch.batch(params as any).send();\n    return op.hash;\n  }\n}\n","import { ParameterSchema, Schema } from '@taquito/michelson-encoder';\nimport { EntrypointsResponse, ScriptResponse } from '@taquito/rpc';\nimport { TransactionOperation } from '../operations/transaction-operation';\nimport { TransferParams } from '../operations/types';\nimport { TransactionWalletOperation, Wallet } from '../wallet';\nimport { InvalidParameterError } from './errors';\nimport { ContractProvider, StorageProvider } from './interface';\n\ninterface SendParams {\n  fee?: number;\n  storageLimit?: number;\n  gasLimit?: number;\n  amount: number;\n  source?: string;\n  mutez?: boolean;\n}\n\n// Ensure that all parameter that are not in SendParams are defined\ntype ExplicitTransferParams = Required<Omit<TransferParams, keyof SendParams>> & SendParams;\n\nconst DEFAULT_SMART_CONTRACT_METHOD_NAME = 'main';\n\n/**\n * @description Utility class to send smart contract operation\n */\nexport class ContractMethod<T extends ContractProvider | Wallet> {\n  constructor(\n    private provider: T,\n    private address: string,\n    private parameterSchema: ParameterSchema,\n    private name: string,\n    private args: any[],\n    private isMultipleEntrypoint = true,\n    private isAnonymous = false\n  ) {}\n\n  /**\n   * @description Get the schema of the smart contract method\n   */\n  get schema() {\n    return this.isAnonymous\n      ? this.parameterSchema.ExtractSchema()[this.name]\n      : this.parameterSchema.ExtractSchema();\n  }\n\n  /**\n   *\n   * @description Send the smart contract operation\n   *\n   * @param Options generic operation parameter\n   */\n  send(\n    params: Partial<SendParams> = {}\n  ): Promise<T extends Wallet ? TransactionWalletOperation : TransactionOperation> {\n    if (this.provider instanceof Wallet) {\n      // TODO got around TS2352: Conversion of type 'T & Wallet' to type 'Wallet' by adding `as unknown`. Needs clarification\n      return (this.provider as unknown as Wallet).transfer(this.toTransferParams(params)).send() as any;\n    } else {\n      return this.provider.transfer(this.toTransferParams(params)) as any;\n    }\n  }\n\n  /**\n   *\n   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n   *\n   * @param Options generic transfer operation parameters\n   */\n  toTransferParams({\n    fee,\n    gasLimit,\n    storageLimit,\n    source,\n    amount = 0,\n    mutez = false,\n  }: Partial<SendParams> = {}): TransferParams {\n    const fullTransferParams: ExplicitTransferParams = {\n      to: this.address,\n      amount,\n      fee,\n      mutez,\n      source,\n      gasLimit,\n      storageLimit,\n      parameter: {\n        entrypoint: this.isMultipleEntrypoint ? this.name : 'default',\n        value: this.isAnonymous\n          ? this.parameterSchema.Encode(this.name, ...this.args)\n          : this.parameterSchema.Encode(...this.args),\n      },\n    };\n    return fullTransferParams;\n  }\n}\n\nconst validateArgs = (args: any[], schema: ParameterSchema, name: string) => {\n  const sigs = schema.ExtractSignatures();\n\n  if (!sigs.find((x: any[]) => x.length === args.length)) {\n    throw new InvalidParameterError(name, sigs, args);\n  }\n};\n\nexport type Contract = ContractAbstraction<ContractProvider>;\nexport type WalletContract = ContractAbstraction<Wallet>;\n\n/**\n * @description Smart contract abstraction\n */\nexport class ContractAbstraction<T extends ContractProvider | Wallet> {\n  /**\n   * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\n   * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\n   *\n   */\n  public methods: { [key: string]: (...args: any[]) => ContractMethod<T> } = {};\n\n  public readonly schema: Schema;\n\n  public readonly parameterSchema: ParameterSchema;\n\n  constructor(\n    public readonly address: string,\n    public readonly script: ScriptResponse,\n    provider: T,\n    private storageProvider: StorageProvider,\n    private entrypoints: EntrypointsResponse\n  ) {\n    this.schema = Schema.fromRPCResponse({ script: this.script });\n    this.parameterSchema = ParameterSchema.fromRPCResponse({ script: this.script });\n    this._initializeMethods(address, provider, this.entrypoints.entrypoints);\n  }\n\n  private _initializeMethods(\n    address: string,\n    provider: T,\n    entrypoints: {\n      [key: string]: object;\n    }\n  ) {\n    const parameterSchema = this.parameterSchema;\n    const keys = Object.keys(entrypoints);\n    if (parameterSchema.isMultipleEntryPoint) {\n      keys.forEach(smartContractMethodName => {\n        const method = function(...args: any[]) {\n          const smartContractMethodSchema = new ParameterSchema(\n            entrypoints[smartContractMethodName]\n          );\n\n          validateArgs(args, smartContractMethodSchema, smartContractMethodName);\n\n          return new ContractMethod<T>(\n            provider,\n            address,\n            smartContractMethodSchema,\n            smartContractMethodName,\n            args\n          );\n        };\n        this.methods[smartContractMethodName] = method;\n      });\n\n      // Deal with methods with no annotations which were not discovered by the RPC endpoint\n      // Methods with no annotations are discovered using parameter schema\n      const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter(\n        key => Object.keys(entrypoints).indexOf(key) === -1\n      );\n\n      anonymousMethods.forEach(smartContractMethodName => {\n        const method = function(...args: any[]) {\n          validateArgs(\n            [smartContractMethodName, ...args],\n            parameterSchema,\n            smartContractMethodName\n          );\n          return new ContractMethod<T>(\n            provider,\n            address,\n            parameterSchema,\n            smartContractMethodName,\n            args,\n            false,\n            true\n          );\n        };\n        this.methods[smartContractMethodName] = method;\n      });\n    } else {\n      const smartContractMethodSchema = this.parameterSchema;\n      const method = function(...args: any[]) {\n        validateArgs(args, parameterSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME);\n        return new ContractMethod<T>(\n          provider,\n          address,\n          smartContractMethodSchema,\n          DEFAULT_SMART_CONTRACT_METHOD_NAME,\n          args,\n          false\n        );\n      };\n      this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = method;\n    }\n  }\n\n  /**\n   * @description Return a friendly representation of the smart contract storage\n   */\n  public storage<T>() {\n    return this.storageProvider.getStorage<T>(this.address, this.schema);\n  }\n\n  /**\n   *\n   * @description Return a friendly representation of the smart contract big map value\n   *\n   * @param key BigMap key to fetch\n   *\n   * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n   */\n  public bigMap(key: string) {\n    // tslint:disable-next-line: deprecation\n    return this.storageProvider.getBigMapKey(this.address, key, this.schema);\n  }\n}\n","import { Schema } from '@taquito/michelson-encoder';\nimport BigNumber from 'bignumber.js';\nimport { ContractProvider } from './interface';\nimport { HttpResponseError, STATUS_CODE } from '@taquito/http-utils';\n\nexport class BigMapAbstraction {\n  constructor(private id: BigNumber, private schema: Schema, private provider: ContractProvider) {}\n\n  async get(keyToEncode: string) {\n    try {\n      const id = await this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema);\n      return id;\n    } catch (e) {\n      if (e instanceof HttpResponseError && e.status === STATUS_CODE.NOT_FOUND) {\n        return undefined;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  toJSON() {\n    return this.id.toString();\n  }\n\n  toString() {\n    return this.id.toString();\n  }\n}\n","import { Schema, Semantic } from '@taquito/michelson-encoder';\nimport { BigMapAbstraction } from './big-map';\nimport { ContractProvider } from './interface';\nimport BigNumber from 'bignumber.js';\nimport { MichelsonV1Expression } from '@taquito/rpc';\n\n// Override the default michelson encoder semantic to provide richer abstraction over storage properties\nexport const smartContractAbstractionSemantic: (p: ContractProvider) => Semantic = (\n  provider: ContractProvider\n) => ({\n  // Provide a specific abstraction for BigMaps\n  big_map: (val: MichelsonV1Expression, code: MichelsonV1Expression) => {\n    if (!val || !('int' in val) || val.int === undefined) {\n      // Return an empty object in case of missing big map ID\n      return {};\n    } else {\n      const schema = new Schema(code);\n      return new BigMapAbstraction(new BigNumber(val.int), schema, provider);\n    }\n  },\n  /*\n  // TODO: embed useful other abstractions\n  'contract':  () => {},\n  'address':  () => {}\n  */\n});\n","import { Schema } from '@taquito/michelson-encoder';\nimport { ScriptResponse } from '@taquito/rpc';\nimport { encodeExpr } from '@taquito/utils';\nimport { Context } from '../context';\nimport { DelegateOperation } from '../operations/delegate-operation';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport { OriginationOperation } from '../operations/origination-operation';\nimport { TransactionOperation } from '../operations/transaction-operation';\nimport {\n  DelegateParams,\n  OriginateParams,\n  RegisterDelegateParams,\n  TransferParams,\n} from '../operations/types';\nimport { ContractAbstraction } from './contract';\nimport { InvalidDelegationSource } from './errors';\nimport { ContractProvider, ContractSchema, EstimationProvider, StorageProvider } from './interface';\nimport {\n  createOriginationOperation,\n  createRegisterDelegateOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from './prepare';\nimport { smartContractAbstractionSemantic } from './semantic';\n\nexport class RpcContractProvider extends OperationEmitter implements ContractProvider, StorageProvider {\n  constructor(context: Context, private estimator: EstimationProvider) {\n    super(context);\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of the contract storage\n   *\n   * @param contract contract address you want to get the storage from\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n   */\n  async getStorage<T>(contract: string, schema?: ContractSchema): Promise<T> {\n    if (!schema) {\n      schema = await this.rpc.getScript(contract);\n    }\n\n    let contractSchema: Schema;\n    if (Schema.isSchema(schema)) {\n      contractSchema = schema;\n    } else {\n      contractSchema = Schema.fromRPCResponse({ script: schema as ScriptResponse });\n    }\n\n    const storage = await this.rpc.getStorage(contract);\n\n    return contractSchema.Execute(storage, smartContractAbstractionSemantic(this)) as T; // Cast into T because only the caller can know the true type of the storage\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of the contract big map storage\n   *\n   * @param contract contract address you want to get the storage from\n   * @param key contract big map key to fetch value from\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n   *\n   * @deprecated Deprecated in favor of getBigMapKeyByID\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n   */\n  async getBigMapKey<T>(contract: string, key: string, schema?: ContractSchema): Promise<T> {\n    if (!schema) {\n      schema = await this.rpc.getScript(contract);\n    }\n\n    let contractSchema: Schema;\n    if (Schema.isSchema(schema)) {\n      contractSchema = schema;\n    } else {\n      contractSchema = Schema.fromRPCResponse({ script: schema as ScriptResponse });\n    }\n\n    const encodedKey = contractSchema.EncodeBigMapKey(key);\n\n    // tslint:disable-next-line: deprecation\n    const val = await this.rpc.getBigMapKey(contract, encodedKey);\n\n    return contractSchema.ExecuteOnBigMapValue(val) as T; // Cast into T because only the caller can know the true type of the storage\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of a big map value\n   *\n   * @param id Big Map ID\n   * @param keyToEncode key to query (will be encoded properly according to the schema)\n   * @param schema Big Map schema (can be determined using your contract type)\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n   */\n  async getBigMapKeyByID<T>(id: string, keyToEncode: string, schema: Schema): Promise<T> {\n    const { key, type } = schema.EncodeBigMapKey(keyToEncode);\n    const { packed } = await this.context.rpc.packData({ data: key, type });\n\n    const encodedExpr = encodeExpr(packed);\n\n    const bigMapValue = await this.context.rpc.getBigMapExpr(id.toString(), encodedExpr);\n\n    return schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this)) as T;\n  }\n\n  /**\n   *\n   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\n   *\n   * @param OriginationOperation Originate operation parameter\n   */\n  async originate(params: OriginateParams) {\n    const estimate = await this.estimate(params, this.estimator.originate.bind(this.estimator));\n\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const operation = await createOriginationOperation({\n      ...params,\n      ...estimate,\n    });\n    const preparedOrigination = await this.prepareOperation({ operation, source: publicKeyHash });\n    const forgedOrigination = await this.forge(preparedOrigination);\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(forgedOrigination);\n    return new OriginationOperation(hash, operation, forgedBytes, opResponse, context, this);\n  }\n\n  /**\n   *\n   * @description Set the delegate for a contract. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param SetDelegate operation parameter\n   */\n  async setDelegate(params: DelegateParams) {\n    // Since babylon delegation source cannot smart contract\n    if (/kt1/i.test(params.source)) {\n      throw new InvalidDelegationSource(params.source);\n    }\n\n    const estimate = await this.estimate(params, this.estimator.setDelegate.bind(this.estimator));\n    const operation = await createSetDelegateOperation({ ...params, ...estimate });\n    const sourceOrDefault = params.source || (await this.signer.publicKeyHash());\n    const opBytes = await this.prepareAndForge({\n      operation,\n      source: sourceOrDefault,\n    });\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new DelegateOperation(\n      hash,\n      operation,\n      sourceOrDefault,\n      forgedBytes,\n      opResponse,\n      context\n    );\n  }\n\n  /**\n   *\n   * @description Register the current address as delegate. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param RegisterDelegate operation parameter\n   */\n  async registerDelegate(params: RegisterDelegateParams) {\n    const estimate = await this.estimate(\n      params,\n      this.estimator.registerDelegate.bind(this.estimator)\n    );\n    const source = await this.signer.publicKeyHash();\n    const operation = await createRegisterDelegateOperation({ ...params, ...estimate }, source);\n    const opBytes = await this.prepareAndForge({ operation });\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new DelegateOperation(hash, operation, source, forgedBytes, opResponse, context);\n  }\n\n  /**\n   *\n   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param Transfer operation parameter\n   */\n  async transfer(params: TransferParams) {\n    const estimate = await this.estimate(params, this.estimator.transfer.bind(this.estimator));\n    const operation = await createTransferOperation({\n      ...params,\n      ...estimate,\n    });\n    const source = params.source || (await this.signer.publicKeyHash());\n    const opBytes = await this.prepareAndForge({ operation, source: params.source });\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new TransactionOperation(hash, operation, source, forgedBytes, opResponse, context);\n  }\n\n  async at(address: string): Promise<ContractAbstraction<ContractProvider>> {\n    const script = await this.rpc.getScript(address);\n    const entrypoints = await this.rpc.getEntrypoints(address);\n    return new ContractAbstraction(address, script, this, this, entrypoints);\n  }\n}\n","import { OperationContentsAndResult, OperationResultStatusEnum } from '@taquito/rpc';\nimport { BATCH_KINDS } from '../batch/rpc-batch-provider';\nimport { Context } from '../context';\nimport { flattenErrors, flattenOperationResult } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCOperation,\n  StorageConsumingOperation,\n  hasMetadata,\n  hasMetadataWithResult,\n} from './types';\n\nexport class BatchOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCOperation[],\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  public get status() {\n    return (\n      this.results\n        .filter(result => BATCH_KINDS.indexOf(result.kind) !== -1)\n        .map(result => {\n          if (hasMetadataWithResult(result)) {\n            return result.metadata.operation_result.status;\n          } else {\n            return 'unknown';\n          }\n        })[0] || 'unknown'\n    );\n  }\n\n  get fee() {\n    return this.sumProp(this.params, 'fee');\n  }\n\n  get gasLimit() {\n    return this.sumProp(this.params, 'gas_limit');\n  }\n\n  get storageLimit() {\n    return this.sumProp(this.params, 'storage_limit');\n  }\n\n  get consumedGas() {\n    return String(this.sumProp(flattenOperationResult({ contents: this.results }), 'consumed_gas'));\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.results }), 'paid_storage_size_diff')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.results });\n  }\n}\n","import { Context } from '../context';\nimport { ContractMethod } from '../contract/contract';\nimport { EstimationProvider, ContractProvider } from '../contract/interface';\nimport {\n  createOriginationOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from '../contract/prepare';\nimport { BatchOperation } from '../operations/batch-operation';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport {\n  ActivationParams,\n  DelegateParams,\n  OriginateParams,\n  RPCOperation,\n  TransferParams,\n  ParamsWithKind,\n  isOpWithFee,\n} from '../operations/types';\nimport { OpKind } from '@taquito/rpc';\n\nexport const BATCH_KINDS = [\n  OpKind.ACTIVATION,\n  OpKind.ORIGINATION,\n  OpKind.TRANSACTION,\n  OpKind.DELEGATION,\n];\nexport type BatchKinds =\n  | OpKind.ACTIVATION\n  | OpKind.ORIGINATION\n  | OpKind.TRANSACTION\n  | OpKind.DELEGATION;\n\nexport class OperationBatch extends OperationEmitter {\n  private operations: ParamsWithKind[] = [];\n\n  constructor(context: Context, private estimator: EstimationProvider) {\n    super(context);\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withTransfer(params: TransferParams) {\n    this.operations.push({ kind: OpKind.TRANSACTION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withContractCall(params: ContractMethod<ContractProvider>) {\n    return this.withTransfer(params.toTransferParams());\n  }\n\n  /**\n   *\n   * @description Add a delegation operation to the batch\n   *\n   * @param params Delegation operation parameter\n   */\n  withDelegation(params: DelegateParams) {\n    this.operations.push({ kind: OpKind.DELEGATION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an activation operation to the batch\n   *\n   * @param params Activation operation parameter\n   */\n  withActivation({ pkh, secret }: ActivationParams) {\n    this.operations.push({ kind: OpKind.ACTIVATION, pkh, secret });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an origination operation to the batch\n   *\n   * @param params Origination operation parameter\n   */\n  withOrigination(params: OriginateParams) {\n    this.operations.push({ kind: OpKind.ORIGINATION, ...params });\n    return this;\n  }\n\n  private async getRPCOp(param: ParamsWithKind) {\n    switch (param.kind) {\n      case OpKind.TRANSACTION:\n        return createTransferOperation({\n          ...param,\n        });\n      case OpKind.ORIGINATION:\n        return createOriginationOperation({\n          ...param,\n        });\n      case OpKind.DELEGATION:\n        return createSetDelegateOperation({\n          ...param,\n        });\n      case OpKind.ACTIVATION:\n        return {\n          ...param,\n        };\n      default:\n        throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n    }\n  }\n\n  /**\n   *\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n   *\n   * @param params Operations parameter\n   */\n  with(params: ParamsWithKind[]) {\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          this.withTransfer(param);\n          break;\n        case OpKind.ORIGINATION:\n          this.withOrigination(param);\n          break;\n        case OpKind.DELEGATION:\n          this.withDelegation(param);\n          break;\n        case OpKind.ACTIVATION:\n          this.withActivation(param);\n          break;\n        default:\n          throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   *\n   * @description Forge and Inject the operation batch\n   *\n   * @param params Optionally specify the source of the operation\n   */\n  async send(params?: { source?: string }) {\n    const estimates = await this.estimator.batch(this.operations);\n    const ops: RPCOperation[] = [];\n    let i = 0;\n    for (const op of this.operations) {\n      if (isOpWithFee(op)) {\n        const estimated = await this.estimate(op, async () => estimates[i]);\n        ops.push(await this.getRPCOp({ ...op, ...estimated }));\n      } else {\n        ops.push({ ...op });\n      }\n      i++;\n    }\n    const source = (params && params.source) || (await this.signer.publicKeyHash());\n    const opBytes = await this.prepareAndForge({\n      operation: ops,\n      source,\n    });\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new BatchOperation(hash, ops, source, forgedBytes, opResponse, context);\n  }\n}\n\nexport class RPCBatchProvider {\n  constructor(private context: Context, private estimator: EstimationProvider) { }\n\n  /***\n   *\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n   *\n   * @param params List of operation to batch together\n   */\n  batch(params?: ParamsWithKind[]) {\n    const batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n}\n","import { RpcClient } from '@taquito/rpc';\nimport { Protocols } from './constants';\nimport { Forger } from './forger/interface';\nimport { RpcForger } from './forger/rpc-forger';\nimport { Injector } from './injector/interface';\nimport { RpcInjector } from './injector/rpc-injector';\nimport { Signer } from './signer/interface';\nimport { NoopSigner } from './signer/noop';\nimport { OperationFactory } from './wallet/opreation-factory';\nimport { RpcTzProvider } from './tz/rpc-tz-provider';\nimport { RPCEstimateProvider } from './contract/rpc-estimate-provider';\nimport { RpcContractProvider } from './contract/rpc-contract-provider';\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\n\nimport { Wallet, LegacyWalletProvider, WalletProvider } from './wallet';\n\nexport interface TaquitoProvider<T, K extends Array<any>> {\n  new (context: Context, ...rest: K): T;\n}\n\nexport interface Config {\n  confirmationPollingIntervalSecond?: number;\n  confirmationPollingTimeoutSecond?: number;\n  defaultConfirmationCount?: number;\n}\n\nexport const defaultConfig: Required<Config> = {\n  confirmationPollingIntervalSecond: 10,\n  defaultConfirmationCount: 1,\n  confirmationPollingTimeoutSecond: 180,\n};\n\n/**\n * @description Encapsulate common service used throughout different part of the library\n */\nexport class Context {\n  private _forger: Forger;\n  private _injector: Injector;\n  private _walletProvider: WalletProvider;\n  public readonly operationFactory: OperationFactory;\n\n  public readonly tz = new RpcTzProvider(this);\n  public readonly estimate = new RPCEstimateProvider(this);\n  public readonly contract = new RpcContractProvider(this, this.estimate);\n  public readonly batch = new RPCBatchProvider(this, this.estimate);\n  public readonly wallet = new Wallet(this);\n\n  constructor(\n    private _rpcClient: RpcClient = new RpcClient(),\n    private _signer: Signer = new NoopSigner(),\n    private _proto?: Protocols,\n    private _config?: Partial<Config>,\n    forger?: Forger,\n    injector?: Injector,\n    wallet?: WalletProvider\n  ) {\n    this.config = _config as any;\n    this._forger = forger ? forger : new RpcForger(this);\n    this._injector = injector ? injector : new RpcInjector(this);\n    this.operationFactory = new OperationFactory(this);\n    this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);\n  }\n\n  get config(): Required<Config> {\n    return this._config as any;\n  }\n\n  set config(value: Required<Config>) {\n    this._config = {\n      ...defaultConfig,\n      ...value,\n    };\n  }\n\n  get rpc(): RpcClient {\n    return this._rpcClient;\n  }\n\n  set rpc(value: RpcClient) {\n    this._rpcClient = value;\n  }\n\n  get injector() {\n    return this._injector;\n  }\n\n  set injector(value: Injector) {\n    this._injector = value;\n  }\n\n  get forger() {\n    return this._forger;\n  }\n\n  set forger(value: Forger) {\n    this._forger = value;\n  }\n\n  get signer() {\n    return this._signer;\n  }\n\n  get walletProvider() {\n    return this._walletProvider;\n  }\n\n  set walletProvider(value: WalletProvider) {\n    this._walletProvider = value;\n  }\n\n  set signer(value: Signer) {\n    this._signer = value;\n  }\n\n  set proto(value: Protocols | undefined) {\n    this._proto = value;\n  }\n\n  get proto() {\n    return this._proto;\n  }\n\n  async isAnyProtocolActive(protocol: string[] = []) {\n    if (this._proto) {\n      return protocol.includes(this._proto);\n    } else {\n      const { next_protocol } = await this.rpc.getBlockMetadata();\n      return protocol.includes(next_protocol);\n    }\n  }\n\n  /**\n   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\n   */\n  clone(): Context {\n    return new Context(this.rpc, this.signer, this.proto, this.config, this.forger, this._injector);\n  }\n}\n","import { OpFilter, FilterExpression, Filter, OpHashFilter, SourceFilter, KindFilter, DestinationFilter, OperationContent } from './interface';\n\nconst opHashFilter = (op: OperationContent, filter: OpHashFilter) => op.hash === filter.opHash;\n\nconst sourceFilter = (x: OperationContent, filter: SourceFilter) => {\n  switch (x.kind) {\n    case 'endorsement':\n      return 'metadata' in x && x.metadata.delegate === filter.source\n    case 'activate_account':\n      return 'metadata' in x && x.pkh === filter.source\n    default:\n      return 'source' in x && x.source === filter.source\n  }\n}\n\nconst kindFilter = (x: OperationContent, filter: KindFilter) => 'kind' in x && x.kind === filter.kind;\n\nconst destinationFilter = (x: OperationContent, filter: DestinationFilter) => {\n  switch (x.kind) {\n    case 'delegation':\n      return x.delegate === filter.destination;\n    case 'origination':\n      if (\n        'metadata' in x &&\n        'operation_result' in x.metadata &&\n        'originated_contracts' in x.metadata.operation_result &&\n        Array.isArray(x.metadata.operation_result.originated_contracts)\n      ) {\n        return x.metadata.operation_result.originated_contracts.some(\n          contract => contract === filter.destination\n        );\n      }\n      break;\n    case 'transaction':\n      return x.destination === filter.destination;\n    default:\n      return false;\n  }\n};\n\nexport const evaluateOpFilter = (op: OperationContent, filter: OpFilter) => {\n  if ('opHash' in filter) {\n    return opHashFilter(op, filter);\n  } else if ('source' in filter) {\n    return sourceFilter(op, filter)\n  } else if ('kind' in filter) {\n    return kindFilter(op, filter);\n  } else if ('destination' in filter) {\n    return destinationFilter(op, filter)\n  }\n\n  return false;\n};\n\nexport const evaluateExpression = (op: OperationContent, exp: FilterExpression): boolean => {\n  if (Array.isArray(exp.and)) {\n    return exp.and.every((x: OpFilter | FilterExpression) => evaluateFilter(op, x));\n  } else if (Array.isArray(exp.or)) {\n    return exp.or.some((x: OpFilter | FilterExpression) => evaluateFilter(op, x));\n  } else {\n    throw new Error('Filter expression must contains either and/or property');\n  }\n};\n\nexport const evaluateFilter = (op: OperationContent, filter: Filter): boolean => {\n  const filters: OpFilter[] | FilterExpression[] = [];\n  if (!Array.isArray(filter)) {\n    filters.push(filter as any);\n  } else {\n    filters.push(...(filter as any));\n  }\n\n  return filters.every((filterOrExp: OpFilter | FilterExpression) => {\n    if ('and' in filterOrExp || 'or' in filterOrExp) {\n      return evaluateExpression(op, filterOrExp);\n    } else {\n      return evaluateOpFilter(op, filterOrExp as OpFilter);\n    }\n  });\n};\n","import { Observable, Subscription as RXJSSubscription, Subject } from 'rxjs';\nimport { Subscription } from './interface';\nimport { takeUntil } from 'rxjs/operators';\n\nexport class ObservableSubscription<T> implements Subscription<T> {\n  private errorListeners: Array<(error: Error) => void> = [];\n  private messageListeners: Array<(data: T) => void> = [];\n  private closeListeners: Array<() => void> = [];\n  private completed$ = new Subject();\n\n  constructor(obs: Observable<T>) {\n    obs.pipe(takeUntil(this.completed$)).subscribe(\n      (data: T) => {\n        this.call(this.messageListeners, data);\n      },\n      error => {\n        this.call(this.errorListeners, error);\n      },\n      () => {\n        this.call(this.closeListeners);\n      }\n    );\n  }\n\n  private call<K>(listeners: Array<(val: K) => void>, value?: K) {\n    for (const l of listeners) {\n      try {\n        l(value!);\n      } catch (ex) {\n        console.error(ex);\n      }\n    }\n  }\n\n  private remove(listeners: Array<any>, value: any) {\n    const idx = listeners.indexOf(value);\n    if (idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  }\n\n  public on(type: 'error', cb: (error: Error) => void): void;\n  // tslint:disable-next-line: unified-signatures\n  public on(type: 'data', cb: (data: T) => void): void;\n  public on(type: 'close', cb: () => void): void;\n\n  public on(type: 'data' | 'error' | 'close', cb: any): void {\n    switch (type) {\n      case 'data':\n        this.messageListeners.push(cb);\n        break;\n      case 'error':\n        this.errorListeners.push(cb);\n        break;\n      case 'close':\n        this.closeListeners.push(cb);\n        break;\n      default:\n        throw new Error(`Trying to register on an unsupported event: ${type}`);\n    }\n  }\n\n  public off(type: 'error', cb: (error: Error) => void): void;\n  // tslint:disable-next-line: unified-signatures\n  public off(type: 'data', cb: (data: T) => void): void;\n  public off(type: 'close', cb: () => void): void;\n\n  public off(type: 'data' | 'error' | 'close', cb: any): void {\n    switch (type) {\n      case 'data':\n        this.remove(this.messageListeners, cb);\n        break;\n      case 'error':\n        this.remove(this.errorListeners, cb);\n        break;\n      case 'close':\n        this.remove(this.closeListeners, cb);\n        break;\n      default:\n        throw new Error(`Trying to unregister on an unsupported event: ${type}`);\n    }\n  }\n\n  public close() {\n    this.completed$.next();\n  }\n}\n","import { BlockResponse, OperationEntry } from '@taquito/rpc';\nimport { from, Observable, ObservableInput, timer } from 'rxjs';\nimport {\n  concatMap,\n  distinctUntilKeyChanged,\n  first,\n  map,\n  pluck,\n  publishReplay,\n  refCount,\n  switchMap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { evaluateFilter } from './filters';\nimport { Filter, SubscribeProvider, Subscription, OperationContent } from './interface';\nimport { ObservableSubscription } from './observable-subscription';\n\nconst getLastBlock = (context: Context) => {\n  return from(context.rpc.getBlock()).pipe(first());\n};\n\nconst applyFilter = (filter: Filter) =>\n  concatMap<BlockResponse, ObservableInput<OperationContent>>(block => {\n    return new Observable<OperationContent>(sub => {\n      for (const ops of block.operations) {\n        for (const op of ops) {\n          for (const content of op.contents) {\n            if (evaluateFilter({hash: op.hash, ...content}, filter)) {\n              sub.next({hash: op.hash, ...content});\n            }\n          }\n        }\n      }\n      sub.complete();\n    });\n  });\n\nexport class PollingSubscribeProvider implements SubscribeProvider {\n  private newBlock$ = timer(0, this.POLL_INTERVAL).pipe(\n    map(() => this.context),\n    switchMap(getLastBlock),\n    distinctUntilKeyChanged('hash'),\n    publishReplay(),\n    refCount()\n  );\n\n  constructor(private context: Context, public readonly POLL_INTERVAL = 20000) {}\n\n  subscribe(_filter: 'head'): Subscription<string> {\n    return new ObservableSubscription(this.newBlock$.pipe(pluck('hash')));\n  }\n\n  subscribeOperation(filter: Filter): Subscription<OperationContent> {\n    return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)));\n  }\n}\n","import { Forger, ForgeParams, ForgeResponse } from './interface';\n\nexport class ForgingMismatchError implements Error {\n  name: string = 'ForgingMismatchError';\n  message: string = 'Forging mismatch error';\n  constructor(public results: string[]) {}\n}\n\nexport class CompositeForger implements Forger {\n  constructor(private forgers: Forger[]) {\n    if (forgers.length === 0) {\n      throw new Error('At least one forger must be specified');\n    }\n  }\n\n  async forge({ branch, contents }: ForgeParams): Promise<ForgeResponse> {\n    const results = await Promise.all(\n      this.forgers.map(forger => {\n        return forger.forge({ branch, contents });\n      })\n    );\n\n    if (results.length === 0) {\n      throw new Error('At least one forger must be specified');\n    }\n\n    let lastResult: string = results.pop()!; // Assumed to be more than one since we\n    while (results.length) {\n      const currentResult = results.pop()!;\n\n      if (currentResult !== lastResult) {\n        throw new ForgingMismatchError([lastResult, currentResult]);\n      }\n      lastResult = currentResult;\n    }\n\n    return lastResult;\n  }\n}\n","import { RpcClient } from '@taquito/rpc';\nimport { importKey } from '@taquito/signer';\nimport { Protocols } from './constants';\nimport { Config, Context, TaquitoProvider } from './context';\nimport { ContractProvider, EstimationProvider } from './contract/interface';\nimport { Forger } from './forger/interface';\nimport { RpcForger } from './forger/rpc-forger';\nimport { format } from './format';\nimport { Signer } from './signer/interface';\nimport { NoopSigner } from './signer/noop';\nimport { SubscribeProvider } from './subscribe/interface';\nimport { PollingSubscribeProvider } from './subscribe/polling-provider';\nimport { TzProvider } from './tz/interface';\nimport { LegacyWalletProvider, Wallet, WalletProvider } from './wallet';\nimport { OperationFactory } from './wallet/opreation-factory';\n\nexport { MichelsonMap, UnitValue } from '@taquito/michelson-encoder';\nexport * from './constants';\nexport * from './context';\nexport { TaquitoProvider } from './context';\nexport * from './contract';\nexport * from './contract/big-map';\nexport { CompositeForger } from './forger/composite-forger';\nexport * from './forger/interface';\nexport { RpcForger } from './forger/rpc-forger';\nexport {\n  TezosOperationError,\n  TezosOperationErrorWithMessage,\n  TezosPreapplyFailureError,\n} from './operations/operation-errors';\nexport { OpKind } from './operations/types';\nexport * from './signer/interface';\nexport * from './subscribe/interface';\nexport { SubscribeProvider } from './subscribe/interface';\nexport { PollingSubscribeProvider } from './subscribe/polling-provider';\nexport * from './tz/interface';\nexport * from './wallet';\n\nexport interface SetProviderOptions {\n  forger?: Forger;\n  wallet?: WalletProvider;\n  rpc?: string | RpcClient;\n  stream?: string | SubscribeProvider;\n  signer?: Signer;\n  protocol?: Protocols;\n  config?: Config;\n}\n\n/**\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\n */\nexport class TezosToolkit {\n  private _rpcClient = new RpcClient();\n  private _stream!: SubscribeProvider;\n  private _options: SetProviderOptions = {};\n\n  private _context: Context = new Context();\n  private _wallet: Wallet = new Wallet(this._context);\n\n  public readonly format = format;\n\n  constructor() {\n    this.setProvider({ rpc: this._rpcClient });\n  }\n\n  /**\n   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\n   *\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\n   *\n   * @example Tezos.setProvider({rpc: 'https://api.tez.ie/rpc/mainnet', signer: new InMemorySigner.fromSecretKey(edsk...)})\n   * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})\n   *\n   */\n\n  setProvider({ rpc, stream, signer, protocol, config, forger, wallet }: SetProviderOptions) {\n    this.setRpcProvider(rpc);\n    this.setStreamProvider(stream);\n    this.setSignerProvider(signer);\n    this.setForgerProvider(forger);\n    this.setWalletProvider(wallet);\n\n    this._context.proto = protocol;\n    this._context.config = config as Required<Config>;\n  }\n\n  /**\n   * @description Sets signer provider on the Tezos Taquito instance.\n   *\n   * @param options signer to use to interact with the Tezos network\n   *\n   * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))\n   *\n   */\n  setSignerProvider(signer?: SetProviderOptions['signer']) {\n    if (!this._options.signer && typeof signer === 'undefined') {\n      this._context.signer = new NoopSigner();\n      this._options.signer = signer;\n    } else if (typeof signer !== 'undefined') {\n      this._context.signer = signer;\n      this._options.signer = signer;\n    }\n  }\n\n  /**\n   * @description Sets rpc provider on the Tezos Taquito instance\n   *\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\n   *\n   * @example Tezos.setRpcProvider('https://api.tez.ie/rpc/mainnet')\n   *\n   */\n  setRpcProvider(rpc?: SetProviderOptions['rpc']) {\n    if (typeof rpc === 'string') {\n      this._rpcClient = new RpcClient(rpc);\n    } else if (rpc instanceof RpcClient) {\n      this._rpcClient = rpc;\n    } else if (this._options.rpc === undefined) {\n      this._rpcClient = new RpcClient();\n    }\n    this._options.rpc = this._rpcClient;\n    this._context.rpc = this._rpcClient;\n  }\n\n  /**\n   * @description Sets forger provider on the Tezos Taquito instance\n   *\n   * @param options forger to use to interact with the Tezos network\n   *\n   * @example Tezos.setForgerProvider(localForger)\n   *\n   */\n  setForgerProvider(forger?: SetProviderOptions['forger']) {\n    const f = typeof forger === 'undefined' ? this.getFactory(RpcForger)() : forger;\n    this._options.forger = f;\n    this._context.forger = f;\n  }\n\n  /**\n   * @description Sets stream provider on the Tezos Taquito instance\n   *\n   * @param options stream to use to interact with the Tezos network\n   *\n   * @example Tezos.setStreamProvider(...)\n   *\n   */\n  setStreamProvider(stream?: SetProviderOptions['stream']) {\n    if (typeof stream === 'string') {\n      this._stream = new PollingSubscribeProvider(new Context(new RpcClient(stream)));\n    } else if (typeof stream !== 'undefined') {\n      this._stream = stream;\n    } else if (this._options.stream === undefined) {\n      this._stream = this.getFactory(PollingSubscribeProvider)();\n    }\n    this._options.stream = stream;\n  }\n\n  /**\n   * @description Sets wallet provider on the Tezos Taquito instance\n   *\n   * @param options wallet to use to interact with the Tezos network\n   *\n   * @example Tezos.setWalletProvider(...)\n   *\n   */\n  setWalletProvider(wallet?: SetProviderOptions['wallet']) {\n    if (!this._options.wallet && typeof wallet === 'undefined') {\n      const w = this.getFactory(LegacyWalletProvider)();\n      this._options.wallet = w;\n      this._context.walletProvider = w;\n    } else if (typeof wallet !== 'undefined') {\n      this._options.wallet = wallet;\n      this._context.walletProvider = wallet;\n    }\n  }\n\n  /**\n   * @description Provide access to tezos account management\n   */\n  get tz(): TzProvider {\n    return this._context.tz;\n  }\n\n  /**\n   * @description Provide access to smart contract utilities\n   */\n  get contract(): ContractProvider {\n    return this._context.contract;\n  }\n\n  get wallet(): Wallet {\n    return this._wallet;\n  }\n\n  get operation(): OperationFactory {\n    return this._context.operationFactory;\n  }\n\n  public batch = this._context.batch.batch.bind(this._context.batch);\n\n  /**\n   * @description Provide access to operation estimation utilities\n   */\n  get estimate(): EstimationProvider {\n    return this._context.estimate;\n  }\n\n  /**\n   * @description Provide access to streaming utilities backed by an streamer implementation\n   */\n  get stream(): SubscribeProvider {\n    return this._stream;\n  }\n\n  /**\n   * @description Provide access to the currently used rpc client\n   */\n  get rpc(): RpcClient {\n    return this._context.rpc;\n  }\n\n  /**\n   * @description Provide access to the currently used signer\n   */\n  get signer() {\n    return this._context.signer;\n  }\n\n  /**\n   * @deprecated Deprecated in favor of setting the signer provider with @taquito/signer importKey\n   */\n  importKey(privateKeyOrEmail: string, passphrase?: string, mnemonic?: string, secret?: string) {\n    return importKey(this, privateKeyOrEmail, passphrase, mnemonic, secret);\n  }\n\n  getFactory<T, K extends Array<any>>(ctor: TaquitoProvider<T, K>) {\n    return (...args: K) => {\n      return new ctor(this._context, ...args);\n    };\n  }\n}\n\n/**\n * @description Default Tezos toolkit instance\n */\nexport const Tezos = new TezosToolkit();\n"]},"metadata":{},"sourceType":"module"}