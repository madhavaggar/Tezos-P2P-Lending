{"ast":null,"code":"import sodium from 'libsodium-wrappers';\nimport { isValidPrefix, b58cdecode, prefix, buf2hex, b58cencode, hex2buf, mergebuf } from '@taquito/utils';\nimport toBuffer from 'typedarray-to-buffer';\nimport elliptic from 'elliptic';\nimport pbkdf2 from 'pbkdf2';\nimport { mnemonicToSeedSync } from 'bip39';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n/**\r\n * @description Provide signing logic for ed25519 curve based key (tz1)\r\n */\n\n\nvar Tz1 =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param key Encoded private key\r\n   * @param encrypted Is the private key encrypted\r\n   * @param decrypt Decrypt function\r\n   */\n  function Tz1(key, encrypted, decrypt) {\n    this.key = key;\n    var keyPrefix = key.substr(0, encrypted ? 5 : 4);\n\n    if (!isValidPrefix(keyPrefix)) {\n      throw new Error('key contains invalid prefix');\n    }\n\n    this._key = decrypt(b58cdecode(this.key, prefix[keyPrefix]));\n    this._publicKey = this._key.slice(32);\n\n    if (!this._key) {\n      throw new Error('Unable to decode key');\n    }\n\n    this.isInit = this.init();\n  }\n\n  Tz1.prototype.init = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, publicKey, privateKey;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , sodium.ready];\n\n          case 1:\n            _b.sent();\n\n            if (this._key.length !== 64) {\n              _a = sodium.crypto_sign_seed_keypair(new Uint8Array(this._key), 'uint8array'), publicKey = _a.publicKey, privateKey = _a.privateKey;\n              this._publicKey = publicKey;\n              this._key = privateKey;\n            }\n\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @param bytes Bytes to sign\r\n   * @param bytesHash Blake2b hash of the bytes to sign\r\n   */\n\n\n  Tz1.prototype.sign = function (bytes, bytesHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signature, signatureBuffer, sbytes;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.isInit];\n\n          case 1:\n            _a.sent();\n\n            signature = sodium.crypto_sign_detached(new Uint8Array(bytesHash), new Uint8Array(this._key));\n            signatureBuffer = toBuffer(signature);\n            sbytes = bytes + buf2hex(signatureBuffer);\n            return [2\n            /*return*/\n            , {\n              bytes: bytes,\n              sig: b58cencode(signature, prefix.sig),\n              prefixSig: b58cencode(signature, prefix.edsig),\n              sbytes: sbytes\n            }];\n        }\n      });\n    });\n  };\n  /**\r\n   * @returns Encoded public key\r\n   */\n\n\n  Tz1.prototype.publicKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.isInit];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , b58cencode(this._publicKey, prefix['edpk'])];\n        }\n      });\n    });\n  };\n  /**\r\n   * @returns Encoded public key hash\r\n   */\n\n\n  Tz1.prototype.publicKeyHash = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.isInit];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , sodium.ready];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , b58cencode(sodium.crypto_generichash(20, new Uint8Array(this._publicKey)), prefix.tz1)];\n        }\n      });\n    });\n  };\n  /**\r\n   * @returns Encoded private key\r\n   */\n\n\n  Tz1.prototype.secretKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, privateKey;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.isInit];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , sodium.ready];\n\n          case 2:\n            _a.sent();\n\n            key = this._key;\n            privateKey = sodium.crypto_sign_seed_keypair(new Uint8Array(key).slice(0, 32), 'uint8array').privateKey;\n            key = toBuffer(privateKey);\n            return [2\n            /*return*/\n            , b58cencode(key, prefix[\"edsk\"])];\n        }\n      });\n    });\n  };\n\n  return Tz1;\n}();\n\nvar pref = {\n  p256: {\n    pk: prefix['p2pk'],\n    sk: prefix['p2sk'],\n    pkh: prefix.tz3,\n    sig: prefix.p2sig\n  },\n  secp256k1: {\n    pk: prefix['sppk'],\n    sk: prefix['spsk'],\n    pkh: prefix.tz2,\n    sig: prefix.spsig\n  }\n};\n/**\r\n * @description Provide signing logic for elliptic curve based key (tz2, tz3)\r\n */\n\nvar ECKey =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param curve Curve to use with the key\r\n   * @param key Encoded private key\r\n   * @param encrypted Is the private key encrypted\r\n   * @param decrypt Decrypt function\r\n   */\n  function ECKey(curve, key, encrypted, decrypt) {\n    this.curve = curve;\n    this.key = key;\n    var keyPrefix = key.substr(0, encrypted ? 5 : 4);\n\n    if (!isValidPrefix(keyPrefix)) {\n      throw new Error('key contains invalid prefix');\n    }\n\n    this._key = decrypt(b58cdecode(this.key, prefix[keyPrefix]));\n    var keyPair = new elliptic.ec(this.curve).keyFromPrivate(this._key);\n    var pref = keyPair.getPublic().getY().toArray()[31] % 2 ? 3 : 2;\n    var pad = new Array(32).fill(0);\n    this._publicKey = toBuffer(new Uint8Array([pref].concat(pad.concat(keyPair.getPublic().getX().toArray()).slice(-32))));\n  }\n  /**\r\n   *\r\n   * @param bytes Bytes to sign\r\n   * @param bytesHash Blake2b hash of the bytes to sign\r\n   */\n\n\n  ECKey.prototype.sign = function (bytes, bytesHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, sig, signature, sbytes;\n      return __generator(this, function (_a) {\n        key = new elliptic.ec(this.curve).keyFromPrivate(this._key);\n        sig = key.sign(bytesHash, {\n          canonical: true\n        });\n        signature = sig.r.toString('hex', 64) + sig.s.toString('hex', 64);\n        sbytes = bytes + signature;\n        return [2\n        /*return*/\n        , {\n          bytes: bytes,\n          sig: b58cencode(signature, prefix.sig),\n          prefixSig: b58cencode(signature, pref[this.curve].sig),\n          sbytes: sbytes\n        }];\n      });\n    });\n  };\n  /**\r\n   * @returns Encoded public key\r\n   */\n\n\n  ECKey.prototype.publicKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , b58cencode(this._publicKey, pref[this.curve].pk)];\n      });\n    });\n  };\n  /**\r\n   * @returns Encoded public key hash\r\n   */\n\n\n  ECKey.prototype.publicKeyHash = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , sodium.ready];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , b58cencode(sodium.crypto_generichash(20, new Uint8Array(this._publicKey)), pref[this.curve].pkh)];\n        }\n      });\n    });\n  };\n  /**\r\n   * @returns Encoded private key\r\n   */\n\n\n  ECKey.prototype.secretKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var key;\n      return __generator(this, function (_a) {\n        key = this._key;\n        return [2\n        /*return*/\n        , b58cencode(key, pref[this.curve].sk)];\n      });\n    });\n  };\n\n  return ECKey;\n}();\n/**\r\n * @description Tz3 key class using the p256 curve\r\n */\n\n\nvar Tz3 = ECKey.bind(null, 'p256');\n/**\r\n * @description Tz3 key class using the secp256k1 curve\r\n */\n\nvar Tz2 = ECKey.bind(null, 'secp256k1');\n/**\r\n *\r\n * @description Import a key to sign operation with the side-effect of setting the Tezos instance to use the InMemorySigner provider\r\n *\r\n * @param toolkit The toolkit instance to attach a signer\r\n * @param privateKeyOrEmail Key to load in memory\r\n * @param passphrase If the key is encrypted passphrase to decrypt it\r\n * @param mnemonic Faucet mnemonic\r\n * @param secret Faucet secret\r\n */\n\nfunction importKey(toolkit, privateKeyOrEmail, passphrase, mnemonic, secret) {\n  return __awaiter(this, void 0, void 0, function () {\n    var signer, pkh, op, ex_1, isInvalidActivationError, signer;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!(privateKeyOrEmail && passphrase && mnemonic && secret)) return [3\n          /*break*/\n          , 8];\n          signer = InMemorySigner.fromFundraiser(privateKeyOrEmail, passphrase, mnemonic);\n          toolkit.setProvider({\n            signer: signer\n          });\n          return [4\n          /*yield*/\n          , signer.publicKeyHash()];\n\n        case 1:\n          pkh = _a.sent();\n          op = void 0;\n          _a.label = 2;\n\n        case 2:\n          _a.trys.push([2, 4,, 5]);\n\n          return [4\n          /*yield*/\n          , toolkit.tz.activate(pkh, secret)];\n\n        case 3:\n          op = _a.sent();\n          return [3\n          /*break*/\n          , 5];\n\n        case 4:\n          ex_1 = _a.sent();\n          isInvalidActivationError = ex_1 && ex_1.body && /Invalid activation/.test(ex_1.body);\n\n          if (!isInvalidActivationError) {\n            throw ex_1;\n          }\n\n          return [3\n          /*break*/\n          , 5];\n\n        case 5:\n          if (!op) return [3\n          /*break*/\n          , 7];\n          return [4\n          /*yield*/\n          , op.confirmation()];\n\n        case 6:\n          _a.sent();\n\n          _a.label = 7;\n\n        case 7:\n          return [3\n          /*break*/\n          , 10];\n\n        case 8:\n          return [4\n          /*yield*/\n          , InMemorySigner.fromSecretKey(privateKeyOrEmail, passphrase)];\n\n        case 9:\n          signer = _a.sent();\n          toolkit.setProvider({\n            signer: signer\n          });\n          _a.label = 10;\n\n        case 10:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n/**\r\n * @description A local implementation of the signer. Will represent a Tezos account and be able to produce signature in its behalf\r\n *\r\n * @warn If running in production and dealing with tokens that have real value, it is strongly recommended to use a HSM backed signer so that private key material is not stored in memory or on disk\r\n *\r\n * @warn Calling this constructor directly is discouraged as it do not await for sodium library to be loaded.\r\n *\r\n * Consider doing:\r\n *\r\n * ```const sodium = require('libsodium-wrappers'); await sodium.ready;```\r\n *\r\n * The recommended usage is to use InMemorySigner.fromSecretKey('edsk', 'passphrase')\r\n */\n\n\nvar InMemorySigner =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param key Encoded private key\r\n   * @param passphrase Passphrase to decrypt the private key if it is encrypted\r\n   *\r\n   */\n  function InMemorySigner(key, passphrase) {\n    var encrypted = key.substring(2, 3) === 'e';\n\n    var decrypt = function (k) {\n      return k;\n    };\n\n    if (encrypted) {\n      if (!passphrase) {\n        throw new Error('Encrypted key provided without a passphrase.');\n      }\n\n      decrypt = function (constructedKey) {\n        var salt = toBuffer(constructedKey.slice(0, 8));\n        var encryptedSk = constructedKey.slice(8);\n        var encryptionKey = pbkdf2.pbkdf2Sync(passphrase, salt, 32768, 32, 'sha512');\n        return sodium.crypto_secretbox_open_easy(new Uint8Array(encryptedSk), new Uint8Array(24), new Uint8Array(encryptionKey));\n      };\n    }\n\n    switch (key.substr(0, 4)) {\n      case 'edes':\n      case 'edsk':\n        this._key = new Tz1(key, encrypted, decrypt);\n        break;\n\n      case 'spsk':\n      case 'spes':\n        this._key = new Tz2(key, encrypted, decrypt);\n        break;\n\n      case 'p2sk':\n      case 'p2es':\n        this._key = new Tz3(key, encrypted, decrypt);\n        break;\n\n      default:\n        throw new Error('Unsupported key type');\n    }\n  }\n\n  InMemorySigner.fromFundraiser = function (email, password, mnemonic) {\n    var seed = mnemonicToSeedSync(mnemonic, \"\" + email + password);\n    var key = b58cencode(seed.slice(0, 32), prefix.edsk2);\n    return new InMemorySigner(key);\n  };\n\n  InMemorySigner.fromSecretKey = function (key, passphrase) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , sodium.ready];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , new InMemorySigner(key, passphrase)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @param bytes Bytes to sign\r\n   * @param watermark Watermark to append to the bytes\r\n   */\n\n\n  InMemorySigner.prototype.sign = function (bytes, watermark) {\n    return __awaiter(this, void 0, void 0, function () {\n      var bb, bytesHash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            bb = hex2buf(bytes);\n\n            if (typeof watermark !== 'undefined') {\n              bb = mergebuf(watermark, bb);\n            } // Ensure sodium is ready before calling crypto_generichash otherwise the function do not exists\n\n\n            return [4\n            /*yield*/\n            , sodium.ready];\n\n          case 1:\n            // Ensure sodium is ready before calling crypto_generichash otherwise the function do not exists\n            _a.sent();\n\n            bytesHash = toBuffer(sodium.crypto_generichash(32, bb));\n            return [2\n            /*return*/\n            , this._key.sign(bytes, bytesHash)];\n        }\n      });\n    });\n  };\n  /**\r\n   * @returns Encoded public key\r\n   */\n\n\n  InMemorySigner.prototype.publicKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this._key.publicKey()];\n      });\n    });\n  };\n  /**\r\n   * @returns Encoded public key hash\r\n   */\n\n\n  InMemorySigner.prototype.publicKeyHash = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this._key.publicKeyHash()];\n      });\n    });\n  };\n  /**\r\n   * @returns Encoded private key\r\n   */\n\n\n  InMemorySigner.prototype.secretKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this._key.secretKey()];\n      });\n    });\n  };\n\n  return InMemorySigner;\n}();\n\nexport { InMemorySigner, importKey };","map":{"version":3,"sources":["../src/ed-key.ts","../src/ec-key.ts","../src/import-key.ts","../src/taquito-signer.ts"],"names":[],"mappings":"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","sourcesContent":["import sodium from 'libsodium-wrappers';\nimport { b58cencode, b58cdecode, prefix, buf2hex, Prefix, isValidPrefix } from '@taquito/utils';\nimport toBuffer from 'typedarray-to-buffer';\n\n/**\n * @description Provide signing logic for ed25519 curve based key (tz1)\n */\nexport class Tz1 {\n  private _key: Uint8Array;\n  private _publicKey: Uint8Array;\n  private isInit: Promise<boolean>;\n\n  /**\n   *\n   * @param key Encoded private key\n   * @param encrypted Is the private key encrypted\n   * @param decrypt Decrypt function\n   */\n  constructor(private key: string, encrypted: boolean, decrypt: (k: any) => any) {\n    const keyPrefix = key.substr(0, encrypted ? 5 : 4);\n    if (!isValidPrefix(keyPrefix)) {\n      throw new Error('key contains invalid prefix');\n    }\n\n    this._key = decrypt(b58cdecode(this.key, prefix[keyPrefix]));\n    this._publicKey = this._key.slice(32);\n\n    if (!this._key) {\n      throw new Error('Unable to decode key');\n    }\n\n    this.isInit = this.init();\n  }\n\n  private async init() {\n    await sodium.ready;\n    if (this._key.length !== 64) {\n      const { publicKey, privateKey } = sodium.crypto_sign_seed_keypair(\n        new Uint8Array(this._key),\n        'uint8array'\n      );\n      this._publicKey = publicKey;\n      this._key = privateKey;\n    }\n    return true;\n  }\n\n  /**\n   *\n   * @param bytes Bytes to sign\n   * @param bytesHash Blake2b hash of the bytes to sign\n   */\n  async sign(bytes: string, bytesHash: Uint8Array) {\n    await this.isInit;\n    const signature = sodium.crypto_sign_detached(\n      new Uint8Array(bytesHash),\n      new Uint8Array(this._key)\n    );\n    const signatureBuffer = toBuffer(signature);\n    const sbytes = bytes + buf2hex(signatureBuffer);\n\n    return {\n      bytes,\n      sig: b58cencode(signature, prefix.sig),\n      prefixSig: b58cencode(signature, prefix.edsig),\n      sbytes,\n    };\n  }\n\n  /**\n   * @returns Encoded public key\n   */\n  async publicKey(): Promise<string> {\n    await this.isInit;\n    return b58cencode(this._publicKey, prefix['edpk']);\n  }\n\n  /**\n   * @returns Encoded public key hash\n   */\n  async publicKeyHash(): Promise<string> {\n    await this.isInit;\n    await sodium.ready;\n    return b58cencode(sodium.crypto_generichash(20, new Uint8Array(this._publicKey)), prefix.tz1);\n  }\n\n  /**\n   * @returns Encoded private key\n   */\n  async secretKey(): Promise<string> {\n    await this.isInit;\n    await sodium.ready;\n    let key = this._key;\n    const { privateKey } = sodium.crypto_sign_seed_keypair(\n      new Uint8Array(key).slice(0, 32),\n      'uint8array'\n    );\n    key = toBuffer(privateKey);\n\n    return b58cencode(key, prefix[`edsk`]);\n  }\n}\n","import sodium from 'libsodium-wrappers';\nimport { b58cencode, b58cdecode, prefix, buf2hex, Prefix, isValidPrefix } from '@taquito/utils';\nimport toBuffer from 'typedarray-to-buffer';\nimport elliptic from 'elliptic';\n\nconst pref = {\n  p256: {\n    pk: prefix['p2pk'],\n    sk: prefix['p2sk'],\n    pkh: prefix.tz3,\n    sig: prefix.p2sig,\n  },\n  secp256k1: {\n    pk: prefix['sppk'],\n    sk: prefix['spsk'],\n    pkh: prefix.tz2,\n    sig: prefix.spsig,\n  },\n};\n\n/**\n * @description Provide signing logic for elliptic curve based key (tz2, tz3)\n */\nexport class ECKey {\n  private _key: Uint8Array;\n  private _publicKey: Uint8Array;\n\n  /**\n   *\n   * @param curve Curve to use with the key\n   * @param key Encoded private key\n   * @param encrypted Is the private key encrypted\n   * @param decrypt Decrypt function\n   */\n  constructor(\n    private curve: 'p256' | 'secp256k1',\n    private key: string,\n    encrypted: boolean,\n    decrypt: (k: any) => any\n  ) {\n    const keyPrefix = key.substr(0, encrypted ? 5 : 4);\n    if (!isValidPrefix(keyPrefix)) {\n      throw new Error('key contains invalid prefix');\n    }\n\n    this._key = decrypt(b58cdecode(this.key, prefix[keyPrefix]));\n    const keyPair = new elliptic.ec(this.curve).keyFromPrivate(this._key);\n    const pref = keyPair.getPublic().getY().toArray()[31] % 2 ? 3 : 2;\n    const pad = new Array(32).fill(0);\n    this._publicKey = toBuffer(\n      new Uint8Array([pref].concat(pad.concat(keyPair.getPublic().getX().toArray()).slice(-32)))\n    );\n  }\n\n  /**\n   *\n   * @param bytes Bytes to sign\n   * @param bytesHash Blake2b hash of the bytes to sign\n   */\n  async sign(bytes: string, bytesHash: Uint8Array) {\n    const key = new elliptic.ec(this.curve).keyFromPrivate(this._key);\n    const sig = key.sign(bytesHash, { canonical: true });\n    const signature = sig.r.toString('hex', 64) + sig.s.toString('hex', 64);\n\n    const sbytes = bytes + signature;\n    return {\n      bytes,\n      sig: b58cencode(signature, prefix.sig),\n      prefixSig: b58cencode(signature, pref[this.curve].sig),\n      sbytes,\n    };\n  }\n\n  /**\n   * @returns Encoded public key\n   */\n  async publicKey(): Promise<string> {\n    return b58cencode(this._publicKey, pref[this.curve].pk);\n  }\n\n  /**\n   * @returns Encoded public key hash\n   */\n  async publicKeyHash(): Promise<string> {\n    await sodium.ready;\n    return b58cencode(\n      sodium.crypto_generichash(20, new Uint8Array(this._publicKey)),\n      pref[this.curve].pkh\n    );\n  }\n\n  /**\n   * @returns Encoded private key\n   */\n  async secretKey(): Promise<string> {\n    let key = this._key;\n\n    return b58cencode(key, pref[this.curve].sk);\n  }\n}\n\n/**\n * @description Tz3 key class using the p256 curve\n */\nexport const Tz3 = ECKey.bind(null, 'p256');\n\n/**\n * @description Tz3 key class using the secp256k1 curve\n */\nexport const Tz2 = ECKey.bind(null, 'secp256k1');\n","import { InMemorySigner } from './taquito-signer';\n\n/**\n *\n * @description Import a key to sign operation with the side-effect of setting the Tezos instance to use the InMemorySigner provider\n *\n * @param toolkit The toolkit instance to attach a signer\n * @param privateKeyOrEmail Key to load in memory\n * @param passphrase If the key is encrypted passphrase to decrypt it\n * @param mnemonic Faucet mnemonic\n * @param secret Faucet secret\n */\nexport async function importKey(\n  toolkit: any,\n  privateKeyOrEmail: string,\n  passphrase?: string,\n  mnemonic?: string,\n  secret?: string\n) {\n  if (privateKeyOrEmail && passphrase && mnemonic && secret) {\n    const signer = InMemorySigner.fromFundraiser(privateKeyOrEmail, passphrase, mnemonic);\n    toolkit.setProvider({ signer });\n    const pkh = await signer.publicKeyHash();\n    let op;\n    try {\n      op = await toolkit.tz.activate(pkh, secret);\n    } catch (ex) {\n      const isInvalidActivationError = ex && ex.body && /Invalid activation/.test(ex.body);\n      if (!isInvalidActivationError) {\n        throw ex;\n      }\n    }\n    if (op) {\n      await op.confirmation();\n    }\n  } else {\n    // Fallback to regular import\n    const signer = await InMemorySigner.fromSecretKey(privateKeyOrEmail, passphrase);\n    toolkit.setProvider({ signer });\n  }\n}\n","import sodium from 'libsodium-wrappers';\nimport { hex2buf, mergebuf, b58cencode, prefix } from '@taquito/utils';\nimport toBuffer from 'typedarray-to-buffer';\nimport { Tz1 } from './ed-key';\nimport { Tz2, ECKey, Tz3 } from './ec-key';\nimport pbkdf2 from 'pbkdf2';\nimport { mnemonicToSeedSync } from 'bip39';\n\nexport * from './import-key';\n\n/**\n * @description A local implementation of the signer. Will represent a Tezos account and be able to produce signature in its behalf\n *\n * @warn If running in production and dealing with tokens that have real value, it is strongly recommended to use a HSM backed signer so that private key material is not stored in memory or on disk\n *\n * @warn Calling this constructor directly is discouraged as it do not await for sodium library to be loaded.\n *\n * Consider doing:\n *\n * ```const sodium = require('libsodium-wrappers'); await sodium.ready;```\n *\n * The recommended usage is to use InMemorySigner.fromSecretKey('edsk', 'passphrase')\n */\nexport class InMemorySigner {\n  private _key!: Tz1 | ECKey;\n\n  static fromFundraiser(email: string, password: string, mnemonic: string) {\n    let seed = mnemonicToSeedSync(mnemonic, `${email}${password}`);\n    const key = b58cencode(seed.slice(0, 32), prefix.edsk2);\n    return new InMemorySigner(key);\n  }\n\n  static async fromSecretKey(key: string, passphrase?: string) {\n    await sodium.ready;\n    return new InMemorySigner(key, passphrase);\n  }\n\n  /**\n   *\n   * @param key Encoded private key\n   * @param passphrase Passphrase to decrypt the private key if it is encrypted\n   *\n   */\n  constructor(key: string, passphrase?: string) {\n    const encrypted = key.substring(2, 3) === 'e';\n\n    let decrypt = (k: any) => k;\n\n    if (encrypted) {\n      if (!passphrase) {\n        throw new Error('Encrypted key provided without a passphrase.');\n      }\n\n      decrypt = (constructedKey: Uint8Array) => {\n        const salt = toBuffer(constructedKey.slice(0, 8));\n        const encryptedSk = constructedKey.slice(8);\n        const encryptionKey = pbkdf2.pbkdf2Sync(passphrase, salt, 32768, 32, 'sha512');\n\n        return sodium.crypto_secretbox_open_easy(\n          new Uint8Array(encryptedSk),\n          new Uint8Array(24),\n          new Uint8Array(encryptionKey)\n        );\n      };\n    }\n\n    switch (key.substr(0, 4)) {\n      case 'edes':\n      case 'edsk':\n        this._key = new Tz1(key, encrypted, decrypt);\n        break;\n      case 'spsk':\n      case 'spes':\n        this._key = new Tz2(key, encrypted, decrypt);\n        break;\n      case 'p2sk':\n      case 'p2es':\n        this._key = new Tz3(key, encrypted, decrypt);\n        break;\n      default:\n        throw new Error('Unsupported key type');\n    }\n  }\n\n  /**\n   *\n   * @param bytes Bytes to sign\n   * @param watermark Watermark to append to the bytes\n   */\n  async sign(bytes: string, watermark?: Uint8Array) {\n    let bb = hex2buf(bytes);\n    if (typeof watermark !== 'undefined') {\n      bb = mergebuf(watermark, bb);\n    }\n\n    // Ensure sodium is ready before calling crypto_generichash otherwise the function do not exists\n    await sodium.ready;\n    const bytesHash = toBuffer(sodium.crypto_generichash(32, bb));\n\n    return this._key.sign(bytes, bytesHash);\n  }\n\n  /**\n   * @returns Encoded public key\n   */\n  async publicKey(): Promise<string> {\n    return this._key.publicKey();\n  }\n\n  /**\n   * @returns Encoded public key hash\n   */\n  async publicKeyHash(): Promise<string> {\n    return this._key.publicKeyHash();\n  }\n\n  /**\n   * @returns Encoded private key\n   */\n  async secretKey(): Promise<string> {\n    return this._key.secretKey();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}