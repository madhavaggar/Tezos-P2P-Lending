{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bip39 = __importStar(require(\"bip39\"));\n\nconst TezosMessageUtil_1 = require(\"../../chain/tezos/TezosMessageUtil\");\n\nconst KeyStore_1 = require(\"../../types/wallet/KeyStore\");\n\nconst CryptoUtils_1 = require(\"../../utils/CryptoUtils\");\n\nvar TezosWalletUtil;\n\n(function (TezosWalletUtil) {\n  function unlockFundraiserIdentity(mnemonic, email, password, pkh) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield getKeysFromMnemonicAndPassphrase(mnemonic, email + password, KeyStore_1.StoreType.Fundraiser, pkh);\n    });\n  }\n\n  TezosWalletUtil.unlockFundraiserIdentity = unlockFundraiserIdentity;\n\n  function restoreIdentityWithSecretKey(keyString) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const secretKey = TezosMessageUtil_1.TezosMessageUtils.writeKeyWithHint(keyString, 'edsk');\n      const keys = yield CryptoUtils_1.CryptoUtils.recoverPublicKey(secretKey);\n      const publicKey = TezosMessageUtil_1.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');\n      const publicKeyHash = TezosMessageUtil_1.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');\n      return {\n        publicKey,\n        privateKey: keyString,\n        publicKeyHash,\n        seed: '',\n        storeType: KeyStore_1.StoreType.Mnemonic\n      };\n    });\n  }\n\n  TezosWalletUtil.restoreIdentityWithSecretKey = restoreIdentityWithSecretKey;\n\n  function generateMnemonic(strength = 256) {\n    return bip39.generateMnemonic(strength);\n  }\n\n  TezosWalletUtil.generateMnemonic = generateMnemonic;\n\n  function unlockIdentityWithMnemonic(mnemonic, passphrase = '') {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield getKeysFromMnemonicAndPassphrase(mnemonic, passphrase, KeyStore_1.StoreType.Mnemonic);\n    });\n  }\n\n  TezosWalletUtil.unlockIdentityWithMnemonic = unlockIdentityWithMnemonic;\n\n  function getKeysFromMnemonicAndPassphrase(mnemonic, passphrase, storeType, pkh) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (![12, 15, 18, 21, 24].includes(mnemonic.split(' ').length)) {\n        throw new Error('Invalid mnemonic length.');\n      }\n\n      if (!bip39.validateMnemonic(mnemonic)) {\n        throw new Error('The given mnemonic could not be validated.');\n      }\n\n      const seed = (yield bip39.mnemonicToSeed(mnemonic, passphrase)).slice(0, 32);\n      const keys = yield CryptoUtils_1.CryptoUtils.generateKeys(seed);\n      const privateKey = TezosMessageUtil_1.TezosMessageUtils.readKeyWithHint(keys.privateKey, 'edsk');\n      const publicKey = TezosMessageUtil_1.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');\n      const publicKeyHash = TezosMessageUtil_1.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');\n\n      if (!!pkh && publicKeyHash !== pkh) {\n        throw new Error('The given mnemonic and passphrase do not correspond to the applied public key hash');\n      }\n\n      return {\n        publicKey,\n        privateKey,\n        publicKeyHash,\n        seed: '',\n        storeType\n      };\n    });\n  }\n\n  TezosWalletUtil.getKeysFromMnemonicAndPassphrase = getKeysFromMnemonicAndPassphrase;\n\n  function signText(keyStore, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const privateKey = TezosMessageUtil_1.TezosMessageUtils.writeKeyWithHint(keyStore.privateKey, 'edsk');\n      const messageSig = yield CryptoUtils_1.CryptoUtils.signDetached(Buffer.from(message, 'utf8'), privateKey);\n      return TezosMessageUtil_1.TezosMessageUtils.readSignatureWithHint(messageSig, 'edsig');\n    });\n  }\n\n  TezosWalletUtil.signText = signText;\n\n  function checkSignature(signature, message, publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const sig = TezosMessageUtil_1.TezosMessageUtils.writeSignatureWithHint(signature, 'edsig');\n      const pk = TezosMessageUtil_1.TezosMessageUtils.writeKeyWithHint(publicKey, 'edpk');\n      return yield CryptoUtils_1.CryptoUtils.checkSignature(sig, Buffer.from(message, 'utf8'), pk);\n    });\n  }\n\n  TezosWalletUtil.checkSignature = checkSignature;\n})(TezosWalletUtil = exports.TezosWalletUtil || (exports.TezosWalletUtil = {}));","map":{"version":3,"sources":["../../../src/identity/tezos/TezosWalletUtil.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bip39 = __importStar(require(\"bip39\"));\nconst TezosMessageUtil_1 = require(\"../../chain/tezos/TezosMessageUtil\");\nconst KeyStore_1 = require(\"../../types/wallet/KeyStore\");\nconst CryptoUtils_1 = require(\"../../utils/CryptoUtils\");\nvar TezosWalletUtil;\n(function (TezosWalletUtil) {\n    function unlockFundraiserIdentity(mnemonic, email, password, pkh) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield getKeysFromMnemonicAndPassphrase(mnemonic, email + password, KeyStore_1.StoreType.Fundraiser, pkh);\n        });\n    }\n    TezosWalletUtil.unlockFundraiserIdentity = unlockFundraiserIdentity;\n    function restoreIdentityWithSecretKey(keyString) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const secretKey = TezosMessageUtil_1.TezosMessageUtils.writeKeyWithHint(keyString, 'edsk');\n            const keys = yield CryptoUtils_1.CryptoUtils.recoverPublicKey(secretKey);\n            const publicKey = TezosMessageUtil_1.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');\n            const publicKeyHash = TezosMessageUtil_1.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');\n            return { publicKey, privateKey: keyString, publicKeyHash, seed: '', storeType: KeyStore_1.StoreType.Mnemonic };\n        });\n    }\n    TezosWalletUtil.restoreIdentityWithSecretKey = restoreIdentityWithSecretKey;\n    function generateMnemonic(strength = 256) {\n        return bip39.generateMnemonic(strength);\n    }\n    TezosWalletUtil.generateMnemonic = generateMnemonic;\n    function unlockIdentityWithMnemonic(mnemonic, passphrase = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield getKeysFromMnemonicAndPassphrase(mnemonic, passphrase, KeyStore_1.StoreType.Mnemonic);\n        });\n    }\n    TezosWalletUtil.unlockIdentityWithMnemonic = unlockIdentityWithMnemonic;\n    function getKeysFromMnemonicAndPassphrase(mnemonic, passphrase, storeType, pkh) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (![12, 15, 18, 21, 24].includes(mnemonic.split(' ').length)) {\n                throw new Error('Invalid mnemonic length.');\n            }\n            if (!bip39.validateMnemonic(mnemonic)) {\n                throw new Error('The given mnemonic could not be validated.');\n            }\n            const seed = (yield bip39.mnemonicToSeed(mnemonic, passphrase)).slice(0, 32);\n            const keys = yield CryptoUtils_1.CryptoUtils.generateKeys(seed);\n            const privateKey = TezosMessageUtil_1.TezosMessageUtils.readKeyWithHint(keys.privateKey, 'edsk');\n            const publicKey = TezosMessageUtil_1.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');\n            const publicKeyHash = TezosMessageUtil_1.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');\n            if (!!pkh && publicKeyHash !== pkh) {\n                throw new Error('The given mnemonic and passphrase do not correspond to the applied public key hash');\n            }\n            return { publicKey, privateKey, publicKeyHash, seed: '', storeType };\n        });\n    }\n    TezosWalletUtil.getKeysFromMnemonicAndPassphrase = getKeysFromMnemonicAndPassphrase;\n    function signText(keyStore, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const privateKey = TezosMessageUtil_1.TezosMessageUtils.writeKeyWithHint(keyStore.privateKey, 'edsk');\n            const messageSig = yield CryptoUtils_1.CryptoUtils.signDetached(Buffer.from(message, 'utf8'), privateKey);\n            return TezosMessageUtil_1.TezosMessageUtils.readSignatureWithHint(messageSig, 'edsig');\n        });\n    }\n    TezosWalletUtil.signText = signText;\n    function checkSignature(signature, message, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const sig = TezosMessageUtil_1.TezosMessageUtils.writeSignatureWithHint(signature, 'edsig');\n            const pk = TezosMessageUtil_1.TezosMessageUtils.writeKeyWithHint(publicKey, 'edpk');\n            return yield CryptoUtils_1.CryptoUtils.checkSignature(sig, Buffer.from(message, 'utf8'), pk);\n        });\n    }\n    TezosWalletUtil.checkSignature = checkSignature;\n})(TezosWalletUtil = exports.TezosWalletUtil || (exports.TezosWalletUtil = {}));\n//# sourceMappingURL=TezosWalletUtil.js.map"]},"metadata":{},"sourceType":"script"}