{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction id(d) {\n  return d[0];\n}\n\nconst moo = require(\"moo\");\n\nconst macroCADRconst = /C[AD]+R/;\nconst macroSETCADRconst = /SET_C[AD]+R/;\nconst macroDIPconst = /DII+P/;\nconst macroDUPconst = /DUU+P/;\nconst DIPmatcher = new RegExp(macroDIPconst);\nconst DUPmatcher = new RegExp(macroDUPconst);\nconst macroASSERTlistConst = ['ASSERT', 'ASSERT_EQ', 'ASSERT_NEQ', 'ASSERT_GT', 'ASSERT_LT', 'ASSERT_GE', 'ASSERT_LE', 'ASSERT_NONE', 'ASSERT_SOME', 'ASSERT_LEFT', 'ASSERT_RIGHT', 'ASSERT_CMPEQ', 'ASSERT_CMPNEQ', 'ASSERT_CMPGT', 'ASSERT_CMPLT', 'ASSERT_CMPGE', 'ASSERT_CMPLE'];\nconst macroIFCMPlist = ['IFCMPEQ', 'IFCMPNEQ', 'IFCMPLT', 'IFCMPGT', 'IFCMPLE', 'IFCMPGE'];\nconst macroCMPlist = ['CMPEQ', 'CMPNEQ', 'CMPLT', 'CMPGT', 'CMPLE', 'CMPGE'];\nconst macroIFlist = ['IFEQ', 'IFNEQ', 'IFLT', 'IFGT', 'IFLE', 'IFGE'];\nconst lexer = moo.compile({\n  annot: /[\\@\\%\\:][a-z_A-Z0-9]+/,\n  lparen: '(',\n  rparen: ')',\n  lbrace: '{',\n  rbrace: '}',\n  ws: /[ \\t]+/,\n  semicolon: \";\",\n  bytes: /0x[0-9a-fA-F]+/,\n  number: /-?[0-9]+(?!x)/,\n  parameter: ['parameter', 'Parameter'],\n  storage: ['Storage', 'storage'],\n  code: ['Code', 'code'],\n  comparableType: ['int', 'nat', 'string', 'bytes', 'mutez', 'bool', 'key_hash', 'timestamp', 'chain_id'],\n  constantType: ['key', 'unit', 'signature', 'operation', 'address'],\n  singleArgType: ['option', 'list', 'set', 'contract'],\n  doubleArgType: ['pair', 'or', 'lambda', 'map', 'big_map'],\n  baseInstruction: ['ABS', 'ADD', 'ADDRESS', 'AMOUNT', 'AND', 'BALANCE', 'BLAKE2B', 'CAR', 'CAST', 'CDR', 'CHECK_SIGNATURE', 'COMPARE', 'CONCAT', 'CONS', 'CONTRACT', 'DIP', 'EDIV', 'EMPTY_SET', 'EQ', 'EXEC', 'FAIL', 'FAILWITH', 'GE', 'GET', 'GT', 'HASH_KEY', 'IF', 'IF_CONS', 'IF_LEFT', 'IF_NONE', 'IF_RIGHT', 'IMPLICIT_ACCOUNT', 'INT', 'ISNAT', 'ITER', 'LAMBDA', 'LE', 'LEFT', 'LOOP', 'LOOP_LEFT', 'LSL', 'LSR', 'LT', 'MAP', 'MEM', 'MUL', 'NEG', 'NEQ', 'NIL', 'NONE', 'NOT', 'NOW', 'OR', 'PACK', 'PAIR', 'REDUCE', 'RENAME', 'RIGHT', 'SELF', 'SENDER', 'SET_DELEGATE', 'SHA256', 'SHA512', 'SIZE', 'SLICE', 'SOME', 'SOURCE', 'STEPS_TO_QUOTA', 'SUB', 'SWAP', 'TRANSFER_TOKENS', 'UNIT', 'UNPACK', 'UPDATE', 'XOR', 'UNPAIR', 'UNPAPAIR', 'IF_SOME', 'IFCMPEQ', 'IFCMPNEQ', 'IFCMPLT', 'IFCMPGT', 'IFCMPLE', 'IFCMPGE', 'CMPEQ', 'CMPNEQ', 'CMPLT', 'CMPGT', 'CMPLE', 'CMPGE', 'IFEQ', 'NEQ', 'IFLT', 'IFGT', 'IFLE', 'IFGE', 'EMPTY_BIG_MAP', 'APPLY', 'CHAIN_ID'],\n  macroCADR: macroCADRconst,\n  macroDIP: macroDIPconst,\n  macroDUP: macroDUPconst,\n  macroSETCADR: macroSETCADRconst,\n  macroASSERTlist: macroASSERTlistConst,\n  constantData: ['Unit', 'True', 'False', 'None', 'instruction'],\n  singleArgData: ['Left', 'Right', 'Some'],\n  doubleArgData: ['Pair'],\n  elt: \"Elt\",\n  word: /[a-zA-Z_0-9]+/,\n  string: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/\n});\n\nconst checkC_R = c_r => {\n  var pattern = new RegExp('^C(A|D)(A|D)+R$');\n  return pattern.test(c_r);\n};\n\nconst expandC_R = (word, annot) => {\n  var expandedC_R = word.slice(1, -1).split('').map(c => c === 'A' ? '{ \"prim\": \"CAR\" }' : '{ \"prim\": \"CDR\" }');\n\n  if (annot != null) {\n    const lastChar = word.slice(-2, -1);\n\n    if (lastChar === 'A') {\n      expandedC_R[expandedC_R.length - 1] = `{ \"prim\": \"CAR\", \"annots\": [${annot}] }`;\n    } else if (lastChar === 'D') {\n      expandedC_R[expandedC_R.length - 1] = `{ \"prim\": \"CDR\", \"annots\": [${annot}] }`;\n    }\n  }\n\n  return `[${expandedC_R.join(', ')}]`;\n};\n\nconst check_compare = cmp => macroCMPlist.includes(cmp);\n\nconst expand_cmp = (cmp, annot) => {\n  var op = cmp.substring(3);\n  var binary_op = keywordToJson([`${op}`]);\n  var compare = keywordToJson(['COMPARE']);\n\n  if (annot != null) {\n    binary_op = `{ \"prim\": \"${op}\", \"annots\": [${annot}] }`;\n  }\n\n  return `[${compare}, ${binary_op}]`;\n};\n\nconst check_dup = dup => DUPmatcher.test(dup);\n\nconst expand_dup = (dup, annot) => {\n  let t = '';\n\n  if (DUPmatcher.test(dup)) {\n    const c = dup.length - 3;\n\n    for (let i = 0; i < c; i++) {\n      t += '[{ \"prim\": \"DIP\", \"args\": [ ';\n    }\n\n    if (annot == null) {\n      t += `[{ \"prim\": \"DUP\" }]`;\n    } else {\n      t += `[{ \"prim\": \"DUP\", \"annots\": [${annot}] }]`;\n    }\n\n    for (let i = 0; i < c; i++) {\n      t += ' ] },{\"prim\":\"SWAP\"}]';\n    }\n\n    return t;\n  }\n\n  throw new Error('');\n};\n\nconst check_assert = assert => macroASSERTlistConst.includes(assert);\n\nconst expand_assert = (assert, annot) => {\n  const annotation = !!annot ? `, \"annots\": [${annot}]` : '';\n\n  switch (assert) {\n    case 'ASSERT':\n      return `[{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_CMPEQ':\n      return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"EQ\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_CMPGE':\n      return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"GE\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_CMPGT':\n      return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"GT\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_CMPLE':\n      return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"LE\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_CMPLT':\n      return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"LT\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_CMPNEQ':\n      return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"NEQ\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_EQ':\n      return `[{\"prim\":\"EQ\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]]`;\n\n    case 'ASSERT_GE':\n      return `[{\"prim\":\"GE\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_GT':\n      return `[{\"prim\":\"GT\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_LE':\n      return `[{\"prim\":\"LE\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_LT':\n      return `[{\"prim\":\"LT\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_NEQ':\n      return `[{\"prim\":\"NEQ\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n\n    case 'ASSERT_NONE':\n      return '[{\"prim\":\"IF_NONE\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"}]]]}]';\n\n    case 'ASSERT_SOME':\n      return '[{\"prim\":\"IF_NONE\",\"args\":[[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"}]],[]]}]';\n\n    case 'ASSERT_LEFT':\n      return '';\n\n    case 'ASSERT_RIGHT':\n      return '';\n\n    default:\n      throw new Error(`Could not process ${assert}`);\n  }\n};\n\nconst check_fail = fail => fail === \"FAIL\";\n\nconst expand_fail = (fail, annot) => {\n  if (annot == null) {\n    return '[ { \"prim\": \"UNIT\" }, { \"prim\": \"FAILWITH\" } ]';\n  } else {\n    return `[ { \"prim\": \"UNIT\" }, { \"prim\": \"FAILWITH\", \"annots\": [${annot}] } ]`;\n  }\n};\n\nconst check_if = ifStatement => macroIFCMPlist.includes(ifStatement) || macroIFlist.includes(ifStatement) || ifStatement === 'IF_SOME';\n\nconst expandIF = (ifInstr, ifTrue, ifFalse, annot) => {\n  const annotation = !!annot ? `, \"annots\": [${annot}]` : '';\n\n  switch (ifInstr) {\n    case 'IFCMPEQ':\n      return `[{\"prim\":\"COMPARE\"},{\"prim\":\"EQ\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFCMPGE':\n      return `[{\"prim\":\"COMPARE\"},{\"prim\":\"GE\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFCMPGT':\n      return `[{\"prim\":\"COMPARE\"},{\"prim\":\"GT\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFCMPLE':\n      return `[{\"prim\":\"COMPARE\"},{\"prim\":\"LE\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFCMPLT':\n      return `[{\"prim\":\"COMPARE\"},{\"prim\":\"LT\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFCMPNEQ':\n      return `[{\"prim\":\"COMPARE\"},{\"prim\":\"NEQ\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFEQ':\n      return `[{\"prim\":\"EQ\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFGE':\n      return `[{\"prim\":\"GE\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFGT':\n      return `[{\"prim\":\"GT\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFLE':\n      return `[{\"prim\":\"LE\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFLT':\n      return `[{\"prim\":\"LT\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IFNEQ':\n      return `[{\"prim\":\"NEQ\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n\n    case 'IF_SOME':\n      return `[{\"prim\":\"IF_NONE\",\"args\":[ [${ifFalse}], [${ifTrue}]]${annotation}}]`;\n\n    default:\n      throw new Error(`Could not process ${ifInstr}`);\n  }\n};\n\nconst check_dip = dip => DIPmatcher.test(dip);\n\nconst expandDIP = (dip, instruction, annot) => {\n  let t = '';\n\n  if (DIPmatcher.test(dip)) {\n    const c = dip.length - 2;\n\n    for (let i = 0; i < c; i++) {\n      t += '[{ \"prim\": \"DIP\", \"args\": [ ';\n    }\n\n    t = `${t} [ ${instruction} ] ]`;\n\n    if (!!annot) {\n      t = `${t}, \"annots\": [${annot}]`;\n    }\n\n    t += ' }]';\n\n    for (let i = 0; i < c - 1; i++) {\n      t += ' ] }]';\n    }\n\n    return t;\n  }\n\n  throw new Error(`Unexpected parameter for DIP processing: ${dip}`);\n};\n\nconst check_other = word => word == \"UNPAIR\" || word == \"UNPAPAIR\";\n\nconst expand_other = (word, annot) => {\n  if (word == 'UNPAIR') {\n    if (annot == null) {\n      return '[ [ { \"prim\": \"DUP\" }, { \"prim\": \"CAR\" }, { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\" } ] ] } ] ]';\n    } else if (annot.length == 1) {\n      return `[ [ { \"prim\": \"DUP\" }, { \"prim\": \"CAR\", \"annots\": [${annot}] }, { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\" } ] ]  } ] ]`;\n    } else if (annot.length == 2) {\n      return `[ [ { \"prim\": \"DUP\" }, { \"prim\": \"CAR\", \"annots\": [${annot[0]}] }, { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\", \"annots\": [${annot[1]}] } ] ]  } ] ]`;\n    } else {\n      return '';\n    }\n  }\n\n  if (word == 'UNPAPAIR') {\n    if (annot == null) {\n      return `[ [ { \"prim\": \"DUP\" },\n                            { \"prim\": \"CAR\" },\n                            { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\" } ] ] } ],\n                            {\"prim\":\"DIP\",\"args\":[[[{\"prim\":\"DUP\"},{\"prim\":\"CAR\"},{\"prim\":\"DIP\",\"args\":[[{\"prim\":\"CDR\"}]]}]]]}]`;\n    } else {\n      return `[ [ { \"prim\": \"DUP\" },\n                            { \"prim\": \"CAR\" },\n                            { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\" } ] ] } ],\n                            {\"prim\":\"DIP\",\"args\":[[[{\"prim\":\"DUP\"},{\"prim\":\"CAR\"},{\"prim\":\"DIP\",\"args\":[[{\"prim\":\"CDR\"}]],\"annots\": [${annot}]}]]]}]`;\n    }\n  }\n};\n\nconst checkSetCadr = s => macroSETCADRconst.test(s);\n\nconst expandSetCadr = (word, annot) => nestSetCadr(word.slice(5, -1));\n\nconst nestSetCadr = r => {\n  if (r.length === 0) {\n    return '';\n  }\n\n  const c = r.charAt(0);\n\n  if (r.length === 1) {\n    if (c === 'A') {\n      return '[{\"prim\": \"CDR\",\"annots\":[\"@%%\"]}, {\"prim\": \"SWAP\"}, {\"prim\": \"PAIR\",\"annots\":[\"%\",\"%@\"]}]';\n    } else if (c === 'D') {\n      return '[{\"prim\": \"CAR\",\"annots\":[\"@%%\"]}, {\"prim\": \"PAIR\",\"annots\":[\"%@\",\"%\"]}]';\n    }\n  }\n\n  if (c === 'A') {\n    return `[{\"prim\": \"DUP\"}, {\"prim\": \"DIP\", \"args\": [[{\"prim\": \"CAR\",\"annots\":[\"@%%\"]}, ${nestSetCadr(r.slice(1))}]]}, {\"prim\": \"CDR\",\"annots\":[\"@%%\"]}, {\"prim\": \"SWAP\"}, {\"prim\": \"PAIR\",\"annots\":[\"%@\",\"%@\"]}]`;\n  } else if (c === 'D') {\n    return `[{\"prim\": \"DUP\"}, {\"prim\": \"DIP\", \"args\": [[{\"prim\": \"CDR\",\"annots\":[\"@%%\"]}, ${nestSetCadr(r.slice(1))}]]}, {\"prim\": \"CAR\",\"annots\":[\"@%%\"]}, {\"prim\": \"PAIR\",\"annots\":[\"%@\",\"%@\"]}]`;\n  }\n};\n\nconst checkKeyword = word => {\n  if (check_assert(word)) {\n    return true;\n  }\n\n  if (check_compare(word)) {\n    return true;\n  }\n\n  if (check_dip(word)) {\n    return true;\n  }\n\n  if (check_dup(word)) {\n    return true;\n  }\n\n  if (check_fail(word)) {\n    return true;\n  }\n\n  if (check_if(word)) {\n    return true;\n  }\n\n  if (checkC_R(word)) {\n    return true;\n  }\n\n  if (check_other(word)) {\n    return true;\n  }\n\n  if (checkSetCadr(word)) {\n    return true;\n  }\n};\n\nconst expandKeyword = (word, annot) => {\n  if (checkC_R(word)) {\n    return expandC_R(word, annot);\n  }\n\n  if (check_assert(word)) {\n    return expand_assert(word, annot);\n  }\n\n  if (check_compare(word)) {\n    return expand_cmp(word, annot);\n  }\n\n  if (check_dip(word)) {\n    return expandDIP(word, annot);\n  }\n\n  if (check_dup(word)) {\n    return expand_dup(word, annot);\n  }\n\n  if (check_fail(word)) {\n    return expand_fail(word, annot);\n  }\n\n  if (check_if(word)) {\n    return expandIF(word, annot);\n  }\n\n  if (check_other(word)) {\n    return expand_other(word, annot);\n  }\n\n  if (checkSetCadr(word)) {\n    return expandSetCadr(word, annot);\n  }\n};\n\nconst intToJson = d => `{ \"int\": \"${parseInt(d[0])}\" }`;\n\nconst stringToJson = d => `{ \"string\": ${d[0]} }`;\n\nconst bytesToJson = d => `{ \"bytes\": \"${d[0].toString().slice(2)}\" }`;\n\nconst keywordToJson = d => {\n  const word = d[0].toString();\n\n  if (d.length == 1) {\n    if (checkKeyword(word)) {\n      return [expandKeyword(word, null)];\n    } else {\n      return `{ \"prim\": \"${d[0]}\" }`;\n    }\n  } else {\n    const annot = d[1].map(x => `\"${x[1]}\"`);\n\n    if (checkKeyword(word)) {\n      return [expandKeyword(word, annot)];\n    } else {\n      return `{ \"prim\": \"${d[0]}\", \"annots\": [${annot}] }`;\n    }\n  }\n};\n\nconst singleArgKeywordToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]} ] }`;\n\nconst comparableTypeToJson = d => {\n  const annot = d[3].map(x => `\"${x[1]}\"`);\n  return `{ \"prim\": \"${d[2]}\", \"annots\": [${annot}]  }`;\n};\n\nconst singleArgTypeKeywordWithParenToJson = d => {\n  const annot = d[3].map(x => `\"${x[1]}\"`);\n  return `{ \"prim\": \"${d[2]}\", \"args\": [ ${d[5]} ], \"annots\": [${annot}]  }`;\n};\n\nconst singleArgInstrKeywordToJson = d => {\n  const word = `${d[0].toString()}`;\n\n  if (check_dip(word)) {\n    return expandDIP(word, d[2]);\n  } else {\n    return `{ \"prim\": \"${d[0]}\", \"args\": [ [ ${d[2]} ] ] }`;\n  }\n};\n\nconst singleArgTypeKeywordToJson = d => {\n  const word = `${d[0].toString()}`;\n  const annot = d[1].map(x => `\"${x[1]}\"`);\n\n  if (check_dip(word)) {\n    return expandDIP(word, d[2], annot);\n  } else {\n    return `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[3]} ], \"annots\": [${annot}] }`;\n  }\n};\n\nconst singleArgKeywordWithParenToJson = d => `{ \"prim\": \"${d[2]}\", \"args\": [ ${d[4 + (d.length === 7 ? 0 : 2)]} ] }`;\n\nconst doubleArgKeywordToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]}, ${d[4]} ] }`;\n\nconst doubleArgParenKeywordToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[4]}, ${d[8]} ] }`;\n\nconst doubleArgInstrKeywordToJson = d => {\n  const word = `${d[0].toString()}`;\n\n  if (check_if(word)) {\n    return expandIF(word, d[2], d[4]);\n  } else {\n    return `{ \"prim\": \"${d[0]}\", \"args\": [ [${d[2]}], [${d[4]}] ] }`;\n  }\n};\n\nconst doubleArgKeywordWithParenToJson = d => `{ \"prim\": \"${d[2]}\", \"args\": [ ${d[4]}, ${d[6]} ] }`;\n\nconst tripleArgKeyWordToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]}, ${d[4]}, [${d[6]}] ] }`;\n\nconst tripleArgKeyWordWithParenToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]}, ${d[4]}, ${d[6]} ] }`;\n\nconst nestedArrayChecker = x => {\n  if (Array.isArray(x) && Array.isArray(x[0])) {\n    return x[0];\n  } else {\n    return x;\n  }\n};\n\nconst instructionSetToJsonNoSemi = d => {\n  return d[2].map(x => x[0]).concat(d[3]).map(x => nestedArrayChecker(x));\n};\n\nconst instructionSetToJsonSemi = d => {\n  return `${d[2].map(x => x[0]).map(x => nestedArrayChecker(x))}`;\n};\n\nconst dataListToJsonSemi = d => {\n  return `[ ${d[2].map(x => x[0]).map(x => nestedArrayChecker(x))} ]`;\n};\n\nconst scriptToJson = d => `[ ${d[0]}, ${d[2]}, { \"prim\": \"code\", \"args\": [ [ ${d[4]} ] ] } ]`;\n\nconst doubleArgTypeKeywordToJson = d => {\n  const annot = d[1].map(x => `\"${x[1]}\"`);\n  return `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[4]}, ${d[6]} ], \"annots\": [${annot}]  }`;\n};\n\nconst doubleArgTypeKeywordWithParenToJson = d => {\n  const annot = d[3].map(x => `\"${x[1]}\"`);\n  return `{ \"prim\": \"${d[2]}\", \"args\": [ ${d[5]}, ${d[7]} ], \"annots\": [${annot}]  }`;\n};\n\nconst tripleArgTypeKeyWordToJson = d => {\n  const annot = d[1].map(x => `\"${x[1]}\"`);\n  return `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[3]}, ${d[5]}, ${d[7]} ], \"annots\": [${annot}]  }`;\n};\n\nconst pushToJson = d => {\n  return `{ \"prim\": \"${d[0]}\", \"args\": [${d[2]}, []] }`;\n};\n\nconst pushWithAnnotsToJson = d => {\n  const annot = d[1].map(x => `\"${x[1]}\"`);\n  return `{ \"prim\": \"PUSH\", \"args\": [ ${d[3]}, ${d[5]} ], \"annots\": [${annot}]  }`;\n};\n\nconst dipnToJson = d => d.length > 4 ? `{ \"prim\": \"${d[0]}\", \"args\": [ { \"int\": \"${d[2]}\" }, [ ${d[4]} ] ] }` : `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]} ] }`;\n\nconst dupnToJson = d => {\n  const n = Number(d[2]);\n\n  if (n === 1) {\n    return '{ \"prim\": \"DUP\" }';\n  } else if (n === 2) {\n    return '[{ \"prim\": \"DIP\", \"args\": [[ {\"prim\": \"DUP\"} ]] }, { \"prim\": \"SWAP\" }]';\n  } else {\n    return `[{ \"prim\": \"DIP\", \"args\": [ {\"int\": \"${n - 1}\"}, [{ \"prim\": \"DUP\" }] ] }, { \"prim\": \"DIG\", \"args\": [ {\"int\": \"${n}\"} ] }]`;\n  }\n};\n\nconst dignToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ { \"int\": \"${d[2]}\" } ] }`;\n\nconst dropnToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ { \"int\": \"${d[2]}\" } ] }`;\n\nconst subContractToJson = d => `{ \"prim\":\"CREATE_CONTRACT\", \"args\": [ [ ${d[4]}, ${d[6]}, {\"prim\": \"code\" , \"args\":[ [ ${d[8]} ] ] } ] ] }`;\n\nconst instructionListToJson = d => {\n  const instructionOne = [d[2]];\n  const instructionList = d[3].map(x => x[3]);\n  return instructionOne.concat(instructionList).map(x => nestedArrayChecker(x));\n};\n\n;\n;\n;\n;\nconst grammar = {\n  Lexer: lexer,\n  ParserRules: [{\n    \"name\": \"main\",\n    \"symbols\": [\"instruction\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"main\",\n    \"symbols\": [\"data\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"main\",\n    \"symbols\": [\"type\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"main\",\n    \"symbols\": [\"parameter\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"main\",\n    \"symbols\": [\"storage\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"main\",\n    \"symbols\": [\"code\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"main\",\n    \"symbols\": [\"script\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"main\",\n    \"symbols\": [\"parameterValue\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"main\",\n    \"symbols\": [\"storageValue\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"main\",\n    \"symbols\": [\"typeData\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"script\",\n    \"symbols\": [\"parameter\", \"_\", \"storage\", \"_\", \"code\"],\n    \"postprocess\": scriptToJson\n  }, {\n    \"name\": \"parameterValue\",\n    \"symbols\": [lexer.has(\"parameter\") ? {\n      type: \"parameter\"\n    } : parameter, \"_\", \"typeData\", \"_\", \"semicolons\"],\n    \"postprocess\": singleArgKeywordToJson\n  }, {\n    \"name\": \"storageValue\",\n    \"symbols\": [lexer.has(\"storage\") ? {\n      type: \"storage\"\n    } : storage, \"_\", \"typeData\", \"_\", \"semicolons\"],\n    \"postprocess\": singleArgKeywordToJson\n  }, {\n    \"name\": \"parameter\",\n    \"symbols\": [lexer.has(\"parameter\") ? {\n      type: \"parameter\"\n    } : parameter, \"_\", \"type\", \"_\", \"semicolons\"],\n    \"postprocess\": singleArgKeywordToJson\n  }, {\n    \"name\": \"storage\",\n    \"symbols\": [lexer.has(\"storage\") ? {\n      type: \"storage\"\n    } : storage, \"_\", \"type\", \"_\", \"semicolons\"],\n    \"postprocess\": singleArgKeywordToJson\n  }, {\n    \"name\": \"code\",\n    \"symbols\": [lexer.has(\"code\") ? {\n      type: \"code\"\n    } : code, \"_\", \"subInstruction\", \"_\", \"semicolons\", \"_\"],\n    \"postprocess\": d => d[2]\n  }, {\n    \"name\": \"code\",\n    \"symbols\": [lexer.has(\"code\") ? {\n      type: \"code\"\n    } : code, \"_\", {\n      \"literal\": \"{};\"\n    }],\n    \"postprocess\": d => \"code {}\"\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"comparableType\") ? {\n      type: \"comparableType\"\n    } : comparableType],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"constantType\") ? {\n      type: \"constantType\"\n    } : constantType],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"singleArgType\") ? {\n      type: \"singleArgType\"\n    } : singleArgType, \"_\", \"type\"],\n    \"postprocess\": singleArgKeywordToJson\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", lexer.has(\"singleArgType\") ? {\n      type: \"singleArgType\"\n    } : singleArgType, \"_\", \"type\", \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": singleArgKeywordWithParenToJson\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", lexer.has(\"singleArgType\") ? {\n      type: \"singleArgType\"\n    } : singleArgType, \"_\", lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", \"type\", \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen, \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": singleArgKeywordWithParenToJson\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"doubleArgType\") ? {\n      type: \"doubleArgType\"\n    } : doubleArgType, \"_\", \"type\", \"_\", \"type\"],\n    \"postprocess\": doubleArgKeywordToJson\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", lexer.has(\"doubleArgType\") ? {\n      type: \"doubleArgType\"\n    } : doubleArgType, \"_\", \"type\", \"_\", \"type\", \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": doubleArgKeywordWithParenToJson\n  }, {\n    \"name\": \"type$ebnf$1$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$1\",\n    \"symbols\": [\"type$ebnf$1$subexpression$1\"]\n  }, {\n    \"name\": \"type$ebnf$1$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$1\",\n    \"symbols\": [\"type$ebnf$1\", \"type$ebnf$1$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"comparableType\") ? {\n      type: \"comparableType\"\n    } : comparableType, \"type$ebnf$1\"],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"type$ebnf$2$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$2\",\n    \"symbols\": [\"type$ebnf$2$subexpression$1\"]\n  }, {\n    \"name\": \"type$ebnf$2$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$2\",\n    \"symbols\": [\"type$ebnf$2\", \"type$ebnf$2$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"constantType\") ? {\n      type: \"constantType\"\n    } : constantType, \"type$ebnf$2\"],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"type$ebnf$3$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$3\",\n    \"symbols\": [\"type$ebnf$3$subexpression$1\"]\n  }, {\n    \"name\": \"type$ebnf$3$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$3\",\n    \"symbols\": [\"type$ebnf$3\", \"type$ebnf$3$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", lexer.has(\"comparableType\") ? {\n      type: \"comparableType\"\n    } : comparableType, \"type$ebnf$3\", \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": comparableTypeToJson\n  }, {\n    \"name\": \"type$ebnf$4$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$4\",\n    \"symbols\": [\"type$ebnf$4$subexpression$1\"]\n  }, {\n    \"name\": \"type$ebnf$4$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$4\",\n    \"symbols\": [\"type$ebnf$4\", \"type$ebnf$4$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", lexer.has(\"constantType\") ? {\n      type: \"constantType\"\n    } : constantType, \"type$ebnf$4\", \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": comparableTypeToJson\n  }, {\n    \"name\": \"type$ebnf$5$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$5\",\n    \"symbols\": [\"type$ebnf$5$subexpression$1\"]\n  }, {\n    \"name\": \"type$ebnf$5$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$5\",\n    \"symbols\": [\"type$ebnf$5\", \"type$ebnf$5$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", lexer.has(\"singleArgType\") ? {\n      type: \"singleArgType\"\n    } : singleArgType, \"type$ebnf$5\", \"_\", \"type\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": singleArgTypeKeywordWithParenToJson\n  }, {\n    \"name\": \"type$ebnf$6$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$6\",\n    \"symbols\": [\"type$ebnf$6$subexpression$1\"]\n  }, {\n    \"name\": \"type$ebnf$6$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"type$ebnf$6\",\n    \"symbols\": [\"type$ebnf$6\", \"type$ebnf$6$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"type\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", lexer.has(\"doubleArgType\") ? {\n      type: \"doubleArgType\"\n    } : doubleArgType, \"type$ebnf$6\", \"_\", \"type\", \"_\", \"type\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": doubleArgTypeKeywordWithParenToJson\n  }, {\n    \"name\": \"typeData\",\n    \"symbols\": [lexer.has(\"singleArgType\") ? {\n      type: \"singleArgType\"\n    } : singleArgType, \"_\", \"typeData\"],\n    \"postprocess\": singleArgKeywordToJson\n  }, {\n    \"name\": \"typeData\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", lexer.has(\"singleArgType\") ? {\n      type: \"singleArgType\"\n    } : singleArgType, \"_\", \"typeData\", \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": singleArgKeywordWithParenToJson\n  }, {\n    \"name\": \"typeData\",\n    \"symbols\": [lexer.has(\"doubleArgType\") ? {\n      type: \"doubleArgType\"\n    } : doubleArgType, \"_\", \"typeData\", \"_\", \"typeData\"],\n    \"postprocess\": doubleArgKeywordToJson\n  }, {\n    \"name\": \"typeData\",\n    \"symbols\": [lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", lexer.has(\"doubleArgType\") ? {\n      type: \"doubleArgType\"\n    } : doubleArgType, \"_\", \"typeData\", \"_\", \"typeData\", \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen],\n    \"postprocess\": doubleArgKeywordWithParenToJson\n  }, {\n    \"name\": \"typeData\",\n    \"symbols\": [\"subTypeData\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"typeData\",\n    \"symbols\": [\"subTypeElt\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"typeData\",\n    \"symbols\": [lexer.has(\"number\") ? {\n      type: \"number\"\n    } : number],\n    \"postprocess\": intToJson\n  }, {\n    \"name\": \"typeData\",\n    \"symbols\": [lexer.has(\"string\") ? {\n      type: \"string\"\n    } : string],\n    \"postprocess\": stringToJson\n  }, {\n    \"name\": \"typeData\",\n    \"symbols\": [lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": d => []\n  }, {\n    \"name\": \"data\",\n    \"symbols\": [lexer.has(\"constantData\") ? {\n      type: \"constantData\"\n    } : constantData],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"data\",\n    \"symbols\": [lexer.has(\"singleArgData\") ? {\n      type: \"singleArgData\"\n    } : singleArgData, \"_\", \"data\"],\n    \"postprocess\": singleArgKeywordToJson\n  }, {\n    \"name\": \"data\",\n    \"symbols\": [lexer.has(\"doubleArgData\") ? {\n      type: \"doubleArgData\"\n    } : doubleArgData, \"_\", \"data\", \"_\", \"data\"],\n    \"postprocess\": doubleArgKeywordToJson\n  }, {\n    \"name\": \"data\",\n    \"symbols\": [\"subData\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"data\",\n    \"symbols\": [\"subElt\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"data\",\n    \"symbols\": [lexer.has(\"string\") ? {\n      type: \"string\"\n    } : string],\n    \"postprocess\": stringToJson\n  }, {\n    \"name\": \"data\",\n    \"symbols\": [lexer.has(\"bytes\") ? {\n      type: \"bytes\"\n    } : bytes],\n    \"postprocess\": bytesToJson\n  }, {\n    \"name\": \"data\",\n    \"symbols\": [lexer.has(\"number\") ? {\n      type: \"number\"\n    } : number],\n    \"postprocess\": intToJson\n  }, {\n    \"name\": \"subData\",\n    \"symbols\": [lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": d => \"[]\"\n  }, {\n    \"name\": \"subData$ebnf$1$subexpression$1\",\n    \"symbols\": [\"data\", \"_\"]\n  }, {\n    \"name\": \"subData$ebnf$1\",\n    \"symbols\": [\"subData$ebnf$1$subexpression$1\"]\n  }, {\n    \"name\": \"subData$ebnf$1$subexpression$2\",\n    \"symbols\": [\"data\", \"_\"]\n  }, {\n    \"name\": \"subData$ebnf$1\",\n    \"symbols\": [\"subData$ebnf$1\", \"subData$ebnf$1$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"subData\",\n    \"symbols\": [{\n      \"literal\": \"(\"\n    }, \"_\", \"subData$ebnf$1\", {\n      \"literal\": \")\"\n    }],\n    \"postprocess\": instructionSetToJsonSemi\n  }, {\n    \"name\": \"subData$ebnf$2$subexpression$1$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subData$ebnf$2$subexpression$1$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subData$ebnf$2$subexpression$1\",\n    \"symbols\": [\"data\", \"_\", \"subData$ebnf$2$subexpression$1$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subData$ebnf$2\",\n    \"symbols\": [\"subData$ebnf$2$subexpression$1\"]\n  }, {\n    \"name\": \"subData$ebnf$2$subexpression$2$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subData$ebnf$2$subexpression$2$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subData$ebnf$2$subexpression$2\",\n    \"symbols\": [\"data\", \"_\", \"subData$ebnf$2$subexpression$2$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subData$ebnf$2\",\n    \"symbols\": [\"subData$ebnf$2\", \"subData$ebnf$2$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"subData\",\n    \"symbols\": [{\n      \"literal\": \"{\"\n    }, \"_\", \"subData$ebnf$2\", {\n      \"literal\": \"}\"\n    }],\n    \"postprocess\": dataListToJsonSemi\n  }, {\n    \"name\": \"subElt\",\n    \"symbols\": [lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": d => \"[]\"\n  }, {\n    \"name\": \"subElt$ebnf$1$subexpression$1$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subElt$ebnf$1$subexpression$1$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subElt$ebnf$1$subexpression$1\",\n    \"symbols\": [\"elt\", \"subElt$ebnf$1$subexpression$1$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subElt$ebnf$1\",\n    \"symbols\": [\"subElt$ebnf$1$subexpression$1\"]\n  }, {\n    \"name\": \"subElt$ebnf$1$subexpression$2$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subElt$ebnf$1$subexpression$2$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subElt$ebnf$1$subexpression$2\",\n    \"symbols\": [\"elt\", \"subElt$ebnf$1$subexpression$2$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subElt$ebnf$1\",\n    \"symbols\": [\"subElt$ebnf$1\", \"subElt$ebnf$1$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"subElt\",\n    \"symbols\": [{\n      \"literal\": \"{\"\n    }, \"_\", \"subElt$ebnf$1\", {\n      \"literal\": \"}\"\n    }],\n    \"postprocess\": dataListToJsonSemi\n  }, {\n    \"name\": \"elt\",\n    \"symbols\": [lexer.has(\"elt\") ? {\n      type: \"elt\"\n    } : elt, \"_\", \"data\", \"_\", \"data\"],\n    \"postprocess\": doubleArgKeywordToJson\n  }, {\n    \"name\": \"subTypeData\",\n    \"symbols\": [lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": d => \"[]\"\n  }, {\n    \"name\": \"subTypeData$ebnf$1$subexpression$1$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subTypeData$ebnf$1$subexpression$1$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subTypeData$ebnf$1$subexpression$1\",\n    \"symbols\": [\"data\", \"subTypeData$ebnf$1$subexpression$1$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subTypeData$ebnf$1\",\n    \"symbols\": [\"subTypeData$ebnf$1$subexpression$1\"]\n  }, {\n    \"name\": \"subTypeData$ebnf$1$subexpression$2$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subTypeData$ebnf$1$subexpression$2$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subTypeData$ebnf$1$subexpression$2\",\n    \"symbols\": [\"data\", \"subTypeData$ebnf$1$subexpression$2$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subTypeData$ebnf$1\",\n    \"symbols\": [\"subTypeData$ebnf$1\", \"subTypeData$ebnf$1$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"subTypeData\",\n    \"symbols\": [{\n      \"literal\": \"{\"\n    }, \"_\", \"subTypeData$ebnf$1\", {\n      \"literal\": \"}\"\n    }],\n    \"postprocess\": instructionSetToJsonSemi\n  }, {\n    \"name\": \"subTypeData$ebnf$2$subexpression$1$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subTypeData$ebnf$2$subexpression$1$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subTypeData$ebnf$2$subexpression$1\",\n    \"symbols\": [\"data\", \"subTypeData$ebnf$2$subexpression$1$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subTypeData$ebnf$2\",\n    \"symbols\": [\"subTypeData$ebnf$2$subexpression$1\"]\n  }, {\n    \"name\": \"subTypeData$ebnf$2$subexpression$2$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subTypeData$ebnf$2$subexpression$2$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subTypeData$ebnf$2$subexpression$2\",\n    \"symbols\": [\"data\", \"subTypeData$ebnf$2$subexpression$2$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subTypeData$ebnf$2\",\n    \"symbols\": [\"subTypeData$ebnf$2\", \"subTypeData$ebnf$2$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"subTypeData\",\n    \"symbols\": [{\n      \"literal\": \"(\"\n    }, \"_\", \"subTypeData$ebnf$2\", {\n      \"literal\": \")\"\n    }],\n    \"postprocess\": instructionSetToJsonSemi\n  }, {\n    \"name\": \"subTypeElt\",\n    \"symbols\": [lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": d => \"[]\"\n  }, {\n    \"name\": \"subTypeElt$ebnf$1$subexpression$1$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subTypeElt$ebnf$1$subexpression$1$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subTypeElt$ebnf$1$subexpression$1\",\n    \"symbols\": [\"typeElt\", \"subTypeElt$ebnf$1$subexpression$1$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subTypeElt$ebnf$1\",\n    \"symbols\": [\"subTypeElt$ebnf$1$subexpression$1\"]\n  }, {\n    \"name\": \"subTypeElt$ebnf$1$subexpression$2$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subTypeElt$ebnf$1$subexpression$2$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subTypeElt$ebnf$1$subexpression$2\",\n    \"symbols\": [\"typeElt\", \"subTypeElt$ebnf$1$subexpression$2$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subTypeElt$ebnf$1\",\n    \"symbols\": [\"subTypeElt$ebnf$1\", \"subTypeElt$ebnf$1$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"subTypeElt\",\n    \"symbols\": [{\n      \"literal\": \"[{\"\n    }, \"_\", \"subTypeElt$ebnf$1\", {\n      \"literal\": \"}]\"\n    }],\n    \"postprocess\": instructionSetToJsonSemi\n  }, {\n    \"name\": \"subTypeElt$ebnf$2$subexpression$1$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subTypeElt$ebnf$2$subexpression$1$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subTypeElt$ebnf$2$subexpression$1\",\n    \"symbols\": [\"typeElt\", \"_\", \"subTypeElt$ebnf$2$subexpression$1$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subTypeElt$ebnf$2\",\n    \"symbols\": [\"subTypeElt$ebnf$2$subexpression$1\"]\n  }, {\n    \"name\": \"subTypeElt$ebnf$2$subexpression$2$ebnf$1\",\n    \"symbols\": [{\n      \"literal\": \";\"\n    }],\n    \"postprocess\": id\n  }, {\n    \"name\": \"subTypeElt$ebnf$2$subexpression$2$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"subTypeElt$ebnf$2$subexpression$2\",\n    \"symbols\": [\"typeElt\", \"_\", \"subTypeElt$ebnf$2$subexpression$2$ebnf$1\", \"_\"]\n  }, {\n    \"name\": \"subTypeElt$ebnf$2\",\n    \"symbols\": [\"subTypeElt$ebnf$2\", \"subTypeElt$ebnf$2$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"subTypeElt\",\n    \"symbols\": [{\n      \"literal\": \"[{\"\n    }, \"_\", \"subTypeElt$ebnf$2\", {\n      \"literal\": \"}]\"\n    }],\n    \"postprocess\": instructionSetToJsonSemi\n  }, {\n    \"name\": \"typeElt\",\n    \"symbols\": [lexer.has(\"elt\") ? {\n      type: \"elt\"\n    } : elt, \"_\", \"typeData\", \"_\", \"typeData\"],\n    \"postprocess\": doubleArgKeywordToJson\n  }, {\n    \"name\": \"subInstruction\",\n    \"symbols\": [lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": d => \"\"\n  }, {\n    \"name\": \"subInstruction\",\n    \"symbols\": [lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", \"instruction\", \"_\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": d => d[2]\n  }, {\n    \"name\": \"subInstruction$ebnf$1$subexpression$1\",\n    \"symbols\": [\"instruction\", \"_\", lexer.has(\"semicolon\") ? {\n      type: \"semicolon\"\n    } : semicolon, \"_\"]\n  }, {\n    \"name\": \"subInstruction$ebnf$1\",\n    \"symbols\": [\"subInstruction$ebnf$1$subexpression$1\"]\n  }, {\n    \"name\": \"subInstruction$ebnf$1$subexpression$2\",\n    \"symbols\": [\"instruction\", \"_\", lexer.has(\"semicolon\") ? {\n      type: \"semicolon\"\n    } : semicolon, \"_\"]\n  }, {\n    \"name\": \"subInstruction$ebnf$1\",\n    \"symbols\": [\"subInstruction$ebnf$1\", \"subInstruction$ebnf$1$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"subInstruction\",\n    \"symbols\": [lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", \"subInstruction$ebnf$1\", \"instruction\", \"_\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": instructionSetToJsonNoSemi\n  }, {\n    \"name\": \"subInstruction$ebnf$2$subexpression$1\",\n    \"symbols\": [\"instruction\", \"_\", lexer.has(\"semicolon\") ? {\n      type: \"semicolon\"\n    } : semicolon, \"_\"]\n  }, {\n    \"name\": \"subInstruction$ebnf$2\",\n    \"symbols\": [\"subInstruction$ebnf$2$subexpression$1\"]\n  }, {\n    \"name\": \"subInstruction$ebnf$2$subexpression$2\",\n    \"symbols\": [\"instruction\", \"_\", lexer.has(\"semicolon\") ? {\n      type: \"semicolon\"\n    } : semicolon, \"_\"]\n  }, {\n    \"name\": \"subInstruction$ebnf$2\",\n    \"symbols\": [\"subInstruction$ebnf$2\", \"subInstruction$ebnf$2$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"subInstruction\",\n    \"symbols\": [lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", \"subInstruction$ebnf$2\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": instructionSetToJsonSemi\n  }, {\n    \"name\": \"instructions\",\n    \"symbols\": [lexer.has(\"baseInstruction\") ? {\n      type: \"baseInstruction\"\n    } : baseInstruction]\n  }, {\n    \"name\": \"instructions\",\n    \"symbols\": [lexer.has(\"macroCADR\") ? {\n      type: \"macroCADR\"\n    } : macroCADR]\n  }, {\n    \"name\": \"instructions\",\n    \"symbols\": [lexer.has(\"macroDIP\") ? {\n      type: \"macroDIP\"\n    } : macroDIP]\n  }, {\n    \"name\": \"instructions\",\n    \"symbols\": [lexer.has(\"macroDUP\") ? {\n      type: \"macroDUP\"\n    } : macroDUP]\n  }, {\n    \"name\": \"instructions\",\n    \"symbols\": [lexer.has(\"macroSETCADR\") ? {\n      type: \"macroSETCADR\"\n    } : macroSETCADR]\n  }, {\n    \"name\": \"instructions\",\n    \"symbols\": [lexer.has(\"macroASSERTlist\") ? {\n      type: \"macroASSERTlist\"\n    } : macroASSERTlist]\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\"],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"subInstruction\"],\n    \"postprocess\": id\n  }, {\n    \"name\": \"instruction$ebnf$1$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$1\",\n    \"symbols\": [\"instruction$ebnf$1$subexpression$1\"]\n  }, {\n    \"name\": \"instruction$ebnf$1$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$1\",\n    \"symbols\": [\"instruction$ebnf$1\", \"instruction$ebnf$1$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"instruction$ebnf$1\", \"_\"],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"_\", \"subInstruction\"],\n    \"postprocess\": singleArgInstrKeywordToJson\n  }, {\n    \"name\": \"instruction$ebnf$2$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$2\",\n    \"symbols\": [\"instruction$ebnf$2$subexpression$1\"]\n  }, {\n    \"name\": \"instruction$ebnf$2$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$2\",\n    \"symbols\": [\"instruction$ebnf$2\", \"instruction$ebnf$2$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"instruction$ebnf$2\", \"_\", \"subInstruction\"],\n    \"postprocess\": singleArgTypeKeywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"_\", \"type\"],\n    \"postprocess\": singleArgKeywordToJson\n  }, {\n    \"name\": \"instruction$ebnf$3$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$3\",\n    \"symbols\": [\"instruction$ebnf$3$subexpression$1\"]\n  }, {\n    \"name\": \"instruction$ebnf$3$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$3\",\n    \"symbols\": [\"instruction$ebnf$3\", \"instruction$ebnf$3$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"instruction$ebnf$3\", \"_\", \"type\"],\n    \"postprocess\": singleArgTypeKeywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"_\", \"data\"],\n    \"postprocess\": singleArgKeywordToJson\n  }, {\n    \"name\": \"instruction$ebnf$4$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$4\",\n    \"symbols\": [\"instruction$ebnf$4$subexpression$1\"]\n  }, {\n    \"name\": \"instruction$ebnf$4$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$4\",\n    \"symbols\": [\"instruction$ebnf$4\", \"instruction$ebnf$4$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"instruction$ebnf$4\", \"_\", \"data\"],\n    \"postprocess\": singleArgTypeKeywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"_\", \"type\", \"_\", \"type\", \"_\", \"subInstruction\"],\n    \"postprocess\": tripleArgKeyWordToJson\n  }, {\n    \"name\": \"instruction$ebnf$5$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$5\",\n    \"symbols\": [\"instruction$ebnf$5$subexpression$1\"]\n  }, {\n    \"name\": \"instruction$ebnf$5$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$5\",\n    \"symbols\": [\"instruction$ebnf$5\", \"instruction$ebnf$5$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"instruction$ebnf$5\", \"_\", \"type\", \"_\", \"type\", \"_\", \"subInstruction\"],\n    \"postprocess\": tripleArgTypeKeyWordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"_\", \"subInstruction\", \"_\", \"subInstruction\"],\n    \"postprocess\": doubleArgInstrKeywordToJson\n  }, {\n    \"name\": \"instruction$ebnf$6$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$6\",\n    \"symbols\": [\"instruction$ebnf$6$subexpression$1\"]\n  }, {\n    \"name\": \"instruction$ebnf$6$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$6\",\n    \"symbols\": [\"instruction$ebnf$6\", \"instruction$ebnf$6$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"instruction$ebnf$6\", \"_\", \"subInstruction\", \"_\", \"subInstruction\"],\n    \"postprocess\": doubleArgTypeKeywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"_\", \"type\", \"_\", \"type\"],\n    \"postprocess\": doubleArgKeywordToJson\n  }, {\n    \"name\": \"instruction$ebnf$7$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$7\",\n    \"symbols\": [\"instruction$ebnf$7$subexpression$1\"]\n  }, {\n    \"name\": \"instruction$ebnf$7$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$7\",\n    \"symbols\": [\"instruction$ebnf$7\", \"instruction$ebnf$7$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [\"instructions\", \"instruction$ebnf$7\", \"_\", \"type\", \"_\", \"type\"],\n    \"postprocess\": doubleArgTypeKeywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"PUSH\"\n    }, \"_\", \"type\", \"_\", \"data\"],\n    \"postprocess\": doubleArgKeywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"PUSH\"\n    }, \"_\", \"type\", \"_\", lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": pushToJson\n  }, {\n    \"name\": \"instruction$ebnf$8$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$8\",\n    \"symbols\": [\"instruction$ebnf$8$subexpression$1\"]\n  }, {\n    \"name\": \"instruction$ebnf$8$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$8\",\n    \"symbols\": [\"instruction$ebnf$8\", \"instruction$ebnf$8$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"PUSH\"\n    }, \"instruction$ebnf$8\", \"_\", \"type\", \"_\", \"data\"],\n    \"postprocess\": pushWithAnnotsToJson\n  }, {\n    \"name\": \"instruction$ebnf$9\",\n    \"symbols\": [/[0-9]/]\n  }, {\n    \"name\": \"instruction$ebnf$9\",\n    \"symbols\": [\"instruction$ebnf$9\", /[0-9]/],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"DIP\"\n    }, \"_\", \"instruction$ebnf$9\", \"_\", \"subInstruction\"],\n    \"postprocess\": dipnToJson\n  }, {\n    \"name\": \"instruction$ebnf$10\",\n    \"symbols\": [/[0-9]/]\n  }, {\n    \"name\": \"instruction$ebnf$10\",\n    \"symbols\": [\"instruction$ebnf$10\", /[0-9]/],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"DUP\"\n    }, \"_\", \"instruction$ebnf$10\"],\n    \"postprocess\": dupnToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"DUP\"\n    }],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"instruction$ebnf$11$subexpression$1\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$11\",\n    \"symbols\": [\"instruction$ebnf$11$subexpression$1\"]\n  }, {\n    \"name\": \"instruction$ebnf$11$subexpression$2\",\n    \"symbols\": [\"_\", lexer.has(\"annot\") ? {\n      type: \"annot\"\n    } : annot]\n  }, {\n    \"name\": \"instruction$ebnf$11\",\n    \"symbols\": [\"instruction$ebnf$11\", \"instruction$ebnf$11$subexpression$2\"],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"DUP\"\n    }, \"instruction$ebnf$11\", \"_\"],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"instruction$ebnf$12\",\n    \"symbols\": [/[0-9]/]\n  }, {\n    \"name\": \"instruction$ebnf$12\",\n    \"symbols\": [\"instruction$ebnf$12\", /[0-9]/],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"DIG\"\n    }, \"_\", \"instruction$ebnf$12\"],\n    \"postprocess\": dignToJson\n  }, {\n    \"name\": \"instruction$ebnf$13\",\n    \"symbols\": [/[0-9]/]\n  }, {\n    \"name\": \"instruction$ebnf$13\",\n    \"symbols\": [\"instruction$ebnf$13\", /[0-9]/],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"DUG\"\n    }, \"_\", \"instruction$ebnf$13\"],\n    \"postprocess\": dignToJson\n  }, {\n    \"name\": \"instruction$ebnf$14\",\n    \"symbols\": [/[0-9]/]\n  }, {\n    \"name\": \"instruction$ebnf$14\",\n    \"symbols\": [\"instruction$ebnf$14\", /[0-9]/],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"DROP\"\n    }, \"_\", \"instruction$ebnf$14\"],\n    \"postprocess\": dropnToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"DROP\"\n    }],\n    \"postprocess\": keywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"CREATE_CONTRACT\"\n    }, \"_\", lexer.has(\"lbrace\") ? {\n      type: \"lbrace\"\n    } : lbrace, \"_\", \"parameter\", \"_\", \"storage\", \"_\", \"code\", \"_\", lexer.has(\"rbrace\") ? {\n      type: \"rbrace\"\n    } : rbrace],\n    \"postprocess\": subContractToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"EMPTY_MAP\"\n    }, \"_\", \"type\", \"_\", \"type\"],\n    \"postprocess\": doubleArgKeywordToJson\n  }, {\n    \"name\": \"instruction\",\n    \"symbols\": [{\n      \"literal\": \"EMPTY_MAP\"\n    }, \"_\", lexer.has(\"lparen\") ? {\n      type: \"lparen\"\n    } : lparen, \"_\", \"type\", \"_\", lexer.has(\"rparen\") ? {\n      type: \"rparen\"\n    } : rparen, \"_\", \"type\"],\n    \"postprocess\": doubleArgParenKeywordToJson\n  }, {\n    \"name\": \"_$ebnf$1\",\n    \"symbols\": []\n  }, {\n    \"name\": \"_$ebnf$1\",\n    \"symbols\": [\"_$ebnf$1\", /[\\s]/],\n    \"postprocess\": d => d[0].concat([d[1]])\n  }, {\n    \"name\": \"_\",\n    \"symbols\": [\"_$ebnf$1\"]\n  }, {\n    \"name\": \"semicolons$ebnf$1\",\n    \"symbols\": [/[;]/],\n    \"postprocess\": id\n  }, {\n    \"name\": \"semicolons$ebnf$1\",\n    \"symbols\": [],\n    \"postprocess\": () => null\n  }, {\n    \"name\": \"semicolons\",\n    \"symbols\": [\"semicolons$ebnf$1\"]\n  }],\n  ParserStart: \"main\"\n};\nexports.default = grammar;","map":{"version":3,"sources":["../../../../src/chain/tezos/lexer/Michelson.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction id(d) { return d[0]; }\nconst moo = require(\"moo\");\nconst macroCADRconst = /C[AD]+R/;\nconst macroSETCADRconst = /SET_C[AD]+R/;\nconst macroDIPconst = /DII+P/;\nconst macroDUPconst = /DUU+P/;\nconst DIPmatcher = new RegExp(macroDIPconst);\nconst DUPmatcher = new RegExp(macroDUPconst);\nconst macroASSERTlistConst = ['ASSERT', 'ASSERT_EQ', 'ASSERT_NEQ', 'ASSERT_GT', 'ASSERT_LT', 'ASSERT_GE', 'ASSERT_LE', 'ASSERT_NONE', 'ASSERT_SOME', 'ASSERT_LEFT', 'ASSERT_RIGHT', 'ASSERT_CMPEQ', 'ASSERT_CMPNEQ', 'ASSERT_CMPGT', 'ASSERT_CMPLT', 'ASSERT_CMPGE', 'ASSERT_CMPLE'];\nconst macroIFCMPlist = ['IFCMPEQ', 'IFCMPNEQ', 'IFCMPLT', 'IFCMPGT', 'IFCMPLE', 'IFCMPGE'];\nconst macroCMPlist = ['CMPEQ', 'CMPNEQ', 'CMPLT', 'CMPGT', 'CMPLE', 'CMPGE'];\nconst macroIFlist = ['IFEQ', 'IFNEQ', 'IFLT', 'IFGT', 'IFLE', 'IFGE'];\nconst lexer = moo.compile({\n    annot: /[\\@\\%\\:][a-z_A-Z0-9]+/,\n    lparen: '(',\n    rparen: ')',\n    lbrace: '{',\n    rbrace: '}',\n    ws: /[ \\t]+/,\n    semicolon: \";\",\n    bytes: /0x[0-9a-fA-F]+/,\n    number: /-?[0-9]+(?!x)/,\n    parameter: ['parameter', 'Parameter'],\n    storage: ['Storage', 'storage'],\n    code: ['Code', 'code'],\n    comparableType: ['int', 'nat', 'string', 'bytes', 'mutez', 'bool', 'key_hash', 'timestamp', 'chain_id'],\n    constantType: ['key', 'unit', 'signature', 'operation', 'address'],\n    singleArgType: ['option', 'list', 'set', 'contract'],\n    doubleArgType: ['pair', 'or', 'lambda', 'map', 'big_map'],\n    baseInstruction: ['ABS', 'ADD', 'ADDRESS', 'AMOUNT', 'AND', 'BALANCE', 'BLAKE2B', 'CAR', 'CAST', 'CDR', 'CHECK_SIGNATURE',\n        'COMPARE', 'CONCAT', 'CONS', 'CONTRACT', 'DIP', 'EDIV',\n        'EMPTY_SET', 'EQ', 'EXEC', 'FAIL', 'FAILWITH', 'GE', 'GET', 'GT', 'HASH_KEY', 'IF', 'IF_CONS', 'IF_LEFT', 'IF_NONE',\n        'IF_RIGHT', 'IMPLICIT_ACCOUNT', 'INT', 'ISNAT', 'ITER', 'LAMBDA', 'LE', 'LEFT', 'LOOP', 'LOOP_LEFT', 'LSL', 'LSR', 'LT',\n        'MAP', 'MEM', 'MUL', 'NEG', 'NEQ', 'NIL', 'NONE', 'NOT', 'NOW', 'OR', 'PACK', 'PAIR', 'REDUCE', 'RENAME', 'RIGHT', 'SELF',\n        'SENDER', 'SET_DELEGATE', 'SHA256', 'SHA512', 'SIZE', 'SLICE', 'SOME', 'SOURCE', 'STEPS_TO_QUOTA', 'SUB', 'SWAP',\n        'TRANSFER_TOKENS', 'UNIT', 'UNPACK', 'UPDATE', 'XOR',\n        'UNPAIR', 'UNPAPAIR',\n        'IF_SOME',\n        'IFCMPEQ', 'IFCMPNEQ', 'IFCMPLT', 'IFCMPGT', 'IFCMPLE', 'IFCMPGE', 'CMPEQ', 'CMPNEQ', 'CMPLT', 'CMPGT', 'CMPLE',\n        'CMPGE', 'IFEQ', 'NEQ', 'IFLT', 'IFGT', 'IFLE', 'IFGE',\n        'EMPTY_BIG_MAP', 'APPLY', 'CHAIN_ID'\n    ],\n    macroCADR: macroCADRconst,\n    macroDIP: macroDIPconst,\n    macroDUP: macroDUPconst,\n    macroSETCADR: macroSETCADRconst,\n    macroASSERTlist: macroASSERTlistConst,\n    constantData: ['Unit', 'True', 'False', 'None', 'instruction'],\n    singleArgData: ['Left', 'Right', 'Some'],\n    doubleArgData: ['Pair'],\n    elt: \"Elt\",\n    word: /[a-zA-Z_0-9]+/,\n    string: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/\n});\nconst checkC_R = c_r => {\n    var pattern = new RegExp('^C(A|D)(A|D)+R$');\n    return pattern.test(c_r);\n};\nconst expandC_R = (word, annot) => {\n    var expandedC_R = word.slice(1, -1).split('').map(c => (c === 'A' ? '{ \"prim\": \"CAR\" }' : '{ \"prim\": \"CDR\" }'));\n    if (annot != null) {\n        const lastChar = word.slice(-2, -1);\n        if (lastChar === 'A') {\n            expandedC_R[expandedC_R.length - 1] = `{ \"prim\": \"CAR\", \"annots\": [${annot}] }`;\n        }\n        else if (lastChar === 'D') {\n            expandedC_R[expandedC_R.length - 1] = `{ \"prim\": \"CDR\", \"annots\": [${annot}] }`;\n        }\n    }\n    return `[${expandedC_R.join(', ')}]`;\n};\nconst check_compare = cmp => macroCMPlist.includes(cmp);\nconst expand_cmp = (cmp, annot) => {\n    var op = cmp.substring(3);\n    var binary_op = keywordToJson([`${op}`]);\n    var compare = keywordToJson(['COMPARE']);\n    if (annot != null) {\n        binary_op = `{ \"prim\": \"${op}\", \"annots\": [${annot}] }`;\n    }\n    return `[${compare}, ${binary_op}]`;\n};\nconst check_dup = dup => DUPmatcher.test(dup);\nconst expand_dup = (dup, annot) => {\n    let t = '';\n    if (DUPmatcher.test(dup)) {\n        const c = dup.length - 3;\n        for (let i = 0; i < c; i++) {\n            t += '[{ \"prim\": \"DIP\", \"args\": [ ';\n        }\n        if (annot == null) {\n            t += `[{ \"prim\": \"DUP\" }]`;\n        }\n        else {\n            t += `[{ \"prim\": \"DUP\", \"annots\": [${annot}] }]`;\n        }\n        for (let i = 0; i < c; i++) {\n            t += ' ] },{\"prim\":\"SWAP\"}]';\n        }\n        return t;\n    }\n    throw new Error('');\n};\nconst check_assert = assert => macroASSERTlistConst.includes(assert);\nconst expand_assert = (assert, annot) => {\n    const annotation = !!annot ? `, \"annots\": [${annot}]` : '';\n    switch (assert) {\n        case 'ASSERT':\n            return `[{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_CMPEQ':\n            return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"EQ\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_CMPGE':\n            return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"GE\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_CMPGT':\n            return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"GT\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_CMPLE':\n            return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"LE\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_CMPLT':\n            return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"LT\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_CMPNEQ':\n            return `[[{\"prim\":\"COMPARE\"},{\"prim\":\"NEQ\"}],{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_EQ':\n            return `[{\"prim\":\"EQ\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]]`;\n        case 'ASSERT_GE':\n            return `[{\"prim\":\"GE\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_GT':\n            return `[{\"prim\":\"GT\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_LE':\n            return `[{\"prim\":\"LE\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_LT':\n            return `[{\"prim\":\"LT\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_NEQ':\n            return `[{\"prim\":\"NEQ\"},{\"prim\":\"IF\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"${annotation}}]]]}]`;\n        case 'ASSERT_NONE':\n            return '[{\"prim\":\"IF_NONE\",\"args\":[[],[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"}]]]}]';\n        case 'ASSERT_SOME':\n            return '[{\"prim\":\"IF_NONE\",\"args\":[[[{\"prim\":\"UNIT\"},{\"prim\":\"FAILWITH\"}]],[]]}]';\n        case 'ASSERT_LEFT':\n            return '';\n        case 'ASSERT_RIGHT':\n            return '';\n        default:\n            throw new Error(`Could not process ${assert}`);\n    }\n};\nconst check_fail = fail => fail === \"FAIL\";\nconst expand_fail = (fail, annot) => {\n    if (annot == null) {\n        return '[ { \"prim\": \"UNIT\" }, { \"prim\": \"FAILWITH\" } ]';\n    }\n    else {\n        return `[ { \"prim\": \"UNIT\" }, { \"prim\": \"FAILWITH\", \"annots\": [${annot}] } ]`;\n    }\n};\nconst check_if = ifStatement => (macroIFCMPlist.includes(ifStatement) || macroIFlist.includes(ifStatement) || ifStatement === 'IF_SOME');\nconst expandIF = (ifInstr, ifTrue, ifFalse, annot) => {\n    const annotation = !!annot ? `, \"annots\": [${annot}]` : '';\n    switch (ifInstr) {\n        case 'IFCMPEQ':\n            return `[{\"prim\":\"COMPARE\"},{\"prim\":\"EQ\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFCMPGE':\n            return `[{\"prim\":\"COMPARE\"},{\"prim\":\"GE\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFCMPGT':\n            return `[{\"prim\":\"COMPARE\"},{\"prim\":\"GT\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFCMPLE':\n            return `[{\"prim\":\"COMPARE\"},{\"prim\":\"LE\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFCMPLT':\n            return `[{\"prim\":\"COMPARE\"},{\"prim\":\"LT\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFCMPNEQ':\n            return `[{\"prim\":\"COMPARE\"},{\"prim\":\"NEQ\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFEQ':\n            return `[{\"prim\":\"EQ\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFGE':\n            return `[{\"prim\":\"GE\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFGT':\n            return `[{\"prim\":\"GT\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFLE':\n            return `[{\"prim\":\"LE\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFLT':\n            return `[{\"prim\":\"LT\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IFNEQ':\n            return `[{\"prim\":\"NEQ\"},{\"prim\":\"IF\",\"args\":[ [${ifTrue}] , [${ifFalse}]]${annotation}}]`;\n        case 'IF_SOME':\n            return `[{\"prim\":\"IF_NONE\",\"args\":[ [${ifFalse}], [${ifTrue}]]${annotation}}]`;\n        default:\n            throw new Error(`Could not process ${ifInstr}`);\n    }\n};\nconst check_dip = dip => DIPmatcher.test(dip);\nconst expandDIP = (dip, instruction, annot) => {\n    let t = '';\n    if (DIPmatcher.test(dip)) {\n        const c = dip.length - 2;\n        for (let i = 0; i < c; i++) {\n            t += '[{ \"prim\": \"DIP\", \"args\": [ ';\n        }\n        t = `${t} [ ${instruction} ] ]`;\n        if (!!annot) {\n            t = `${t}, \"annots\": [${annot}]`;\n        }\n        t += ' }]';\n        for (let i = 0; i < c - 1; i++) {\n            t += ' ] }]';\n        }\n        return t;\n    }\n    throw new Error(`Unexpected parameter for DIP processing: ${dip}`);\n};\nconst check_other = word => (word == \"UNPAIR\" || word == \"UNPAPAIR\");\nconst expand_other = (word, annot) => {\n    if (word == 'UNPAIR') {\n        if (annot == null) {\n            return '[ [ { \"prim\": \"DUP\" }, { \"prim\": \"CAR\" }, { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\" } ] ] } ] ]';\n        }\n        else if (annot.length == 1) {\n            return `[ [ { \"prim\": \"DUP\" }, { \"prim\": \"CAR\", \"annots\": [${annot}] }, { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\" } ] ]  } ] ]`;\n        }\n        else if (annot.length == 2) {\n            return `[ [ { \"prim\": \"DUP\" }, { \"prim\": \"CAR\", \"annots\": [${annot[0]}] }, { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\", \"annots\": [${annot[1]}] } ] ]  } ] ]`;\n        }\n        else {\n            return '';\n        }\n    }\n    if (word == 'UNPAPAIR') {\n        if (annot == null) {\n            return `[ [ { \"prim\": \"DUP\" },\n                            { \"prim\": \"CAR\" },\n                            { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\" } ] ] } ],\n                            {\"prim\":\"DIP\",\"args\":[[[{\"prim\":\"DUP\"},{\"prim\":\"CAR\"},{\"prim\":\"DIP\",\"args\":[[{\"prim\":\"CDR\"}]]}]]]}]`;\n        }\n        else {\n            return `[ [ { \"prim\": \"DUP\" },\n                            { \"prim\": \"CAR\" },\n                            { \"prim\": \"DIP\", \"args\": [ [ { \"prim\": \"CDR\" } ] ] } ],\n                            {\"prim\":\"DIP\",\"args\":[[[{\"prim\":\"DUP\"},{\"prim\":\"CAR\"},{\"prim\":\"DIP\",\"args\":[[{\"prim\":\"CDR\"}]],\"annots\": [${annot}]}]]]}]`;\n        }\n    }\n};\nconst checkSetCadr = s => macroSETCADRconst.test(s);\nconst expandSetCadr = (word, annot) => nestSetCadr(word.slice(5, -1));\nconst nestSetCadr = r => {\n    if (r.length === 0) {\n        return '';\n    }\n    const c = r.charAt(0);\n    if (r.length === 1) {\n        if (c === 'A') {\n            return '[{\"prim\": \"CDR\",\"annots\":[\"@%%\"]}, {\"prim\": \"SWAP\"}, {\"prim\": \"PAIR\",\"annots\":[\"%\",\"%@\"]}]';\n        }\n        else if (c === 'D') {\n            return '[{\"prim\": \"CAR\",\"annots\":[\"@%%\"]}, {\"prim\": \"PAIR\",\"annots\":[\"%@\",\"%\"]}]';\n        }\n    }\n    if (c === 'A') {\n        return `[{\"prim\": \"DUP\"}, {\"prim\": \"DIP\", \"args\": [[{\"prim\": \"CAR\",\"annots\":[\"@%%\"]}, ${nestSetCadr(r.slice(1))}]]}, {\"prim\": \"CDR\",\"annots\":[\"@%%\"]}, {\"prim\": \"SWAP\"}, {\"prim\": \"PAIR\",\"annots\":[\"%@\",\"%@\"]}]`;\n    }\n    else if (c === 'D') {\n        return `[{\"prim\": \"DUP\"}, {\"prim\": \"DIP\", \"args\": [[{\"prim\": \"CDR\",\"annots\":[\"@%%\"]}, ${nestSetCadr(r.slice(1))}]]}, {\"prim\": \"CAR\",\"annots\":[\"@%%\"]}, {\"prim\": \"PAIR\",\"annots\":[\"%@\",\"%@\"]}]`;\n    }\n};\nconst checkKeyword = word => {\n    if (check_assert(word)) {\n        return true;\n    }\n    if (check_compare(word)) {\n        return true;\n    }\n    if (check_dip(word)) {\n        return true;\n    }\n    if (check_dup(word)) {\n        return true;\n    }\n    if (check_fail(word)) {\n        return true;\n    }\n    if (check_if(word)) {\n        return true;\n    }\n    if (checkC_R(word)) {\n        return true;\n    }\n    if (check_other(word)) {\n        return true;\n    }\n    if (checkSetCadr(word)) {\n        return true;\n    }\n};\nconst expandKeyword = (word, annot) => {\n    if (checkC_R(word)) {\n        return expandC_R(word, annot);\n    }\n    if (check_assert(word)) {\n        return expand_assert(word, annot);\n    }\n    if (check_compare(word)) {\n        return expand_cmp(word, annot);\n    }\n    if (check_dip(word)) {\n        return expandDIP(word, annot);\n    }\n    if (check_dup(word)) {\n        return expand_dup(word, annot);\n    }\n    if (check_fail(word)) {\n        return expand_fail(word, annot);\n    }\n    if (check_if(word)) {\n        return expandIF(word, annot);\n    }\n    if (check_other(word)) {\n        return expand_other(word, annot);\n    }\n    if (checkSetCadr(word)) {\n        return expandSetCadr(word, annot);\n    }\n};\nconst intToJson = d => `{ \"int\": \"${parseInt(d[0])}\" }`;\nconst stringToJson = d => `{ \"string\": ${d[0]} }`;\nconst bytesToJson = d => `{ \"bytes\": \"${d[0].toString().slice(2)}\" }`;\nconst keywordToJson = d => {\n    const word = d[0].toString();\n    if (d.length == 1) {\n        if (checkKeyword(word)) {\n            return [expandKeyword(word, null)];\n        }\n        else {\n            return `{ \"prim\": \"${d[0]}\" }`;\n        }\n    }\n    else {\n        const annot = d[1].map(x => `\"${x[1]}\"`);\n        if (checkKeyword(word)) {\n            return [expandKeyword(word, annot)];\n        }\n        else {\n            return `{ \"prim\": \"${d[0]}\", \"annots\": [${annot}] }`;\n        }\n    }\n};\nconst singleArgKeywordToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]} ] }`;\nconst comparableTypeToJson = d => {\n    const annot = d[3].map(x => `\"${x[1]}\"`);\n    return `{ \"prim\": \"${d[2]}\", \"annots\": [${annot}]  }`;\n};\nconst singleArgTypeKeywordWithParenToJson = d => {\n    const annot = d[3].map(x => `\"${x[1]}\"`);\n    return `{ \"prim\": \"${d[2]}\", \"args\": [ ${d[5]} ], \"annots\": [${annot}]  }`;\n};\nconst singleArgInstrKeywordToJson = d => {\n    const word = `${d[0].toString()}`;\n    if (check_dip(word)) {\n        return expandDIP(word, d[2]);\n    }\n    else {\n        return `{ \"prim\": \"${d[0]}\", \"args\": [ [ ${d[2]} ] ] }`;\n    }\n};\nconst singleArgTypeKeywordToJson = d => {\n    const word = `${d[0].toString()}`;\n    const annot = d[1].map(x => `\"${x[1]}\"`);\n    if (check_dip(word)) {\n        return expandDIP(word, d[2], annot);\n    }\n    else {\n        return `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[3]} ], \"annots\": [${annot}] }`;\n    }\n};\nconst singleArgKeywordWithParenToJson = d => `{ \"prim\": \"${d[2]}\", \"args\": [ ${d[(4 + ((d.length === 7) ? 0 : 2))]} ] }`;\nconst doubleArgKeywordToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]}, ${d[4]} ] }`;\nconst doubleArgParenKeywordToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[4]}, ${d[8]} ] }`;\nconst doubleArgInstrKeywordToJson = d => {\n    const word = `${d[0].toString()}`;\n    if (check_if(word)) {\n        return expandIF(word, d[2], d[4]);\n    }\n    else {\n        return `{ \"prim\": \"${d[0]}\", \"args\": [ [${d[2]}], [${d[4]}] ] }`;\n    }\n};\nconst doubleArgKeywordWithParenToJson = d => `{ \"prim\": \"${d[2]}\", \"args\": [ ${d[4]}, ${d[6]} ] }`;\nconst tripleArgKeyWordToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]}, ${d[4]}, [${d[6]}] ] }`;\nconst tripleArgKeyWordWithParenToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]}, ${d[4]}, ${d[6]} ] }`;\nconst nestedArrayChecker = x => {\n    if (Array.isArray(x) && Array.isArray(x[0])) {\n        return x[0];\n    }\n    else {\n        return x;\n    }\n};\nconst instructionSetToJsonNoSemi = d => { return d[2].map(x => x[0]).concat(d[3]).map(x => nestedArrayChecker(x)); };\nconst instructionSetToJsonSemi = d => { return `${d[2].map(x => x[0]).map(x => nestedArrayChecker(x))}`; };\nconst dataListToJsonSemi = d => { return `[ ${d[2].map(x => x[0]).map(x => nestedArrayChecker(x))} ]`; };\nconst scriptToJson = d => `[ ${d[0]}, ${d[2]}, { \"prim\": \"code\", \"args\": [ [ ${d[4]} ] ] } ]`;\nconst doubleArgTypeKeywordToJson = d => {\n    const annot = d[1].map(x => `\"${x[1]}\"`);\n    return `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[4]}, ${d[6]} ], \"annots\": [${annot}]  }`;\n};\nconst doubleArgTypeKeywordWithParenToJson = d => {\n    const annot = d[3].map(x => `\"${x[1]}\"`);\n    return `{ \"prim\": \"${d[2]}\", \"args\": [ ${d[5]}, ${d[7]} ], \"annots\": [${annot}]  }`;\n};\nconst tripleArgTypeKeyWordToJson = d => {\n    const annot = d[1].map(x => `\"${x[1]}\"`);\n    return `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[3]}, ${d[5]}, ${d[7]} ], \"annots\": [${annot}]  }`;\n};\nconst pushToJson = d => {\n    return `{ \"prim\": \"${d[0]}\", \"args\": [${d[2]}, []] }`;\n};\nconst pushWithAnnotsToJson = d => {\n    const annot = d[1].map(x => `\"${x[1]}\"`);\n    return `{ \"prim\": \"PUSH\", \"args\": [ ${d[3]}, ${d[5]} ], \"annots\": [${annot}]  }`;\n};\nconst dipnToJson = d => (d.length > 4) ? `{ \"prim\": \"${d[0]}\", \"args\": [ { \"int\": \"${d[2]}\" }, [ ${d[4]} ] ] }` : `{ \"prim\": \"${d[0]}\", \"args\": [ ${d[2]} ] }`;\nconst dupnToJson = d => {\n    const n = Number(d[2]);\n    if (n === 1) {\n        return '{ \"prim\": \"DUP\" }';\n    }\n    else if (n === 2) {\n        return '[{ \"prim\": \"DIP\", \"args\": [[ {\"prim\": \"DUP\"} ]] }, { \"prim\": \"SWAP\" }]';\n    }\n    else {\n        return `[{ \"prim\": \"DIP\", \"args\": [ {\"int\": \"${n - 1}\"}, [{ \"prim\": \"DUP\" }] ] }, { \"prim\": \"DIG\", \"args\": [ {\"int\": \"${n}\"} ] }]`;\n    }\n};\nconst dignToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ { \"int\": \"${d[2]}\" } ] }`;\nconst dropnToJson = d => `{ \"prim\": \"${d[0]}\", \"args\": [ { \"int\": \"${d[2]}\" } ] }`;\nconst subContractToJson = d => `{ \"prim\":\"CREATE_CONTRACT\", \"args\": [ [ ${d[4]}, ${d[6]}, {\"prim\": \"code\" , \"args\":[ [ ${d[8]} ] ] } ] ] }`;\nconst instructionListToJson = d => {\n    const instructionOne = [d[2]];\n    const instructionList = d[3].map(x => x[3]);\n    return instructionOne.concat(instructionList).map(x => nestedArrayChecker(x));\n};\n;\n;\n;\n;\nconst grammar = {\n    Lexer: lexer,\n    ParserRules: [\n        { \"name\": \"main\", \"symbols\": [\"instruction\"], \"postprocess\": id },\n        { \"name\": \"main\", \"symbols\": [\"data\"], \"postprocess\": id },\n        { \"name\": \"main\", \"symbols\": [\"type\"], \"postprocess\": id },\n        { \"name\": \"main\", \"symbols\": [\"parameter\"], \"postprocess\": id },\n        { \"name\": \"main\", \"symbols\": [\"storage\"], \"postprocess\": id },\n        { \"name\": \"main\", \"symbols\": [\"code\"], \"postprocess\": id },\n        { \"name\": \"main\", \"symbols\": [\"script\"], \"postprocess\": id },\n        { \"name\": \"main\", \"symbols\": [\"parameterValue\"], \"postprocess\": id },\n        { \"name\": \"main\", \"symbols\": [\"storageValue\"], \"postprocess\": id },\n        { \"name\": \"main\", \"symbols\": [\"typeData\"], \"postprocess\": id },\n        { \"name\": \"script\", \"symbols\": [\"parameter\", \"_\", \"storage\", \"_\", \"code\"], \"postprocess\": scriptToJson },\n        { \"name\": \"parameterValue\", \"symbols\": [(lexer.has(\"parameter\") ? { type: \"parameter\" } : parameter), \"_\", \"typeData\", \"_\", \"semicolons\"], \"postprocess\": singleArgKeywordToJson },\n        { \"name\": \"storageValue\", \"symbols\": [(lexer.has(\"storage\") ? { type: \"storage\" } : storage), \"_\", \"typeData\", \"_\", \"semicolons\"], \"postprocess\": singleArgKeywordToJson },\n        { \"name\": \"parameter\", \"symbols\": [(lexer.has(\"parameter\") ? { type: \"parameter\" } : parameter), \"_\", \"type\", \"_\", \"semicolons\"], \"postprocess\": singleArgKeywordToJson },\n        { \"name\": \"storage\", \"symbols\": [(lexer.has(\"storage\") ? { type: \"storage\" } : storage), \"_\", \"type\", \"_\", \"semicolons\"], \"postprocess\": singleArgKeywordToJson },\n        { \"name\": \"code\", \"symbols\": [(lexer.has(\"code\") ? { type: \"code\" } : code), \"_\", \"subInstruction\", \"_\", \"semicolons\", \"_\"], \"postprocess\": d => d[2] },\n        { \"name\": \"code\", \"symbols\": [(lexer.has(\"code\") ? { type: \"code\" } : code), \"_\", { \"literal\": \"{};\" }], \"postprocess\": d => \"code {}\" },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"comparableType\") ? { type: \"comparableType\" } : comparableType)], \"postprocess\": keywordToJson },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"constantType\") ? { type: \"constantType\" } : constantType)], \"postprocess\": keywordToJson },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"singleArgType\") ? { type: \"singleArgType\" } : singleArgType), \"_\", \"type\"], \"postprocess\": singleArgKeywordToJson },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", (lexer.has(\"singleArgType\") ? { type: \"singleArgType\" } : singleArgType), \"_\", \"type\", \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": singleArgKeywordWithParenToJson },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", (lexer.has(\"singleArgType\") ? { type: \"singleArgType\" } : singleArgType), \"_\", (lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", \"type\", \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen), \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": singleArgKeywordWithParenToJson },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"doubleArgType\") ? { type: \"doubleArgType\" } : doubleArgType), \"_\", \"type\", \"_\", \"type\"], \"postprocess\": doubleArgKeywordToJson },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", (lexer.has(\"doubleArgType\") ? { type: \"doubleArgType\" } : doubleArgType), \"_\", \"type\", \"_\", \"type\", \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": doubleArgKeywordWithParenToJson },\n        { \"name\": \"type$ebnf$1$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$1\", \"symbols\": [\"type$ebnf$1$subexpression$1\"] },\n        { \"name\": \"type$ebnf$1$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$1\", \"symbols\": [\"type$ebnf$1\", \"type$ebnf$1$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"comparableType\") ? { type: \"comparableType\" } : comparableType), \"type$ebnf$1\"], \"postprocess\": keywordToJson },\n        { \"name\": \"type$ebnf$2$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$2\", \"symbols\": [\"type$ebnf$2$subexpression$1\"] },\n        { \"name\": \"type$ebnf$2$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$2\", \"symbols\": [\"type$ebnf$2\", \"type$ebnf$2$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"constantType\") ? { type: \"constantType\" } : constantType), \"type$ebnf$2\"], \"postprocess\": keywordToJson },\n        { \"name\": \"type$ebnf$3$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$3\", \"symbols\": [\"type$ebnf$3$subexpression$1\"] },\n        { \"name\": \"type$ebnf$3$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$3\", \"symbols\": [\"type$ebnf$3\", \"type$ebnf$3$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", (lexer.has(\"comparableType\") ? { type: \"comparableType\" } : comparableType), \"type$ebnf$3\", \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": comparableTypeToJson },\n        { \"name\": \"type$ebnf$4$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$4\", \"symbols\": [\"type$ebnf$4$subexpression$1\"] },\n        { \"name\": \"type$ebnf$4$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$4\", \"symbols\": [\"type$ebnf$4\", \"type$ebnf$4$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", (lexer.has(\"constantType\") ? { type: \"constantType\" } : constantType), \"type$ebnf$4\", \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": comparableTypeToJson },\n        { \"name\": \"type$ebnf$5$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$5\", \"symbols\": [\"type$ebnf$5$subexpression$1\"] },\n        { \"name\": \"type$ebnf$5$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$5\", \"symbols\": [\"type$ebnf$5\", \"type$ebnf$5$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", (lexer.has(\"singleArgType\") ? { type: \"singleArgType\" } : singleArgType), \"type$ebnf$5\", \"_\", \"type\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": singleArgTypeKeywordWithParenToJson },\n        { \"name\": \"type$ebnf$6$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$6\", \"symbols\": [\"type$ebnf$6$subexpression$1\"] },\n        { \"name\": \"type$ebnf$6$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"type$ebnf$6\", \"symbols\": [\"type$ebnf$6\", \"type$ebnf$6$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"type\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", (lexer.has(\"doubleArgType\") ? { type: \"doubleArgType\" } : doubleArgType), \"type$ebnf$6\", \"_\", \"type\", \"_\", \"type\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": doubleArgTypeKeywordWithParenToJson },\n        { \"name\": \"typeData\", \"symbols\": [(lexer.has(\"singleArgType\") ? { type: \"singleArgType\" } : singleArgType), \"_\", \"typeData\"], \"postprocess\": singleArgKeywordToJson },\n        { \"name\": \"typeData\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", (lexer.has(\"singleArgType\") ? { type: \"singleArgType\" } : singleArgType), \"_\", \"typeData\", \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": singleArgKeywordWithParenToJson },\n        { \"name\": \"typeData\", \"symbols\": [(lexer.has(\"doubleArgType\") ? { type: \"doubleArgType\" } : doubleArgType), \"_\", \"typeData\", \"_\", \"typeData\"], \"postprocess\": doubleArgKeywordToJson },\n        { \"name\": \"typeData\", \"symbols\": [(lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", (lexer.has(\"doubleArgType\") ? { type: \"doubleArgType\" } : doubleArgType), \"_\", \"typeData\", \"_\", \"typeData\", \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen)], \"postprocess\": doubleArgKeywordWithParenToJson },\n        { \"name\": \"typeData\", \"symbols\": [\"subTypeData\"], \"postprocess\": id },\n        { \"name\": \"typeData\", \"symbols\": [\"subTypeElt\"], \"postprocess\": id },\n        { \"name\": \"typeData\", \"symbols\": [(lexer.has(\"number\") ? { type: \"number\" } : number)], \"postprocess\": intToJson },\n        { \"name\": \"typeData\", \"symbols\": [(lexer.has(\"string\") ? { type: \"string\" } : string)], \"postprocess\": stringToJson },\n        { \"name\": \"typeData\", \"symbols\": [(lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": d => [] },\n        { \"name\": \"data\", \"symbols\": [(lexer.has(\"constantData\") ? { type: \"constantData\" } : constantData)], \"postprocess\": keywordToJson },\n        { \"name\": \"data\", \"symbols\": [(lexer.has(\"singleArgData\") ? { type: \"singleArgData\" } : singleArgData), \"_\", \"data\"], \"postprocess\": singleArgKeywordToJson },\n        { \"name\": \"data\", \"symbols\": [(lexer.has(\"doubleArgData\") ? { type: \"doubleArgData\" } : doubleArgData), \"_\", \"data\", \"_\", \"data\"], \"postprocess\": doubleArgKeywordToJson },\n        { \"name\": \"data\", \"symbols\": [\"subData\"], \"postprocess\": id },\n        { \"name\": \"data\", \"symbols\": [\"subElt\"], \"postprocess\": id },\n        { \"name\": \"data\", \"symbols\": [(lexer.has(\"string\") ? { type: \"string\" } : string)], \"postprocess\": stringToJson },\n        { \"name\": \"data\", \"symbols\": [(lexer.has(\"bytes\") ? { type: \"bytes\" } : bytes)], \"postprocess\": bytesToJson },\n        { \"name\": \"data\", \"symbols\": [(lexer.has(\"number\") ? { type: \"number\" } : number)], \"postprocess\": intToJson },\n        { \"name\": \"subData\", \"symbols\": [(lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": d => \"[]\" },\n        { \"name\": \"subData$ebnf$1$subexpression$1\", \"symbols\": [\"data\", \"_\"] },\n        { \"name\": \"subData$ebnf$1\", \"symbols\": [\"subData$ebnf$1$subexpression$1\"] },\n        { \"name\": \"subData$ebnf$1$subexpression$2\", \"symbols\": [\"data\", \"_\"] },\n        { \"name\": \"subData$ebnf$1\", \"symbols\": [\"subData$ebnf$1\", \"subData$ebnf$1$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"subData\", \"symbols\": [{ \"literal\": \"(\" }, \"_\", \"subData$ebnf$1\", { \"literal\": \")\" }], \"postprocess\": instructionSetToJsonSemi },\n        { \"name\": \"subData$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subData$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subData$ebnf$2$subexpression$1\", \"symbols\": [\"data\", \"_\", \"subData$ebnf$2$subexpression$1$ebnf$1\", \"_\"] },\n        { \"name\": \"subData$ebnf$2\", \"symbols\": [\"subData$ebnf$2$subexpression$1\"] },\n        { \"name\": \"subData$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subData$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subData$ebnf$2$subexpression$2\", \"symbols\": [\"data\", \"_\", \"subData$ebnf$2$subexpression$2$ebnf$1\", \"_\"] },\n        { \"name\": \"subData$ebnf$2\", \"symbols\": [\"subData$ebnf$2\", \"subData$ebnf$2$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"subData\", \"symbols\": [{ \"literal\": \"{\" }, \"_\", \"subData$ebnf$2\", { \"literal\": \"}\" }], \"postprocess\": dataListToJsonSemi },\n        { \"name\": \"subElt\", \"symbols\": [(lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": d => \"[]\" },\n        { \"name\": \"subElt$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subElt$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subElt$ebnf$1$subexpression$1\", \"symbols\": [\"elt\", \"subElt$ebnf$1$subexpression$1$ebnf$1\", \"_\"] },\n        { \"name\": \"subElt$ebnf$1\", \"symbols\": [\"subElt$ebnf$1$subexpression$1\"] },\n        { \"name\": \"subElt$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subElt$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subElt$ebnf$1$subexpression$2\", \"symbols\": [\"elt\", \"subElt$ebnf$1$subexpression$2$ebnf$1\", \"_\"] },\n        { \"name\": \"subElt$ebnf$1\", \"symbols\": [\"subElt$ebnf$1\", \"subElt$ebnf$1$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"subElt\", \"symbols\": [{ \"literal\": \"{\" }, \"_\", \"subElt$ebnf$1\", { \"literal\": \"}\" }], \"postprocess\": dataListToJsonSemi },\n        { \"name\": \"elt\", \"symbols\": [(lexer.has(\"elt\") ? { type: \"elt\" } : elt), \"_\", \"data\", \"_\", \"data\"], \"postprocess\": doubleArgKeywordToJson },\n        { \"name\": \"subTypeData\", \"symbols\": [(lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": d => \"[]\" },\n        { \"name\": \"subTypeData$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subTypeData$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subTypeData$ebnf$1$subexpression$1\", \"symbols\": [\"data\", \"subTypeData$ebnf$1$subexpression$1$ebnf$1\", \"_\"] },\n        { \"name\": \"subTypeData$ebnf$1\", \"symbols\": [\"subTypeData$ebnf$1$subexpression$1\"] },\n        { \"name\": \"subTypeData$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subTypeData$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subTypeData$ebnf$1$subexpression$2\", \"symbols\": [\"data\", \"subTypeData$ebnf$1$subexpression$2$ebnf$1\", \"_\"] },\n        { \"name\": \"subTypeData$ebnf$1\", \"symbols\": [\"subTypeData$ebnf$1\", \"subTypeData$ebnf$1$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"subTypeData\", \"symbols\": [{ \"literal\": \"{\" }, \"_\", \"subTypeData$ebnf$1\", { \"literal\": \"}\" }], \"postprocess\": instructionSetToJsonSemi },\n        { \"name\": \"subTypeData$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subTypeData$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subTypeData$ebnf$2$subexpression$1\", \"symbols\": [\"data\", \"subTypeData$ebnf$2$subexpression$1$ebnf$1\", \"_\"] },\n        { \"name\": \"subTypeData$ebnf$2\", \"symbols\": [\"subTypeData$ebnf$2$subexpression$1\"] },\n        { \"name\": \"subTypeData$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subTypeData$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subTypeData$ebnf$2$subexpression$2\", \"symbols\": [\"data\", \"subTypeData$ebnf$2$subexpression$2$ebnf$1\", \"_\"] },\n        { \"name\": \"subTypeData$ebnf$2\", \"symbols\": [\"subTypeData$ebnf$2\", \"subTypeData$ebnf$2$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"subTypeData\", \"symbols\": [{ \"literal\": \"(\" }, \"_\", \"subTypeData$ebnf$2\", { \"literal\": \")\" }], \"postprocess\": instructionSetToJsonSemi },\n        { \"name\": \"subTypeElt\", \"symbols\": [(lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": d => \"[]\" },\n        { \"name\": \"subTypeElt$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subTypeElt$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subTypeElt$ebnf$1$subexpression$1\", \"symbols\": [\"typeElt\", \"subTypeElt$ebnf$1$subexpression$1$ebnf$1\", \"_\"] },\n        { \"name\": \"subTypeElt$ebnf$1\", \"symbols\": [\"subTypeElt$ebnf$1$subexpression$1\"] },\n        { \"name\": \"subTypeElt$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subTypeElt$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subTypeElt$ebnf$1$subexpression$2\", \"symbols\": [\"typeElt\", \"subTypeElt$ebnf$1$subexpression$2$ebnf$1\", \"_\"] },\n        { \"name\": \"subTypeElt$ebnf$1\", \"symbols\": [\"subTypeElt$ebnf$1\", \"subTypeElt$ebnf$1$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"subTypeElt\", \"symbols\": [{ \"literal\": \"[{\" }, \"_\", \"subTypeElt$ebnf$1\", { \"literal\": \"}]\" }], \"postprocess\": instructionSetToJsonSemi },\n        { \"name\": \"subTypeElt$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subTypeElt$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subTypeElt$ebnf$2$subexpression$1\", \"symbols\": [\"typeElt\", \"_\", \"subTypeElt$ebnf$2$subexpression$1$ebnf$1\", \"_\"] },\n        { \"name\": \"subTypeElt$ebnf$2\", \"symbols\": [\"subTypeElt$ebnf$2$subexpression$1\"] },\n        { \"name\": \"subTypeElt$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [{ \"literal\": \";\" }], \"postprocess\": id },\n        { \"name\": \"subTypeElt$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"subTypeElt$ebnf$2$subexpression$2\", \"symbols\": [\"typeElt\", \"_\", \"subTypeElt$ebnf$2$subexpression$2$ebnf$1\", \"_\"] },\n        { \"name\": \"subTypeElt$ebnf$2\", \"symbols\": [\"subTypeElt$ebnf$2\", \"subTypeElt$ebnf$2$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"subTypeElt\", \"symbols\": [{ \"literal\": \"[{\" }, \"_\", \"subTypeElt$ebnf$2\", { \"literal\": \"}]\" }], \"postprocess\": instructionSetToJsonSemi },\n        { \"name\": \"typeElt\", \"symbols\": [(lexer.has(\"elt\") ? { type: \"elt\" } : elt), \"_\", \"typeData\", \"_\", \"typeData\"], \"postprocess\": doubleArgKeywordToJson },\n        { \"name\": \"subInstruction\", \"symbols\": [(lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": d => \"\" },\n        { \"name\": \"subInstruction\", \"symbols\": [(lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", \"instruction\", \"_\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": d => d[2] },\n        { \"name\": \"subInstruction$ebnf$1$subexpression$1\", \"symbols\": [\"instruction\", \"_\", (lexer.has(\"semicolon\") ? { type: \"semicolon\" } : semicolon), \"_\"] },\n        { \"name\": \"subInstruction$ebnf$1\", \"symbols\": [\"subInstruction$ebnf$1$subexpression$1\"] },\n        { \"name\": \"subInstruction$ebnf$1$subexpression$2\", \"symbols\": [\"instruction\", \"_\", (lexer.has(\"semicolon\") ? { type: \"semicolon\" } : semicolon), \"_\"] },\n        { \"name\": \"subInstruction$ebnf$1\", \"symbols\": [\"subInstruction$ebnf$1\", \"subInstruction$ebnf$1$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"subInstruction\", \"symbols\": [(lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", \"subInstruction$ebnf$1\", \"instruction\", \"_\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": instructionSetToJsonNoSemi },\n        { \"name\": \"subInstruction$ebnf$2$subexpression$1\", \"symbols\": [\"instruction\", \"_\", (lexer.has(\"semicolon\") ? { type: \"semicolon\" } : semicolon), \"_\"] },\n        { \"name\": \"subInstruction$ebnf$2\", \"symbols\": [\"subInstruction$ebnf$2$subexpression$1\"] },\n        { \"name\": \"subInstruction$ebnf$2$subexpression$2\", \"symbols\": [\"instruction\", \"_\", (lexer.has(\"semicolon\") ? { type: \"semicolon\" } : semicolon), \"_\"] },\n        { \"name\": \"subInstruction$ebnf$2\", \"symbols\": [\"subInstruction$ebnf$2\", \"subInstruction$ebnf$2$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"subInstruction\", \"symbols\": [(lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", \"subInstruction$ebnf$2\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": instructionSetToJsonSemi },\n        { \"name\": \"instructions\", \"symbols\": [(lexer.has(\"baseInstruction\") ? { type: \"baseInstruction\" } : baseInstruction)] },\n        { \"name\": \"instructions\", \"symbols\": [(lexer.has(\"macroCADR\") ? { type: \"macroCADR\" } : macroCADR)] },\n        { \"name\": \"instructions\", \"symbols\": [(lexer.has(\"macroDIP\") ? { type: \"macroDIP\" } : macroDIP)] },\n        { \"name\": \"instructions\", \"symbols\": [(lexer.has(\"macroDUP\") ? { type: \"macroDUP\" } : macroDUP)] },\n        { \"name\": \"instructions\", \"symbols\": [(lexer.has(\"macroSETCADR\") ? { type: \"macroSETCADR\" } : macroSETCADR)] },\n        { \"name\": \"instructions\", \"symbols\": [(lexer.has(\"macroASSERTlist\") ? { type: \"macroASSERTlist\" } : macroASSERTlist)] },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\"], \"postprocess\": keywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [\"subInstruction\"], \"postprocess\": id },\n        { \"name\": \"instruction$ebnf$1$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$1\", \"symbols\": [\"instruction$ebnf$1$subexpression$1\"] },\n        { \"name\": \"instruction$ebnf$1$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$1\", \"symbols\": [\"instruction$ebnf$1\", \"instruction$ebnf$1$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"instruction$ebnf$1\", \"_\"], \"postprocess\": keywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"_\", \"subInstruction\"], \"postprocess\": singleArgInstrKeywordToJson },\n        { \"name\": \"instruction$ebnf$2$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$2\", \"symbols\": [\"instruction$ebnf$2$subexpression$1\"] },\n        { \"name\": \"instruction$ebnf$2$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$2\", \"symbols\": [\"instruction$ebnf$2\", \"instruction$ebnf$2$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"instruction$ebnf$2\", \"_\", \"subInstruction\"], \"postprocess\": singleArgTypeKeywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"_\", \"type\"], \"postprocess\": singleArgKeywordToJson },\n        { \"name\": \"instruction$ebnf$3$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$3\", \"symbols\": [\"instruction$ebnf$3$subexpression$1\"] },\n        { \"name\": \"instruction$ebnf$3$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$3\", \"symbols\": [\"instruction$ebnf$3\", \"instruction$ebnf$3$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"instruction$ebnf$3\", \"_\", \"type\"], \"postprocess\": singleArgTypeKeywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"_\", \"data\"], \"postprocess\": singleArgKeywordToJson },\n        { \"name\": \"instruction$ebnf$4$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$4\", \"symbols\": [\"instruction$ebnf$4$subexpression$1\"] },\n        { \"name\": \"instruction$ebnf$4$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$4\", \"symbols\": [\"instruction$ebnf$4\", \"instruction$ebnf$4$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"instruction$ebnf$4\", \"_\", \"data\"], \"postprocess\": singleArgTypeKeywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"_\", \"type\", \"_\", \"type\", \"_\", \"subInstruction\"], \"postprocess\": tripleArgKeyWordToJson },\n        { \"name\": \"instruction$ebnf$5$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$5\", \"symbols\": [\"instruction$ebnf$5$subexpression$1\"] },\n        { \"name\": \"instruction$ebnf$5$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$5\", \"symbols\": [\"instruction$ebnf$5\", \"instruction$ebnf$5$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"instruction$ebnf$5\", \"_\", \"type\", \"_\", \"type\", \"_\", \"subInstruction\"], \"postprocess\": tripleArgTypeKeyWordToJson },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"_\", \"subInstruction\", \"_\", \"subInstruction\"], \"postprocess\": doubleArgInstrKeywordToJson },\n        { \"name\": \"instruction$ebnf$6$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$6\", \"symbols\": [\"instruction$ebnf$6$subexpression$1\"] },\n        { \"name\": \"instruction$ebnf$6$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$6\", \"symbols\": [\"instruction$ebnf$6\", \"instruction$ebnf$6$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"instruction$ebnf$6\", \"_\", \"subInstruction\", \"_\", \"subInstruction\"], \"postprocess\": doubleArgTypeKeywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"_\", \"type\", \"_\", \"type\"], \"postprocess\": doubleArgKeywordToJson },\n        { \"name\": \"instruction$ebnf$7$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$7\", \"symbols\": [\"instruction$ebnf$7$subexpression$1\"] },\n        { \"name\": \"instruction$ebnf$7$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$7\", \"symbols\": [\"instruction$ebnf$7\", \"instruction$ebnf$7$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [\"instructions\", \"instruction$ebnf$7\", \"_\", \"type\", \"_\", \"type\"], \"postprocess\": doubleArgTypeKeywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"PUSH\" }, \"_\", \"type\", \"_\", \"data\"], \"postprocess\": doubleArgKeywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"PUSH\" }, \"_\", \"type\", \"_\", (lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": pushToJson },\n        { \"name\": \"instruction$ebnf$8$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$8\", \"symbols\": [\"instruction$ebnf$8$subexpression$1\"] },\n        { \"name\": \"instruction$ebnf$8$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$8\", \"symbols\": [\"instruction$ebnf$8\", \"instruction$ebnf$8$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"PUSH\" }, \"instruction$ebnf$8\", \"_\", \"type\", \"_\", \"data\"], \"postprocess\": pushWithAnnotsToJson },\n        { \"name\": \"instruction$ebnf$9\", \"symbols\": [/[0-9]/] },\n        { \"name\": \"instruction$ebnf$9\", \"symbols\": [\"instruction$ebnf$9\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"DIP\" }, \"_\", \"instruction$ebnf$9\", \"_\", \"subInstruction\"], \"postprocess\": dipnToJson },\n        { \"name\": \"instruction$ebnf$10\", \"symbols\": [/[0-9]/] },\n        { \"name\": \"instruction$ebnf$10\", \"symbols\": [\"instruction$ebnf$10\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"DUP\" }, \"_\", \"instruction$ebnf$10\"], \"postprocess\": dupnToJson },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"DUP\" }], \"postprocess\": keywordToJson },\n        { \"name\": \"instruction$ebnf$11$subexpression$1\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$11\", \"symbols\": [\"instruction$ebnf$11$subexpression$1\"] },\n        { \"name\": \"instruction$ebnf$11$subexpression$2\", \"symbols\": [\"_\", (lexer.has(\"annot\") ? { type: \"annot\" } : annot)] },\n        { \"name\": \"instruction$ebnf$11\", \"symbols\": [\"instruction$ebnf$11\", \"instruction$ebnf$11$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"DUP\" }, \"instruction$ebnf$11\", \"_\"], \"postprocess\": keywordToJson },\n        { \"name\": \"instruction$ebnf$12\", \"symbols\": [/[0-9]/] },\n        { \"name\": \"instruction$ebnf$12\", \"symbols\": [\"instruction$ebnf$12\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"DIG\" }, \"_\", \"instruction$ebnf$12\"], \"postprocess\": dignToJson },\n        { \"name\": \"instruction$ebnf$13\", \"symbols\": [/[0-9]/] },\n        { \"name\": \"instruction$ebnf$13\", \"symbols\": [\"instruction$ebnf$13\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"DUG\" }, \"_\", \"instruction$ebnf$13\"], \"postprocess\": dignToJson },\n        { \"name\": \"instruction$ebnf$14\", \"symbols\": [/[0-9]/] },\n        { \"name\": \"instruction$ebnf$14\", \"symbols\": [\"instruction$ebnf$14\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"DROP\" }, \"_\", \"instruction$ebnf$14\"], \"postprocess\": dropnToJson },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"DROP\" }], \"postprocess\": keywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"CREATE_CONTRACT\" }, \"_\", (lexer.has(\"lbrace\") ? { type: \"lbrace\" } : lbrace), \"_\", \"parameter\", \"_\", \"storage\", \"_\", \"code\", \"_\", (lexer.has(\"rbrace\") ? { type: \"rbrace\" } : rbrace)], \"postprocess\": subContractToJson },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"EMPTY_MAP\" }, \"_\", \"type\", \"_\", \"type\"], \"postprocess\": doubleArgKeywordToJson },\n        { \"name\": \"instruction\", \"symbols\": [{ \"literal\": \"EMPTY_MAP\" }, \"_\", (lexer.has(\"lparen\") ? { type: \"lparen\" } : lparen), \"_\", \"type\", \"_\", (lexer.has(\"rparen\") ? { type: \"rparen\" } : rparen), \"_\", \"type\"], \"postprocess\": doubleArgParenKeywordToJson },\n        { \"name\": \"_$ebnf$1\", \"symbols\": [] },\n        { \"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", /[\\s]/], \"postprocess\": (d) => d[0].concat([d[1]]) },\n        { \"name\": \"_\", \"symbols\": [\"_$ebnf$1\"] },\n        { \"name\": \"semicolons$ebnf$1\", \"symbols\": [/[;]/], \"postprocess\": id },\n        { \"name\": \"semicolons$ebnf$1\", \"symbols\": [], \"postprocess\": () => null },\n        { \"name\": \"semicolons\", \"symbols\": [\"semicolons$ebnf$1\"] }\n    ],\n    ParserStart: \"main\",\n};\nexports.default = grammar;\n//# sourceMappingURL=Michelson.js.map"]},"metadata":{},"sourceType":"script"}