{"ast":null,"code":"(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n    /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory();\n  } else {\n    root.moo = factory();\n  }\n})(this, function () {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var toString = Object.prototype.toString;\n  var hasSticky = typeof new RegExp().sticky === 'boolean';\n  /***************************************************************************/\n\n  function isRegExp(o) {\n    return o && toString.call(o) === '[object RegExp]';\n  }\n\n  function isObject(o) {\n    return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o);\n  }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  }\n\n  function reGroups(s) {\n    var re = new RegExp('|' + s);\n    return re.exec('').length - 1;\n  }\n\n  function reCapture(s) {\n    return '(' + s + ')';\n  }\n\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)';\n    var source = regexps.map(function (s) {\n      return \"(?:\" + s + \")\";\n    }).join('|');\n    return \"(?:\" + source + \")\";\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')';\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed');\n      if (obj.global) throw new Error('RegExp /g flag is implied');\n      if (obj.sticky) throw new Error('RegExp /y flag is implied');\n      if (obj.multiline) throw new Error('RegExp /m flag is implied');\n      if (obj.unicode) throw new Error('RegExp /u flag is not allowed');\n      return obj.source;\n    } else {\n      throw new Error('Not a pattern: ' + obj);\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object);\n    var result = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var thing = object[key];\n      var rules = [].concat(thing);\n\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({\n            include: rules[j]\n          });\n        }\n\n        continue;\n      }\n\n      var match = [];\n      rules.forEach(function (rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match));\n          result.push(ruleOptions(key, rule));\n          match = [];\n        } else {\n          match.push(rule);\n        }\n      });\n      if (match.length) result.push(ruleOptions(key, match));\n    }\n\n    return result;\n  }\n\n  function arrayToRules(array) {\n    var result = [];\n\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i];\n\n      if (obj.include) {\n        var include = [].concat(obj.include);\n\n        for (var j = 0; j < include.length; j++) {\n          result.push({\n            include: include[j]\n          });\n        }\n\n        continue;\n      }\n\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj));\n      }\n\n      result.push(ruleOptions(obj.type, obj));\n    }\n\n    return result;\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = {\n        match: obj\n      };\n    }\n\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states');\n    } // nb. error and fallback imply lineBreaks\n\n\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false\n    }; // Avoid Object.assign(), so we support IE9+\n\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key];\n      }\n    } // type transform cannot be a string\n\n\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\");\n    } // convert to array\n\n\n    var match = options.match;\n    options.match = Array.isArray(match) ? match : match ? [match] : [];\n    options.match.sort(function (a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length;\n    });\n    return options;\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);\n  }\n\n  var defaultErrorRule = ruleOptions('error', {\n    lineBreaks: true,\n    shouldThrow: true\n  });\n\n  function compileRules(rules, hasStates) {\n    var errorRule = null;\n    var fast = Object.create(null);\n    var fastAllowed = true;\n    var groups = [];\n    var parts = []; // If there is a fallback rule, then disable fast matching\n\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false;\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i];\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers');\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\");\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\");\n          }\n        }\n\n        errorRule = options;\n      }\n\n      var match = options.match;\n\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift();\n          fast[word.charCodeAt(0)] = options;\n        }\n      } // Warn about inappropriate state-switching options\n\n\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\");\n        }\n\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\");\n        }\n      } // Only rules with a .match are included in the RegExp\n\n\n      if (match.length === 0) {\n        continue;\n      }\n\n      fastAllowed = false;\n      groups.push(options); // convert to RegExp\n\n      var pat = reUnion(match.map(regexpOrLiteral)); // validate\n\n      var regexp = new RegExp(pat);\n\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp);\n      }\n\n      var groupCount = reGroups(pat);\n\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: â€¦ ) instead\");\n      } // try and detect rules matching newlines\n\n\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp);\n      } // store regex\n\n\n      parts.push(reCapture(pat));\n    } // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n\n\n    var fallbackRule = errorRule && errorRule.fallback;\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm';\n    var suffix = hasSticky || fallbackRule ? '' : '|';\n    var combined = new RegExp(reUnion(parts) + suffix, flags);\n    return {\n      regexp: combined,\n      groups: groups,\n      fast: fast,\n      error: errorRule || defaultErrorRule\n    };\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules));\n    return new Lexer({\n      start: result\n    }, 'start');\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next);\n\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\");\n    }\n\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\");\n    }\n  }\n\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : [];\n    delete states.$all;\n    var keys = Object.getOwnPropertyNames(states);\n    if (!start) start = keys[0];\n    var ruleMap = Object.create(null);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      ruleMap[key] = toRules(states[key]).concat(all);\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var rules = ruleMap[key];\n      var included = Object.create(null);\n\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j];\n        if (!rule.include) continue;\n        var splice = [j, 1];\n\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true;\n          var newRules = ruleMap[rule.include];\n\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\");\n          }\n\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k];\n            if (rules.indexOf(newRule) !== -1) continue;\n            splice.push(newRule);\n          }\n        }\n\n        rules.splice.apply(rules, splice);\n        j--;\n      }\n    }\n\n    var map = Object.create(null);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      map[key] = compileRules(ruleMap[key], true);\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i];\n      var state = map[name];\n      var groups = state.groups;\n\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map);\n      }\n\n      var fastKeys = Object.getOwnPropertyNames(state.fast);\n\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map);\n      }\n    }\n\n    return new Lexer(map, start);\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null);\n    var byLength = Object.create(null);\n    var types = Object.getOwnPropertyNames(map);\n\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i];\n      var item = map[tokenType];\n      var keywordList = Array.isArray(item) ? item : [item];\n      keywordList.forEach(function (keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword);\n\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\");\n        }\n\n        reverseMap[keyword] = tokenType;\n      });\n    } // fast string lookup\n    // https://jsperf.com/string-lookups\n\n\n    function str(x) {\n      return JSON.stringify(x);\n    }\n\n    var source = '';\n    source += 'switch (value.length) {\\n';\n\n    for (var length in byLength) {\n      var keywords = byLength[length];\n      source += 'case ' + length + ':\\n';\n      source += 'switch (value) {\\n';\n      keywords.forEach(function (keyword) {\n        var tokenType = reverseMap[keyword];\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n';\n      });\n      source += '}\\n';\n    }\n\n    source += '}\\n';\n    return Function('value', source); // type\n  }\n  /***************************************************************************/\n\n\n  var Lexer = function (states, state) {\n    this.startState = state;\n    this.states = states;\n    this.buffer = '';\n    this.stack = [];\n    this.reset();\n  };\n\n  Lexer.prototype.reset = function (data, info) {\n    this.buffer = data || '';\n    this.index = 0;\n    this.line = info ? info.line : 1;\n    this.col = info ? info.col : 1;\n    this.queuedToken = info ? info.queuedToken : null;\n    this.queuedThrow = info ? info.queuedThrow : null;\n    this.setState(info ? info.state : this.startState);\n    this.stack = info && info.stack ? info.stack.slice() : [];\n    return this;\n  };\n\n  Lexer.prototype.save = function () {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow\n    };\n  };\n\n  Lexer.prototype.setState = function (state) {\n    if (!state || this.state === state) return;\n    this.state = state;\n    var info = this.states[state];\n    this.groups = info.groups;\n    this.error = info.error;\n    this.re = info.regexp;\n    this.fast = info.fast;\n  };\n\n  Lexer.prototype.popState = function () {\n    this.setState(this.stack.pop());\n  };\n\n  Lexer.prototype.pushState = function (state) {\n    this.stack.push(this.state);\n    this.setState(state);\n  };\n\n  var eat = hasSticky ? function (re, buffer) {\n    // assume re is /y\n    return re.exec(buffer);\n  } : function (re, buffer) {\n    // assume re is /g\n    var match = re.exec(buffer); // will always match, since we used the |(?:) trick\n\n    if (match[0].length === 0) {\n      return null;\n    }\n\n    return match;\n  };\n\n  Lexer.prototype._getGroup = function (match) {\n    var groupCount = this.groups.length;\n\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i];\n      }\n    }\n\n    throw new Error('Cannot find token type for matched text');\n  };\n\n  function tokenToString() {\n    return this.value;\n  }\n\n  Lexer.prototype.next = function () {\n    var index = this.index; // If a fallback token matched, we don't need to re-run the RegExp\n\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index);\n\n      this.queuedGroup = null;\n      this.queuedText = \"\";\n      return token;\n    }\n\n    var buffer = this.buffer;\n\n    if (index === buffer.length) {\n      return; // EOF\n    } // Fast matching for single characters\n\n\n    var group = this.fast[buffer.charCodeAt(index)];\n\n    if (group) {\n      return this._token(group, buffer.charAt(index), index);\n    } // Execute RegExp\n\n\n    var re = this.re;\n    re.lastIndex = index;\n    var match = eat(re, buffer); // Error tokens match the remaining buffer\n\n    var error = this.error;\n\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index);\n    }\n\n    var group = this._getGroup(match);\n\n    var text = match[0];\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group;\n      this.queuedText = text; // Fallback tokens contain the unmatched portion of the buffer\n\n      return this._token(error, buffer.slice(index, match.index), index);\n    }\n\n    return this._token(group, text, index);\n  };\n\n  Lexer.prototype._token = function (group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0;\n\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g;\n      var nl = 1;\n\n      if (text === '\\n') {\n        lineBreaks = 1;\n      } else {\n        while (matchNL.exec(text)) {\n          lineBreaks++;\n          nl = matchNL.lastIndex;\n        }\n      }\n    }\n\n    var token = {\n      type: typeof group.type === 'function' && group.type(text) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col\n    }; // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length;\n    this.index += size;\n    this.line += lineBreaks;\n\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1;\n    } else {\n      this.col += size;\n    } // throw, if no rule with {error: true}\n\n\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"));\n    }\n\n    if (group.pop) this.popState();else if (group.push) this.pushState(group.push);else if (group.next) this.setState(group.next);\n    return token;\n  };\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function (lexer) {\n      this.lexer = lexer;\n    };\n\n    LexerIterator.prototype.next = function () {\n      var token = this.lexer.next();\n      return {\n        value: token,\n        done: !token\n      };\n    };\n\n    LexerIterator.prototype[Symbol.iterator] = function () {\n      return this;\n    };\n\n    Lexer.prototype[Symbol.iterator] = function () {\n      return new LexerIterator(this);\n    };\n  }\n\n  Lexer.prototype.formatError = function (token, message) {\n    var value = token.text;\n    var index = token.offset;\n    var eol = token.lineBreaks ? value.indexOf('\\n') : value.length;\n    var start = Math.max(0, index - token.col + 1);\n    var firstLine = this.buffer.substring(start, index + eol);\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\";\n    message += \"  \" + firstLine + \"\\n\";\n    message += \"  \" + Array(token.col).join(\" \") + \"^\";\n    return message;\n  };\n\n  Lexer.prototype.clone = function () {\n    return new Lexer(this.states, this.state);\n  };\n\n  Lexer.prototype.has = function (tokenType) {\n    return true;\n  };\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({\n      error: true\n    }),\n    fallback: Object.freeze({\n      fallback: true\n    }),\n    keywords: keywordTransform\n  };\n});","map":{"version":3,"sources":["/home/madhav/P2P Lending/node_modules/moo/moo.js"],"names":["root","factory","define","amd","module","exports","moo","hasOwnProperty","Object","prototype","toString","hasSticky","RegExp","sticky","isRegExp","o","call","isObject","Array","isArray","reEscape","s","replace","reGroups","re","exec","length","reCapture","reUnion","regexps","source","map","join","regexpOrLiteral","obj","ignoreCase","Error","global","multiline","unicode","objectToRules","object","keys","getOwnPropertyNames","result","i","key","thing","rules","concat","j","push","include","match","forEach","rule","ruleOptions","arrayToRules","array","type","JSON","stringify","options","defaultType","lineBreaks","error","fallback","pop","next","value","shouldThrow","sort","a","b","toRules","spec","defaultErrorRule","compileRules","hasStates","errorRule","fast","create","fastAllowed","groups","parts","word","shift","charCodeAt","pat","regexp","test","groupCount","fallbackRule","flags","suffix","combined","compile","Lexer","start","checkStateGroup","g","name","state","compileStates","states","all","$all","ruleMap","included","splice","newRules","k","newRule","indexOf","apply","fastKeys","keywordTransform","reverseMap","byLength","types","tokenType","item","keywordList","keyword","str","x","keywords","Function","startState","buffer","stack","reset","data","info","index","line","col","queuedToken","queuedThrow","setState","slice","save","popState","pushState","eat","_getGroup","undefined","tokenToString","queuedGroup","token","_token","queuedText","group","charAt","lastIndex","text","offset","matchNL","nl","size","formatError","Symbol","iterator","LexerIterator","lexer","done","message","eol","Math","max","firstLine","substring","clone","has","freeze"],"mappings":"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","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      if (obj.unicode) throw new Error('RegExp /u flag is not allowed')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: â€¦ ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    var value = token.text\n    var index = token.offset\n    var eol = token.lineBreaks ? value.indexOf('\\n') : value.length\n    var start = Math.max(0, index - token.col + 1)\n    var firstLine = this.buffer.substring(start, index + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n"]},"metadata":{},"sourceType":"script"}