"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ColdObservable_1 = require("rxjs/internal/testing/ColdObservable");
var TestMessage_1 = require("../message/TestMessage");
var ObservableMarbleToken_1 = require("./ObservableMarbleToken");
var SubscriptionMarbleToken_1 = require("./SubscriptionMarbleToken");
/**
 * Translate single token in marble diagram to correct metadata
 * @param {any} token Single char in marble diagram
 * @param {{ [key: string]: T }} [value] Custom value for marble value
 * @param {boolean} [materializeInnerObservables] Flatten inner observables in cold observable. False by default.
 */
var getMarbleTokenValue = function (token, value, materializeInnerObservables) {
    var customValue = value && token in value ? value[token] : token;
    return materializeInnerObservables && customValue instanceof ColdObservable_1.ColdObservable ? customValue.messages : customValue;
};
var timeFrameExpandTokenHandler = function (acc, frameTimeFactor) {
    var ret = tslib_1.__assign({}, acc);
    ret.expandingTokenCount += 1;
    //When token reaches ...xxx..., clean up state
    if (ret.expandingTokenCount === 6) {
        ret.expandingValue.splice(0);
        ret.expandingTokenCount = 0;
    }
    //When first ending token arrives ...xxx. , parse values and adjust timeframe
    if (ret.expandingTokenCount === 4) {
        if (ret.expandingValue.length === 0) {
            throw new Error("There isn't value to expand timeframe");
        }
        var expandedFrame = parseInt(ret.expandingValue.join(''), 10);
        ret.currentTimeFrame += expandedFrame * frameTimeFactor;
    }
    return ret;
};
var validateTimeFrameToken = function (acc) {
    if (acc.expandingTokenCount > 0 || acc.simultaneousGrouped) {
        throw new Error('Incorret timeframe specified');
    }
};
var validateSimultaneousGroupToken = function (acc) {
    if (acc.simultaneousGrouped) {
        throw new Error('Cannot nest grouped value');
    }
};
var increaseTimeFrame = function (acc, frameTimeFactor) {
    var ret = tslib_1.__assign({}, acc);
    ret.currentTimeFrame += 1 * frameTimeFactor;
    return ret;
};
/**
 * @internal
 * Reducer to traverse Observable marble diagram to generate TestMessage metadata.
 * @param value Custom values for marble values
 * @param error Custom error
 * @param materializeInnerObservables Flatten inner observable if available
 * @param frameTimeFactor Custom timeframe factor
 */
var observableTokenParseReducer = function (value, error, materializeInnerObservables, frameTimeFactor, maxFrame) { return function (acc, token) {
    if (acc.currentTimeFrame >= maxFrame) {
        return acc;
    }
    var message = null;
    switch (token) {
        case ObservableMarbleToken_1.ObservableMarbleToken.TIMEFRAME:
            validateTimeFrameToken(acc);
            acc = increaseTimeFrame(acc, frameTimeFactor);
            break;
        case ObservableMarbleToken_1.ObservableMarbleToken.ERROR:
            message = TestMessage_1.error(acc.currentTimeFrame, error || '#');
            break;
        case ObservableMarbleToken_1.ObservableMarbleToken.COMPLETE:
            message = TestMessage_1.complete(acc.currentTimeFrame);
            break;
        case ObservableMarbleToken_1.ObservableMarbleToken.TIMEFRAME_EXPAND:
            acc = timeFrameExpandTokenHandler(acc, frameTimeFactor);
            break;
        case ObservableMarbleToken_1.ObservableMarbleToken.SIMULTANEOUS_START:
            validateSimultaneousGroupToken(acc);
            acc.simultaneousGrouped = true;
            break;
        case ObservableMarbleToken_1.ObservableMarbleToken.SIMULTANEOUS_END:
            acc = increaseTimeFrame(acc, frameTimeFactor);
            acc.simultaneousGrouped = false;
            break;
        case SubscriptionMarbleToken_1.SubscriptionMarbleToken.SUBSCRIBE:
            acc = increaseTimeFrame(acc, frameTimeFactor);
            break;
        default:
            if (acc.expandingTokenCount > 0) {
                acc.expandingValue.push(token);
            }
            else {
                var tokenValue = getMarbleTokenValue(token, value, materializeInnerObservables);
                message = TestMessage_1.next(acc.currentTimeFrame, tokenValue);
            }
    }
    if (!!message) {
        acc.messages.push(message);
        if (!acc.simultaneousGrouped) {
            acc = increaseTimeFrame(acc, frameTimeFactor);
        }
    }
    return acc;
}; };
exports.observableTokenParseReducer = observableTokenParseReducer;
/**
 * @internal
 * Reducer to traverse subscription marble diagram to generate SubscriptionLog metadata.
 * @param frameTimeFactor Custom timeframe factor
 */
var subscriptionTokenParseReducer = function (frameTimeFactor, maxFrame) { return function (acc, token) {
    if (acc.currentTimeFrame >= maxFrame) {
        return acc;
    }
    switch (token) {
        case SubscriptionMarbleToken_1.SubscriptionMarbleToken.SUBSCRIBE:
            acc.subscriptionFrame = acc.currentTimeFrame;
            if (!acc.simultaneousGrouped) {
                acc = increaseTimeFrame(acc, frameTimeFactor);
            }
            break;
        case SubscriptionMarbleToken_1.SubscriptionMarbleToken.UNSUBSCRIBE:
            acc.unsubscriptionFrame = acc.currentTimeFrame;
            break;
        case ObservableMarbleToken_1.ObservableMarbleToken.TIMEFRAME_EXPAND:
            acc = timeFrameExpandTokenHandler(acc, frameTimeFactor);
            break;
        case ObservableMarbleToken_1.ObservableMarbleToken.SIMULTANEOUS_START:
            validateSimultaneousGroupToken(acc);
            acc.simultaneousGrouped = true;
            break;
        case ObservableMarbleToken_1.ObservableMarbleToken.SIMULTANEOUS_END:
            acc.simultaneousGrouped = false;
        case ObservableMarbleToken_1.ObservableMarbleToken.TIMEFRAME:
            validateTimeFrameToken(acc);
        case ObservableMarbleToken_1.ObservableMarbleToken.ERROR:
        case ObservableMarbleToken_1.ObservableMarbleToken.COMPLETE:
        default:
            if (acc.expandingTokenCount > 0) {
                acc.expandingValue.push(token);
            }
            else if (!acc.simultaneousGrouped) {
                acc = increaseTimeFrame(acc, frameTimeFactor);
            }
            break;
    }
    return acc;
}; };
exports.subscriptionTokenParseReducer = subscriptionTokenParseReducer;
//# sourceMappingURL=tokenParseReducer.js.map