"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var matchers_1 = require("jest-matchers/build/matchers");
var SubscriptionLog_1 = require("rxjs/internal/testing/SubscriptionLog");
var constructObservableMarble_1 = require("./constructObservableMarble");
var constructSubscriptionMarble_1 = require("./constructSubscriptionMarble");
exports.constructSubscriptionMarble = constructSubscriptionMarble_1.constructSubscriptionMarble;
var _a = require('jest-matcher-utils'), matcherHint = _a.matcherHint, printExpected = _a.printExpected, printReceived = _a.printReceived; //tslint:disable-line:no-require-imports no-var-requires
var toEqualAssert = matchers_1.toEqual.bind({ expand: false });
var subscriptionMarbleAssert = function (source) { return function (expected) {
    var asserted = toEqualAssert(source, expected);
    if (!asserted.pass) {
        var length_1 = source.length > expected.length ? source.length : expected.length;
        var description = "\n" + matcherHint(' to equal ') + "\n    ";
        for (var idx = 0; idx < length_1; idx++) {
            var sourceMarble = !!source[idx]
                ? constructSubscriptionMarble_1.constructSubscriptionMarble(source[idx])
                : { marbleString: '', frameString: '' };
            var expectedMarble = !!expected[idx]
                ? constructSubscriptionMarble_1.constructSubscriptionMarble(expected[idx])
                : { marbleString: '', frameString: '' };
            if (toEqualAssert(sourceMarble, expectedMarble).pass) {
                continue;
            }
            description += "\n\n" + printReceived("Source:   " + sourceMarble.marbleString) + "\n" + printReceived("          " + sourceMarble.frameString) + "\n" + printExpected("Expected: " + expectedMarble.marbleString) + "\n" + printExpected("          " + expectedMarble.frameString) + "\n      ";
        }
        description += "\n" + asserted.message() + "\n";
        throw new Error(description);
    }
}; };
var observableMarbleAssert = function (source) { return function (expected) {
    if (!Array.isArray(expected)) {
        throw new Error('Expected value is not array');
    }
    //polymorphic picks up observablemarbleassert first when empty array, manually falls back
    //if expected is subscriptionlog
    if (expected.every(function (x) { return x instanceof SubscriptionLog_1.SubscriptionLog; })) {
        subscriptionMarbleAssert(source)(expected);
        return;
    }
    var sourceMarble = constructObservableMarble_1.constructObservableMarble(source);
    var expectedMarble = constructObservableMarble_1.constructObservableMarble(expected);
    var asserted = toEqualAssert(source, expected);
    if (!asserted.pass) {
        var description = "\n" + printReceived("Source:   " + sourceMarble) + "\n" + printExpected("Expected: " + expectedMarble) + "\n\n" + asserted.message() + "\n    ";
        throw new Error(description);
    }
}; };
function marbleAssert(source) {
    var isSourceArray = Array.isArray(source);
    if (!isSourceArray) {
        throw new Error('Cannot assert non array');
    }
    var isSourceSubscription = source.length > 0 && source.every(function (v) { return v instanceof SubscriptionLog_1.SubscriptionLog; });
    return {
        to: {
            equal: isSourceSubscription ? subscriptionMarbleAssert(source) : observableMarbleAssert(source)
        }
    };
}
exports.marbleAssert = marbleAssert;
//# sourceMappingURL=marbleAssert.js.map