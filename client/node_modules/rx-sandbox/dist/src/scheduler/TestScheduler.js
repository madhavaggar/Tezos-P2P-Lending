"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var rxjs_1 = require("rxjs");
var VirtualTimeScheduler_1 = require("rxjs/internal/scheduler/VirtualTimeScheduler");
var ColdObservable_1 = require("rxjs/internal/testing/ColdObservable");
var HotObservable_1 = require("rxjs/internal/testing/HotObservable");
var parseObservableMarble_1 = require("../marbles/parseObservableMarble");
var SubscriptionMarbleToken_1 = require("../marbles/SubscriptionMarbleToken");
var TestMessage_1 = require("../message/TestMessage");
var calculateSubscriptionFrame_1 = require("./calculateSubscriptionFrame");
/**
 * @internal
 */
var TestScheduler = /** @class */ (function (_super) {
    tslib_1.__extends(TestScheduler, _super);
    function TestScheduler(autoFlush, frameTimeFactor, maxFrameValue) {
        var _this = _super.call(this, VirtualTimeScheduler_1.VirtualAction, Number.POSITIVE_INFINITY) || this;
        _this.autoFlush = autoFlush;
        _this.frameTimeFactor = frameTimeFactor;
        _this.coldObservables = [];
        _this.hotObservables = [];
        _this.flushed = false;
        _this.flushing = false;
        _this._maxFrame = maxFrameValue * frameTimeFactor;
        return _this;
    }
    Object.defineProperty(TestScheduler.prototype, "maxFrame", {
        get: function () {
            return this._maxFrame;
        },
        enumerable: true,
        configurable: true
    });
    TestScheduler.prototype.flush = function () {
        this.flushUntil();
    };
    TestScheduler.prototype.getMessages = function (observable, unsubscriptionMarbles) {
        var _this = this;
        if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }
        var _a = calculateSubscriptionFrame_1.calculateSubscriptionFrame(observable, unsubscriptionMarbles, this.frameTimeFactor), subscribedFrame = _a.subscribedFrame, unsubscribedFrame = _a.unsubscribedFrame;
        var observableMetadata = [];
        var pushMetadata = function (notification) {
            return observableMetadata.push(new TestMessage_1.TestMessageValue(_this.frame, notification));
        };
        var subscription = null;
        this.schedule(function () {
            subscription = observable.subscribe(function (value) {
                return pushMetadata(rxjs_1.Notification.createNext(value instanceof rxjs_1.Observable ? _this.materializeInnerObservable(value, _this.frame) : value));
            }, function (err) { return pushMetadata(rxjs_1.Notification.createError(err)); }, function () { return pushMetadata(rxjs_1.Notification.createComplete()); });
        }, subscribedFrame);
        if (unsubscribedFrame !== Number.POSITIVE_INFINITY) {
            this.schedule(function () { return subscription.unsubscribe(); }, unsubscribedFrame);
        }
        if (this.autoFlush) {
            if (this.flushed) {
                throw new Error("Cannot schedule to get marbles, scheduler's already flushed");
            }
            this.flush();
        }
        return observableMetadata;
    };
    TestScheduler.prototype.createColdObservable = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var marbleValue = args[0], value = args[1], error = args[2];
        if (typeof marbleValue === 'string' && marbleValue.indexOf(SubscriptionMarbleToken_1.SubscriptionMarbleToken.SUBSCRIBE) !== -1) {
            throw new Error("Cold observable cannot have subscription offset " + SubscriptionMarbleToken_1.SubscriptionMarbleToken.SUBSCRIBE);
        }
        var messages = Array.isArray(marbleValue)
            ? marbleValue
            : parseObservableMarble_1.parseObservableMarble(marbleValue, value, error, false, this.frameTimeFactor, this._maxFrame);
        var observable = new ColdObservable_1.ColdObservable(messages, this);
        this.coldObservables.push(observable);
        return observable;
    };
    TestScheduler.prototype.createHotObservable = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var marbleValue = args[0], value = args[1], error = args[2];
        var messages = Array.isArray(marbleValue)
            ? marbleValue
            : parseObservableMarble_1.parseObservableMarble(marbleValue, value, error, false, this.frameTimeFactor, this._maxFrame);
        var subject = new HotObservable_1.HotObservable(messages, this);
        this.hotObservables.push(subject);
        return subject;
    };
    TestScheduler.prototype.advanceTo = function (toFrame) {
        if (this.autoFlush) {
            throw new Error('Cannot advance frame manually with autoflushing scheduler');
        }
        if (toFrame < 0 || toFrame < this.frame) {
            throw new Error("Cannot advance frame, given frame is either negative or smaller than current frame");
        }
        this.flushUntil(toFrame);
        this.frame = toFrame;
    };
    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
        var _this = this;
        var innerObservableMetadata = [];
        var pushMetaData = function (notification) {
            return innerObservableMetadata.push(new TestMessage_1.TestMessageValue(_this.frame - outerFrame, notification));
        };
        observable.subscribe(function (value) { return pushMetaData(rxjs_1.Notification.createNext(value)); }, function (err) { return pushMetaData(rxjs_1.Notification.createError(err)); }, function () { return pushMetaData(rxjs_1.Notification.createComplete()); });
        return innerObservableMetadata;
    };
    TestScheduler.prototype.peek = function () {
        var actions = this.actions;
        return actions && actions.length > 0 ? actions[0] : null;
    };
    TestScheduler.prototype.flushUntil = function (toFrame) {
        if (toFrame === void 0) { toFrame = this.maxFrame; }
        if (this.flushing) {
            return;
        }
        var hotObservables = this.hotObservables;
        while (hotObservables.length > 0) {
            hotObservables.shift().setup();
        }
        this.flushing = true;
        var actions = this.actions;
        var error;
        var action = null;
        while (this.flushing && (action = this.peek()) && action.delay <= toFrame) {
            var action_1 = actions.shift();
            this.frame = action_1.delay;
            if ((error = action_1.execute(action_1.state, action_1.delay))) {
                break;
            }
        }
        this.flushing = false;
        if (toFrame >= this.maxFrame) {
            this.flushed = true;
        }
        if (error) {
            while ((action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return TestScheduler;
}(VirtualTimeScheduler_1.VirtualTimeScheduler));
exports.TestScheduler = TestScheduler;
//# sourceMappingURL=TestScheduler.js.map