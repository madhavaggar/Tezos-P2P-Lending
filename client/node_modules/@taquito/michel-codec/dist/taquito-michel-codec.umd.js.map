{"version":3,"file":"taquito-michel-codec.umd.js","sources":["../src/scan.ts","../src/macros.ts","../src/micheline-parser.ts","../src/micheline-emitter.ts","../src/michelson-validator.ts"],"sourcesContent":["export class ScanError extends Error {\n    constructor(public src: string, public idx: number, message?: string) {\n        super(message);\n    }\n}\n\nexport enum Literal {\n    Comment,\n    Number,\n    String,\n    Bytes,\n    Ident,\n}\n\nexport type TokenType = \"(\" | \")\" | \"{\" | \"}\" | \";\" | Literal;\n\nconst isSpace = new RegExp(\"\\\\s\");\nconst isIdentStart = new RegExp(\"[:@%_A-Za-z]\");\nconst isIdent = new RegExp(\"[@%_\\\\.A-Za-z0-9]\");\nconst isDigit = new RegExp(\"[0-9]\");\nconst isHex = new RegExp(\"[0-9a-fA-F]\");\n\nexport interface Token {\n    t: TokenType;\n    v: string;\n    offset: number;\n}\n\nexport function* scan(src: string, scanComments = false): Generator<Token, void> {\n    let i = 0;\n    while (i < src.length) {\n        // Skip space\n        while (i < src.length && isSpace.test(src[i])) {\n            i++;\n        }\n        if (i === src.length) {\n            return;\n        }\n\n        const s = src[i];\n        const start = i;\n        if (isIdentStart.test(s)) {\n            // Identifier\n            i++;\n            while (i < src.length && isIdent.test(src[i])) {\n                i++;\n            }\n            yield { t: Literal.Ident, v: src.slice(start, i), offset: i };\n        } else if (src.length - i > 1 && src.substr(i, 2) === \"0x\") {\n            // Bytes\n            i += 2;\n            while (i < src.length && isHex.test(src[i])) {\n                i++;\n            }\n            if (i - start === 2) {\n                throw new ScanError(src, i, \"Bytes literal is too short\");\n            } else if (((i - start) & 1) !== 0) {\n                throw new ScanError(src, i, \"Bytes literal length is expected to be power of two\");\n            }\n            yield { t: Literal.Bytes, v: src.slice(start, i), offset: i };\n        } else if (isDigit.test(s) || s === \"-\") {\n            // Number\n            if (s === \"-\") {\n                i++;\n            }\n            const ii = i;\n            while (i < src.length && isDigit.test(src[i])) {\n                i++;\n            }\n            if (ii === i) {\n                throw new ScanError(src, i, \"Number literal is too short\");\n            }\n            yield { t: Literal.Number, v: src.slice(start, i), offset: i };\n        } else if (s === \"\\\"\") {\n            // String\n            i++;\n            let esc = false;\n            for (; i < src.length && (esc || src[i] !== \"\\\"\"); i++) {\n                if (!esc && src[i] === \"\\\\\") {\n                    esc = true;\n                } else {\n                    esc = false;\n                }\n            }\n            if (i === src.length) {\n                throw new ScanError(src, i, \"Unterminated string literal\");\n            }\n            i++;\n            yield { t: Literal.String, v: src.slice(start, i), offset: i };\n        } else if (s === \"#\") {\n            // Comment\n            i++;\n            while (i < src.length && src[i] !== \"\\n\") {\n                i++;\n            }\n            if (scanComments) {\n                yield { t: Literal.Comment, v: src.slice(start, i), offset: i };\n            }\n        } else if (s === \"(\" || s === \")\" || s === \"{\" || s === \"}\" || s === \";\") {\n            i++;\n            yield { t: s, v: s, offset: i };\n        } else {\n            throw new ScanError(src, i, `Invalid character at offset ${i}: \\`${s}'`);\n        }\n    }\n}","import { Prim, Expr, IntLiteral } from \"./micheline\";\nimport { Tuple, NoArgs, ReqArgs, NoAnnots } from \"./utils\";\n\nexport class MacroError extends Error {\n    constructor(public prim: Prim, message?: string) {\n        super(message);\n    }\n}\n\nfunction assertArgs<N extends number>(ex: Prim, n: N):\n    ex is N extends 0 ?\n    NoArgs<Prim<string>> :\n    ReqArgs<Prim<string, Tuple<Expr, N>>> {\n    if ((n === 0 && ex.args === undefined) || ex.args?.length === n) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects ${n} arguments, was given ${ex.args?.length}`);\n}\n\nfunction assertNoAnnots(ex: Prim): ex is NoAnnots<Prim> {\n    if (ex.annots === undefined) {\n        return true;\n    }\n    throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${ex.annots}`);\n}\n\nfunction assertIntArg(ex: Prim, arg: Expr): arg is IntLiteral {\n    if (\"int\" in arg) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects int argument`);\n}\n\ntype PT = [number, [string | null, string | null]];\n\nfunction parsePairUnpairExpr(p: Prim, expr: string, annotations: string[], agg: (a: PT[], v: PT) => PT[]): { r: PT[], n: number, an: number } {\n    const res: PT[] = [];\n    let i = 0;\n    let ai = 0;\n    const ann: [string | null, string | null] = [null, null];\n\n    // Left expression\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    let c = expr[i++];\n    switch (c) {\n        case \"P\":\n            const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n            res.push(...r);\n            i += n;\n            ai += an;\n            break;\n        case \"A\":\n            if (ai !== annotations.length) {\n                ann[0] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n\n    // Right expression\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    c = expr[i++];\n    switch (c) {\n        case \"P\":\n            const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n            res.push(...r.map<PT>(([v, a]) => [v + 1, a]));\n            i += n;\n            ai += an;\n            break;\n        case \"I\":\n            if (ai !== annotations.length) {\n                ann[1] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n\n    return { r: agg(res, [0, ann]), n: i, an: ai };\n}\n\nfunction parseSetMapCadr(p: Prim, expr: string, vann: string[], term: { a: Expr, d: Expr }): Expr {\n    const c = expr[0];\n    switch (c) {\n        case \"A\":\n            return expr.length > 1 ?\n                [\n                    { prim: \"DUP\" },\n                    {\n                        prim: \"DIP\",\n                        args: [[\n                            { prim: \"CAR\", annots: [\"@%%\"] },\n                            parseSetMapCadr(p, expr.slice(1), [], term),\n                        ]],\n                    },\n                    { prim: \"CDR\", annots: [\"@%%\"] },\n                    { prim: \"SWAP\" },\n                    { prim: \"PAIR\", annots: [\"%@\", \"%@\", ...vann] },\n                ] : term.a;\n\n        case \"D\":\n            return expr.length > 1 ?\n                [\n                    { prim: \"DUP\" },\n                    {\n                        prim: \"DIP\",\n                        args: [[\n                            { prim: \"CDR\", annots: [\"@%%\"] },\n                            parseSetMapCadr(p, expr.slice(1), [], term),\n                        ]],\n                    },\n                    { prim: \"CAR\", annots: [\"@%%\"] },\n                    { prim: \"PAIR\", annots: [\"%@\", \"%@\", ...vann] },\n                ] : term.d;\n\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n}\n\nfunction trimLast<T>(a: T[], v: T): T[] {\n    let l = a.length;\n    while (l > 0 && a[l - 1] === v) {\n        l--;\n    }\n    return a.slice(0, l);\n}\n\nfunction filterAnnotations(a?: string[]): {\n    fields: string[];\n    rest: string[];\n} {\n    const fields: string[] = [];\n    const rest: string[] = [];\n    if (a !== undefined) {\n        for (const v of a) {\n            (v.length !== 0 && v[0] === \"%\" ? fields : rest).push(v);\n        }\n    }\n    return { fields, rest };\n}\n\nfunction mkPrim({ prim, annots, args }: Prim): Prim {\n    return {\n        prim,\n        ...(annots && { annots }),\n        ...(args && { args }),\n    };\n}\n\nconst pairRe = /^P[PAI]{3,}R$/;\nconst unpairRe = /^UNP[PAI]{2,}R$/;\nconst cadrRe = /^C[AD]{2,}R$/;\nconst setCadrRe = /^SET_C[AD]+R$/;\nconst mapCadrRe = /^MAP_C[AD]+R$/;\nconst diipRe = /^DI{2,}P$/;\nconst duupRe = /^DU+P$/;\n\nexport function expandMacros(ex: Prim): Expr {\n    function mayRename(annots?: string[]): Prim[] {\n        return annots !== undefined ? [{ prim: \"RENAME\", annots }] : [];\n    }\n\n    switch (ex.prim) {\n        // Compare\n        case \"CMPEQ\":\n        case \"CMPNEQ\":\n        case \"CMPLT\":\n        case \"CMPGT\":\n        case \"CMPLE\":\n        case \"CMPGE\":\n            if (assertArgs(ex, 0)) {\n                return [\n                    { prim: \"COMPARE\" },\n                    mkPrim({ prim: ex.prim.slice(3), annots: ex.annots }),\n                ];\n            }\n            break;\n\n        case \"IFEQ\":\n        case \"IFNEQ\":\n        case \"IFLT\":\n        case \"IFGT\":\n        case \"IFLE\":\n        case \"IFGE\":\n            if (assertArgs(ex, 2)) {\n                return [\n                    { prim: ex.prim.slice(2) },\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\n                ];\n            }\n            break;\n\n        case \"IFCMPEQ\":\n        case \"IFCMPNEQ\":\n        case \"IFCMPLT\":\n        case \"IFCMPGT\":\n        case \"IFCMPLE\":\n        case \"IFCMPGE\":\n            if (assertArgs(ex, 2)) {\n                return [\n                    { prim: \"COMPARE\" },\n                    { prim: ex.prim.slice(5) },\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\n                ];\n            }\n            break;\n\n        // Fail\n        case \"FAIL\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    { prim: \"UNIT\" },\n                    { prim: \"FAILWITH\" },\n                ];\n            }\n            break;\n\n        // Assertion macros\n        case \"ASSERT\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [{\n                    prim: \"IF\", args: [\n                        [],\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_EQ\":\n        case \"ASSERT_NEQ\":\n        case \"ASSERT_LT\":\n        case \"ASSERT_GT\":\n        case \"ASSERT_LE\":\n        case \"ASSERT_GE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    { prim: ex.prim.slice(7) },\n                    {\n                        prim: \"IF\", args: [\n                            [],\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        ]\n                    },\n                ];\n            }\n            break;\n\n        case \"ASSERT_CMPEQ\":\n        case \"ASSERT_CMPNEQ\":\n        case \"ASSERT_CMPLT\":\n        case \"ASSERT_CMPGT\":\n        case \"ASSERT_CMPLE\":\n        case \"ASSERT_CMPGE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    [\n                        { prim: \"COMPARE\" },\n                        { prim: ex.prim.slice(10) },\n                    ],\n                    {\n                        prim: \"IF\", args: [\n                            [],\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        ]\n                    },\n                ];\n            }\n            break;\n\n        case \"ASSERT_NONE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [{\n                    prim: \"IF_NONE\", args: [\n                        [],\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_SOME\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_NONE\", args: [\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        mayRename(ex.annots),\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_LEFT\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_LEFT\", args: [\n                        mayRename(ex.annots),\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_RIGHT\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_LEFT\", args: [\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        mayRename(ex.annots),\n                    ]\n                }];\n            }\n            break;\n\n        // Syntactic conveniences\n\n        case \"IF_SOME\":\n            if (assertArgs(ex, 2)) {\n                return [mkPrim({ prim: \"IF_NONE\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\n            }\n            break;\n\n        case \"IF_RIGHT\":\n            if (assertArgs(ex, 2)) {\n                return [mkPrim({ prim: \"IF_LEFT\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\n            }\n    }\n\n    // More syntactic conveniences\n\n    // PAPPAIIR macro\n    if (pairRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, (a, v) => [...a, v]);\n\n            return r.map(([v, a], i) => {\n                const ann = [\n                    ...trimLast(a, null).map(v => v === null ? \"%\" : v),\n                    ...((v === 0 && i === r.length - 1) ? rest : [])];\n\n                const leaf = mkPrim({ prim: \"PAIR\", annots: ann.length !== 0 ? ann : undefined, });\n\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\n                };\n            });\n        }\n    }\n\n    // UNPAPPAIIR macro\n    if (unpairRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], (a, v) => [v, ...a]);\n\n            return r.map(([v, a]) => {\n                const leaf: Prim[] = [\n                    { prim: \"DUP\" },\n                    mkPrim({ prim: \"CAR\", annots: a[0] !== null ? [a[0]] : undefined }),\n                    {\n                        prim: \"DIP\",\n                        args: [[mkPrim({ prim: \"CDR\", annots: a[1] !== null ? [a[1]] : undefined })]],\n                    }\n                ];\n\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\n                };\n            });\n        }\n    }\n\n    // C[AD]+R macro\n    if (cadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const ch = [...ex.prim.slice(1, ex.prim.length - 1)];\n\n            return ch.map<Prim>((c, i) => {\n                const ann = i === ch.length - 1 ? ex.annots : undefined;\n                switch (c) {\n                    case \"A\":\n                        return mkPrim({ prim: \"CAR\", annots: ann });\n                    case \"D\":\n                        return mkPrim({ prim: \"CDR\", annots: ann });\n                    default:\n                        throw new MacroError(ex, `unexpected character: ${c}`);\n                }\n            });\n        }\n    }\n\n    // SET_C[AD]+R macro\n    if (setCadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n\n            const term = fields.length !== 0 ?\n                {\n                    a: [\n                        { prim: \"DUP\" },\n                        { prim: \"CAR\", annots: fields },\n                        { prim: \"DROP\" },\n                        { prim: \"CDR\", annots: [\"@%%\"] },\n                        { prim: \"SWAP\" },\n                        { prim: \"PAIR\", annots: [fields[0], \"%@\"] },\n                    ],\n                    d: [\n                        { prim: \"DUP\" },\n                        { prim: \"CDR\", annots: fields },\n                        { prim: \"DROP\" },\n                        { prim: \"CAR\", annots: [\"@%%\"] },\n                        { prim: \"PAIR\", annots: [\"%@\", fields[0]] },\n                    ],\n                } :\n                {\n                    a: [\n                        { prim: \"CDR\", annots: [\"@%%\"] },\n                        { prim: \"SWAP\" },\n                        { prim: \"PAIR\", annots: [\"%\", \"%@\"] },\n                    ],\n                    d: [\n                        { prim: \"CAR\", annots: [\"@%%\"] },\n                        { prim: \"PAIR\", annots: [\"%@\", \"%\"] },\n                    ],\n                };\n\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);\n        }\n    }\n\n    // MAP_C[AD]+R macro\n    if (mapCadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 1)) {\n            const { fields } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n\n            const term = {\n                a: [\n                    { prim: \"DUP\" },\n                    { prim: \"CDR\", annots: [\"@%%\"] },\n                    {\n                        prim: \"DIP\", args: [[\n                            mkPrim({ prim: \"CAR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\n                            ex.args[0],\n                        ]]\n                    },\n                    { prim: \"SWAP\" },\n                    { prim: \"PAIR\", annots: [fields.length !== 0 ? fields[0] : \"%\", \"%@\"] },\n                ],\n                d: [\n                    { prim: \"DUP\" },\n                    mkPrim({ prim: \"CDR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\n                    ex.args[0],\n                    { prim: \"SWAP\" },\n                    { prim: \"CAR\", annots: [\"@%%\"] },\n                    { prim: \"PAIR\", annots: [\"%@\", fields.length !== 0 ? fields[0] : \"%\"] },\n                ],\n            };\n\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);\n        }\n    }\n\n    // Expand deprecated DI...IP to [DIP n]\n    if (diipRe.test(ex.prim)) {\n        if (assertArgs(ex, 1)) {\n            let n = 0;\n            while (ex.prim[1 + n] === \"I\") { n++ }\n            return mkPrim({ prim: \"DIP\", args: [{ int: String(n) }, ex.args[0]] });\n        }\n    }\n\n    // Expand modern DUP n or deprecated DU...UP\n    if (duupRe.test(ex.prim)) {\n        let n = 0;\n        while (ex.prim[1 + n] === \"U\") { n++ }\n\n        if (n === 1) {\n            if (ex.args === undefined) {\n                return ex; // skip\n            }\n            if (assertArgs(ex, 1) && assertIntArg(ex, ex.args[0])) {\n                n = parseInt(ex.args[0].int, 10);\n            }\n        } else {\n            assertArgs(ex, 0);\n        }\n\n        if (n === 1) {\n            return [mkPrim({ prim: \"DUP\", annots: ex.annots })];\n\n        } else if (n === 2) {\n            return [\n                {\n                    prim: \"DIP\",\n                    args: [[mkPrim({ prim: \"DUP\", annots: ex.annots })]],\n                },\n                { prim: \"SWAP\" },\n            ];\n\n        } else {\n            return [\n                {\n                    prim: \"DIP\",\n                    args: [\n                        { int: String(n - 1) },\n                        [mkPrim({ prim: \"DUP\", annots: ex.annots })],\n                    ],\n                },\n                {\n                    prim: \"DIG\",\n                    args: [{ int: String(n) }],\n                },\n            ];\n        }\n\n    }\n\n    return ex;\n}","import { scan, Token, Literal } from './scan';\nimport { Expr, Prim, StringLiteral, IntLiteral, BytesLiteral } from './micheline';\nimport { expandMacros } from './macros';\n\nexport class MichelineParseError extends Error {\n    /**\n     * @param token A token caused the error\n     * @param message An error message\n     */\n    constructor(public token: Token | null, message?: string) {\n        super(message);\n    }\n}\n\nexport class JSONParseError extends Error {\n    /**\n     * @param node A node caused the error\n     * @param message An error message\n     */\n    constructor(public node: any, message?: string) {\n        super(message);\n    }\n}\n\nconst errEOF = new MichelineParseError(null, 'Unexpected EOF');\n\nfunction isAnnotation(tok: Token): boolean {\n    return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');\n}\n\nconst intRe = new RegExp('^-?[0-9]+$');\nconst bytesRe = new RegExp('^([0-9a-fA-F]{2})+$');\n\nexport interface ParserOptions {\n    /**\n     * Expand [Michelson macros](https://tezos.gitlab.io/whitedoc/michelson.html#macros) during parsing.\n     */\n    expandMacros: boolean;\n}\n\n/**\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\n *\n * Pretty Print a Michelson Smart Contract:\n * ```\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\n * const p = new Parser();\n *\n * const michelsonCode = p.parseJSON(contract.script.code);\n * const storage = p.parseJSON(contract.script.storage);\n *\n * console.log(\"Pretty print Michelson smart contract:\");\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\n *\n * console.log(\"Pretty print Storage:\");\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\n * ```\n *\n * Encode a Michelson expression for inital storage of a smart contract\n * ```\n * const src = `(Pair (Pair { Elt 1\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\n *                      0x0501000000026869) }\n *          10000000)\n *    (Pair 2 333))`;\n *\n * const p = new Parser();\n *\n * const exp = p.parseMichelineExpression(src);\n * console.log(JSON.stringify(exp));\n * ```\n */\nexport class Parser {\n    constructor(private opt?: ParserOptions) { }\n\n    private expand(ex: Prim): Expr {\n        return this.opt?.expandMacros ? expandMacros(ex) : ex;\n    }\n\n    private parseList(scanner: Iterator<Token>): Expr {\n        const tok = scanner.next();\n        if (tok.done) {\n            throw errEOF;\n        }\n\n        if (tok.value.t !== Literal.Ident) {\n            throw new MichelineParseError(tok.value, `List: not an identifier: ${tok.value.v}`);\n        }\n\n        const ret: Prim = {\n            prim: tok.value.v,\n        };\n\n        for (; ;) {\n            const tok = scanner.next();\n            if (tok.done) {\n                throw errEOF;\n            }\n            if (tok.value.t === ')') {\n                break;\n            }\n            if (isAnnotation(tok.value)) {\n                ret.annots = ret.annots || [];\n                ret.annots.push(tok.value.v);\n            } else {\n                ret.args = ret.args || [];\n                ret.args.push(this.parseExpr(scanner, tok.value));\n            }\n        }\n        return this.expand(ret);\n    }\n\n    private parseArgs(\n        scanner: Iterator<Token>,\n        prim: string,\n        expectBracket: boolean\n    ): [Prim, boolean] {\n        // Identifier with arguments\n        const p: Prim = { prim };\n\n        for (; ;) {\n            const t = scanner.next();\n            if (t.done) {\n                if (expectBracket) {\n                    throw errEOF;\n                } else {\n                    return [p, true];\n                }\n            } else if (t.value.t === '}') {\n                if (!expectBracket) {\n                    throw new MichelineParseError(t.value, `Seq: unexpected token: ${t.value.v}`);\n                } else {\n                    return [p, true];\n                }\n            } else if (t.value.t === ';') {\n                return [p, false];\n            }\n\n            if (isAnnotation(t.value)) {\n                p.annots = p.annots || [];\n                p.annots.push(t.value.v);\n            } else {\n                p.args = p.args || [];\n                p.args.push(this.parseExpr(scanner, t.value));\n            }\n        }\n    }\n\n    private parseSequence(\n        scanner: Iterator<Token>,\n        initialToken: Token | null,\n        expectBracket: boolean\n    ): Expr[] {\n        const seq: Expr[] = [];\n        for (; ;) {\n            let tok: Token;\n            if (initialToken !== null) {\n                tok = initialToken;\n                initialToken = null;\n            } else {\n                const t = scanner.next();\n                if (t.done) {\n                    if (expectBracket) {\n                        throw errEOF;\n                    } else {\n                        return seq;\n                    }\n                }\n                tok = t.value;\n            }\n\n            if (tok.t === '}') {\n                if (!expectBracket) {\n                    throw new MichelineParseError(tok, `Seq: unexpected token: ${tok.v}`);\n                } else {\n                    return seq;\n                }\n            } else if (tok.t === Literal.Ident) {\n                // Identifier with arguments\n                const [itm, done] = this.parseArgs(scanner, tok.v, expectBracket);\n                seq.push(this.expand(itm));\n                if (done) {\n                    return seq;\n                }\n            } else {\n                // Other\n                seq.push(this.parseExpr(scanner, tok));\n\n                const t = scanner.next();\n                if (t.done) {\n                    if (expectBracket) {\n                        throw errEOF;\n                    } else {\n                        return seq;\n                    }\n                } else if (t.value.t === '}') {\n                    if (!expectBracket) {\n                        throw new MichelineParseError(t.value, `Seq: unexpected token: ${t.value.v}`);\n                    } else {\n                        return seq;\n                    }\n                } else if (t.value.t !== ';') {\n                    throw new MichelineParseError(t.value, `Seq: unexpected token: ${t.value.v}`);\n                }\n            }\n        }\n    }\n\n    private parseExpr(scanner: Iterator<Token>, tok: Token): Expr {\n        switch (tok.t) {\n            case Literal.Ident:\n                return this.expand({ prim: tok.v });\n\n            case Literal.Number:\n                return { int: tok.v };\n\n            case Literal.String:\n                return { string: JSON.parse(tok.v) as string };\n\n            case Literal.Bytes:\n                return { bytes: tok.v.substr(2) };\n\n            case '(':\n                return this.parseList(scanner);\n\n            case '{':\n                return this.parseSequence(scanner, null, true);\n\n            default:\n                throw new MichelineParseError(tok, `Expr: unexpected token: ${tok.v}`);\n        }\n    }\n\n    /**\n     * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\n     */\n    parseScript(src: string): Expr[] | null {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n\n        return tok.value.t === '{'\n            ? this.parseSequence(scanner, null, true)\n            : this.parseSequence(scanner, tok.value, false);\n    }\n\n    /**\n     * Parse any Michelson expression\n     * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\n     * @returns An AST node or null for empty document.\n     */\n    parseMichelineExpression(src: string): Expr | null {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n        return this.parseExpr(scanner, tok.value);\n    }\n\n    /**\n     * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\n     * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\n     */\n    parseJSON(src: object): Expr {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"object\") {\n            throw new TypeError(`object type was expected, got ${typeof src} instead`);\n        }\n\n        if (Array.isArray(src)) {\n            const ret: Expr[] = [];\n            for (const n of src) {\n                if (n === null || typeof n !== 'object') {\n                    throw new JSONParseError(n, `unexpected sequence element: ${n}`);\n                }\n                ret.push(this.parseJSON(n));\n            }\n            return ret;\n\n        } else if ('prim' in src) {\n            const p = src as { prim: any, annots?: any[], args?: any[] };\n            if (\n                typeof p.prim === 'string' &&\n                (p.annots === undefined || Array.isArray(p.annots)) &&\n                (p.args === undefined || Array.isArray(p.args))\n            ) {\n                const ret: Prim = {\n                    prim: p.prim,\n                };\n\n                if (p.annots !== undefined) {\n                    for (const a of p.annots) {\n                        if (typeof a !== 'string') {\n                            throw new JSONParseError(a, `string expected: ${a}`);\n                        }\n                    }\n                    ret.annots = p.annots;\n                }\n\n                if (p.args !== undefined) {\n                    ret.args = [];\n                    for (const a of p.args) {\n                        if (a === null || typeof a !== 'object') {\n                            throw new JSONParseError(a, `unexpected argument: ${a}`);\n                        }\n                        ret.args.push(this.parseJSON(a));\n                    }\n                }\n\n                return this.expand(ret);\n            }\n\n            throw new JSONParseError(src, `malformed prim expression: ${src}`);\n        } else if ('string' in src) {\n            if (typeof (src as any).string === 'string') {\n                return { string: (src as StringLiteral).string };\n            }\n\n            throw new JSONParseError(src, `malformed string literal: ${src}`);\n        } else if ('int' in src) {\n            if (typeof (src as any).int === 'string' && intRe.test((src as IntLiteral).int)) {\n                return { int: (src as IntLiteral).int };\n            }\n\n            throw new JSONParseError(src, `malformed int literal: ${src}`);\n        } else if ('bytes' in src) {\n            if (\n                typeof (src as any).bytes === 'string' &&\n                bytesRe.test((src as BytesLiteral).bytes)\n            ) {\n                return { bytes: (src as BytesLiteral).bytes };\n            }\n\n            throw new JSONParseError(src, `malformed bytes literal: ${src}`);\n        } else {\n            throw new JSONParseError(src, `unexpected object: ${src}`);\n        }\n    }\n}\n","import { Expr, Prim } from \"./micheline\";\n\nexport interface FormatOptions {\n    /**\n     * A string used for code indentation if desired. Usually a tab character or a number of spaces.\n     */\n    indent?: string;\n    /**\n     * A string used for line separation. Usually a newline character (\"\\n\");\n     */\n    newline?: string;\n}\n\nclass Formatter {\n    constructor(private opt?: FormatOptions, private lev: number = 0) {\n    }\n\n    indent(n = 0): string {\n        let ret = \"\";\n        if (this.opt?.indent !== undefined) {\n            for (let i = this.lev + n; i > 0; i--) {\n                ret += this.opt.indent;\n            }\n        }\n        return ret;\n    }\n\n    get lf(): string {\n        return this.opt?.newline || \"\";\n    }\n\n    get lfsp(): string {\n        return this.opt?.newline || \" \";\n    }\n\n    down(n: number): Formatter {\n        return new Formatter(this.opt, this.lev + n);\n    }\n}\n\nfunction hasArgs(node: Expr): node is Prim {\n    return (\"prim\" in node) &&\n        ((node.annots !== undefined && node.annots.length !== 0) ||\n            (node.args !== undefined && node.args.length !== 0));\n}\n\nfunction isMultiline(node: Prim): boolean {\n    if (node.args !== undefined) {\n        for (const a of node.args) {\n            if (Array.isArray(a) || hasArgs(a)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction emitExpr(node: Expr, f: Formatter): string {\n    if (Array.isArray(node)) {\n        return emitSeq(node, f);\n\n    } else if (\"string\" in node) {\n        return JSON.stringify(node.string);\n\n    } else if (\"int\" in node) {\n        return node.int;\n\n    } else if (\"bytes\" in node) {\n        return \"0x\" + node.bytes;\n\n    } else {\n        if ((node.annots === undefined || node.annots.length === 0) &&\n            (node.args === undefined || node.args.length === 0)) {\n            return node.prim;\n        }\n\n        let ret = \"(\" + node.prim;\n        if (node.annots !== undefined) {\n            for (const a of node.annots) {\n                ret += \" \" + a;\n            }\n        }\n        if (node.args !== undefined) {\n            const multiline = isMultiline(node);\n            for (const a of node.args) {\n                if (multiline) {\n                    ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1));\n                } else {\n                    ret += \" \" + emitExpr(a, f);\n                }\n            }\n        }\n        return ret + \")\";\n    }\n}\n\nfunction emitSeq(node: Expr[], f: Formatter): string {\n    let ret = \"{\" + f.lf;\n    let i = node.length;\n    for (const el of node) {\n        ret += f.indent(1);\n\n        if (\"prim\" in el) {\n            ret += el.prim;\n\n            if (el.annots !== undefined) {\n                for (const a of el.annots) {\n                    ret += \" \" + a;\n                }\n            }\n            if (el.args !== undefined) {\n                const multiline = isMultiline(el);\n                for (const a of el.args) {\n                    if (multiline) {\n                        ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2));\n                    } else {\n                        ret += \" \" + emitExpr(a, f);\n                    }\n                }\n            }\n        } else {\n            ret += emitExpr(el, f.down(1));\n        }\n\n        ret += (i > 1 ? \";\" : \"\") + f.lf;\n        i--;\n    }\n    return ret + f.indent() + \"}\";\n}\n\n/**\n * Formats Micheline expression\n * @param expr An AST node\n * @param opt Options\n */\nexport function emitMicheline(expr: Expr, opt?: FormatOptions): string {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof expr !== \"object\") {\n        throw new TypeError(`object type was expected, got ${typeof expr} instead`);\n    }\n\n    return emitExpr(expr, new Formatter(opt));\n}","// Michelson types\n\nimport { Prim, Expr, IntLiteral, StringLiteral, BytesLiteral } from \"./micheline\";\nimport { Tuple, NoArgs, ReqArgs } from \"./utils\";\n\n// Instructions\n\nexport type MichelsonUnaryInstructionId = \"DUP\" | \"SWAP\" | \"SOME\" | \"UNIT\" | \"PAIR\" | \"CAR\" | \"CDR\" |\n   \"CONS\" | \"SIZE\" | \"MEM\" | \"GET\" | \"UPDATE\" | \"EXEC\" | \"FAILWITH\" | \"RENAME\" | \"CONCAT\" | \"SLICE\" |\n   \"PACK\" | \"ADD\" | \"SUB\" | \"MUL\" | \"EDIV\" | \"ABS\" | \"ISNAT\" | \"INT\" | \"NEG\" | \"LSL\" | \"LSR\" | \"OR\" |\n   \"AND\" | \"XOR\" | \"NOT\" | \"COMPARE\" | \"EQ\" | \"NEQ\" | \"LT\" | \"GT\" | \"LE\" | \"GE\" | \"SELF\" |\n   \"TRANSFER_TOKENS\" | \"SET_DELEGATE\" | \"CREATE_ACCOUNT\" | \"IMPLICIT_ACCOUNT\" | \"NOW\" | \"AMOUNT\" |\n   \"BALANCE\" | \"CHECK_SIGNATURE\" | \"BLAKE2B\" | \"SHA256\" | \"SHA512\" | \"HASH_KEY\" | \"STEPS_TO_QUOTA\" |\n   \"SOURCE\" | \"SENDER\" | \"ADDRESS\" | \"CHAIN_ID\";\n\nexport type MichelsonInstructionId = MichelsonUnaryInstructionId |\n   \"DROP\" | \"DIG\" | \"DUG\" | \"NONE\" | \"LEFT\" | \"RIGHT\" | \"NIL\" | \"UNPACK\" | \"CONTRACT\" | \"CAST\" |\n   \"IF_NONE\" | \"IF_LEFT\" | \"IF_CONS\" | \"IF\" | \"MAP\" | \"ITER\" | \"LOOP\" | \"LOOP_LEFT\" | \"DIP\" |\n   \"CREATE_CONTRACT\" | \"PUSH\" | \"EMPTY_SET\" | \"EMPTY_MAP\" | \"EMPTY_BIG_MAP\" | \"LAMBDA\";\n\ntype InstrPrim<PT extends MichelsonInstructionId, AT extends Expr[] = never> = Prim<PT, AT>;\n\nexport type MichelsonInstruction = MichelsonInstruction[] |\n   NoArgs<InstrPrim<MichelsonUnaryInstructionId>> |\n   ReqArgs<InstrPrim<\"DIG\" | \"DUG\", [IntLiteral]>> |\n   InstrPrim<\"DROP\", [IntLiteral]> | // Keep optional argument\n   ReqArgs<InstrPrim<\"NONE\" | \"LEFT\" | \"RIGHT\" | \"NIL\" | \"UNPACK\" | \"CONTRACT\" | \"CAST\", [MichelsonType]>> |\n   ReqArgs<InstrPrim<\"IF_NONE\" | \"IF_LEFT\" | \"IF_CONS\" | \"IF\", [MichelsonInstruction[], MichelsonInstruction[]]>> |\n   ReqArgs<InstrPrim<\"MAP\" | \"ITER\" | \"LOOP\" | \"LOOP_LEFT\" | \"DIP\" | \"CREATE_CONTRACT\", [MichelsonInstruction[]]>> |\n   ReqArgs<InstrPrim<\"PUSH\", [MichelsonType, MichelsonData]>> |\n   ReqArgs<InstrPrim<\"EMPTY_SET\", [MichelsonComparableType]>> |\n   ReqArgs<InstrPrim<\"EMPTY_MAP\" | \"EMPTY_BIG_MAP\", [MichelsonComparableType, MichelsonType]>> |\n   ReqArgs<InstrPrim<\"LAMBDA\", [MichelsonType, MichelsonType, MichelsonInstruction[]]>> |\n   ReqArgs<InstrPrim<\"DIP\", [IntLiteral, MichelsonInstruction[]] | [MichelsonInstruction[]]>>;\n\n// Types\n\nexport type MichelsonSimpleComparableTypeId = \"int\" | \"nat\" | \"string\" | \"bytes\" | \"mutez\" | \"bool\" |\n   \"key_hash\" | \"timestamp\" | \"address\";\n\nexport type MichelsonTypeId = MichelsonSimpleComparableTypeId |\n   \"key\" | \"unit\" | \"signature\" | \"operation\" | \"chain_id\" | \"option\" | \"list\" | \"contract\" | \"pair\" |\n   \"or\" | \"lambda\" | \"set\" | \"map\" | \"big_map\";\n\ntype TypePrim<PT extends MichelsonTypeId, AT extends MichelsonType[] = never> = Prim<PT, AT>;\n\nexport type MichelsonSimpleComparableType = NoArgs<TypePrim<MichelsonSimpleComparableTypeId>>;\nexport type MichelsonComparableType = MichelsonSimpleComparableType |\n   ReqArgs<TypePrim<\"pair\", [MichelsonSimpleComparableType, MichelsonComparableType]>>;\n\nexport type MichelsonType = MichelsonComparableType |\n   NoArgs<TypePrim<\"key\" | \"unit\" | \"signature\" | \"operation\" | \"chain_id\">> |\n   ReqArgs<TypePrim<\"option\" | \"list\" | \"contract\", [MichelsonType]>> |\n   ReqArgs<TypePrim<\"pair\" | \"or\" | \"lambda\", [MichelsonType, MichelsonType]>> |\n   ReqArgs<TypePrim<\"set\", [MichelsonComparableType]>> |\n   ReqArgs<TypePrim<\"map\" | \"big_map\", [MichelsonComparableType, MichelsonType]>>;\n\n// Data\n\nexport type MichelsonMapElt = ReqArgs<Prim<\"Elt\", [MichelsonData, MichelsonData]>>;\nexport type MichelsonDataId = \"Unit\" | \"True\" | \"False\" | \"None\" | \"Pair\" | \"Left\" | \"Right\" | \"Some\";\ntype DataPrim<PT extends MichelsonDataId, AT extends MichelsonData[] = never> = Prim<PT, AT>;\n\nexport type MichelsonData = IntLiteral |\n   StringLiteral |\n   BytesLiteral |\n   NoArgs<DataPrim<\"Unit\" | \"True\" | \"False\" | \"None\">> |\n   ReqArgs<DataPrim<\"Pair\", [MichelsonData, MichelsonData]>> |\n   ReqArgs<DataPrim<\"Left\" | \"Right\" | \"Some\", [MichelsonData]>> |\n   MichelsonData[] |\n   MichelsonMapElt[] |\n   MichelsonInstruction;\n\n// Top level script sections\n\ntype MichelsonSectionId = \"parameter\" | \"storage\" | \"code\";\ntype SectionPrim<PT extends MichelsonSectionId, AT extends Expr[]> = ReqArgs<Prim<PT, AT>>;\n\nexport type MichelsonParameter = SectionPrim<\"parameter\", [MichelsonType]>;\nexport type MichelsonStorage = SectionPrim<\"storage\", [MichelsonType]>;\nexport type MichelsonCode = SectionPrim<\"code\", [MichelsonInstruction[]]>;\n\nexport type MichelsonScript = [MichelsonParameter, MichelsonStorage, MichelsonCode] |\n   [MichelsonStorage, MichelsonCode, MichelsonParameter] |\n   [MichelsonCode, MichelsonParameter, MichelsonStorage];\n\n// Michelson validator\n\ninterface PathElem {\n   /**\n    * Node's index. Either argument index or sequence index.\n    */\n   index: number;\n   /**\n    * Node's value.\n    */\n   val: Expr;\n}\n\nexport class ValidationError extends Error {\n   /**\n    * @param val Value of a node caused the error\n    * @param path Path to a node caused the error in the AST tree\n    * @param message An error message\n    */\n   constructor(public val: Expr, public path?: PathElem[], message?: string) {\n      super(message);\n   }\n}\n\nfunction isPrim(ex: Expr): ex is Prim {\n   return \"prim\" in ex;\n}\n\nfunction assertPrim(ex: Expr, path: PathElem[]): ex is Prim {\n   if (isPrim(ex)) {\n      return true;\n   }\n   throw new ValidationError(ex, path, \"prim expression expected\");\n}\n\nfunction assertSeq(ex: Expr, path: PathElem[]): ex is Expr[] {\n   if (Array.isArray(ex)) {\n      return true;\n   }\n   throw new ValidationError(ex, path, \"sequence expression expected\");\n}\n\nfunction assertNatural(i: IntLiteral, path: PathElem[]) {\n   if (i.int[0] === \"-\") {\n      throw new ValidationError(i, path, \"natural number expected\");\n   }\n}\n\nfunction assertIntLiteral(ex: Expr, path: PathElem[]): ex is IntLiteral {\n   if (\"int\" in ex) {\n      return true;\n   }\n   throw new ValidationError(ex, path, \"int literal expected\");\n}\n\nfunction assertArgs<N extends number>(ex: Prim, n: N, path: PathElem[]):\n   ex is N extends 0 ?\n   NoArgs<Prim<string>> :\n   ReqArgs<Prim<string, Tuple<Expr, N>>> {\n   if ((n === 0 && ex.args === undefined) || ex.args?.length === n) {\n      return true;\n   }\n   throw new ValidationError(ex, path, `${n} arguments expected`);\n}\n\nconst unaryInstructionTable: Record<MichelsonUnaryInstructionId, boolean> = {\n   \"DUP\": true, \"SWAP\": true, \"SOME\": true, \"UNIT\": true, \"PAIR\": true, \"CAR\": true, \"CDR\": true,\n   \"CONS\": true, \"SIZE\": true, \"MEM\": true, \"GET\": true, \"UPDATE\": true, \"EXEC\": true, \"FAILWITH\": true, \"RENAME\": true, \"CONCAT\": true, \"SLICE\": true,\n   \"PACK\": true, \"ADD\": true, \"SUB\": true, \"MUL\": true, \"EDIV\": true, \"ABS\": true, \"ISNAT\": true, \"INT\": true, \"NEG\": true, \"LSL\": true, \"LSR\": true, \"OR\": true,\n   \"AND\": true, \"XOR\": true, \"NOT\": true, \"COMPARE\": true, \"EQ\": true, \"NEQ\": true, \"LT\": true, \"GT\": true, \"LE\": true, \"GE\": true, \"SELF\": true,\n   \"TRANSFER_TOKENS\": true, \"SET_DELEGATE\": true, \"CREATE_ACCOUNT\": true, \"IMPLICIT_ACCOUNT\": true, \"NOW\": true, \"AMOUNT\": true,\n   \"BALANCE\": true, \"CHECK_SIGNATURE\": true, \"BLAKE2B\": true, \"SHA256\": true, \"SHA512\": true, \"HASH_KEY\": true, \"STEPS_TO_QUOTA\": true,\n   \"SOURCE\": true, \"SENDER\": true, \"ADDRESS\": true, \"CHAIN_ID\": true,\n};\n\nconst instructionTable: Record<MichelsonInstructionId, boolean> = Object.assign({}, unaryInstructionTable, {\n   \"DROP\": true, \"DIG\": true, \"DUG\": true, \"NONE\": true, \"LEFT\": true, \"RIGHT\": true, \"NIL\": true, \"UNPACK\": true, \"CONTRACT\": true, \"CAST\": true,\n   \"IF_NONE\": true, \"IF_LEFT\": true, \"IF_CONS\": true, \"IF\": true, \"MAP\": true, \"ITER\": true, \"LOOP\": true, \"LOOP_LEFT\": true, \"DIP\": true,\n   \"CREATE_CONTRACT\": true, \"PUSH\": true, \"EMPTY_SET\": true, \"EMPTY_MAP\": true, \"EMPTY_BIG_MAP\": true, \"LAMBDA\": true,\n});\n\nfunction assertMichelsonInstruction(ex: Expr[] | Prim, path: PathElem[]): ex is MichelsonInstruction {\n   if (Array.isArray(ex)) {\n      let i = 0;\n      for (const n of ex) {\n         const p = [...path, { index: i, val: n }];\n         if (!Array.isArray(n) && !isPrim(n)) {\n            throw new ValidationError(ex, p, \"sequence or prim expected\");\n         }\n         assertMichelsonInstruction(n, p);\n         i++;\n      }\n   } else if (Object.prototype.hasOwnProperty.call(unaryInstructionTable, ex.prim)) {\n      assertArgs(ex, 0, path);\n   } else {\n      switch (ex.prim) {\n         case \"DROP\":\n            if (ex.args !== undefined && assertArgs(ex, 1, path)) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0], p)) {\n                  assertNatural(ex.args[0], p);\n               }\n            }\n            break;\n\n         case \"DIG\":\n         case \"DUG\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0], p)) {\n                  assertNatural(ex.args[0], p);\n               }\n            }\n            break;\n\n         case \"NONE\":\n         case \"LEFT\":\n         case \"RIGHT\":\n         case \"NIL\":\n         case \"UNPACK\":\n         case \"CONTRACT\":\n         case \"CAST\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"IF_NONE\":\n         case \"IF_LEFT\":\n         case \"IF_CONS\":\n         case \"IF\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               const p0 = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0], p0)) {\n                  assertMichelsonInstruction(ex.args[0], p0);\n               }\n               const p1 = [...path, { index: 1, val: ex.args[1] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[1], p1)) {\n                  assertMichelsonInstruction(ex.args[1], p1);\n               }\n            }\n            break;\n\n         case \"MAP\":\n         case \"ITER\":\n         case \"LOOP\":\n         case \"LOOP_LEFT\":\n         case \"CREATE_CONTRACT\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0], p)) {\n                  assertMichelsonInstruction(ex.args[0], p);\n               }\n            }\n            break;\n\n         case \"DIP\":\n            if (ex.args?.length === 2) {\n               const p0 = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0], p0)) {\n                  assertNatural(ex.args[0], p0);\n               }\n               const p1 = [...path, { index: 1, val: ex.args[1] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[1], p1)) {\n                  assertMichelsonInstruction(ex.args[1], p1);\n               }\n            } else if (ex.args?.length === 1) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0], p)) {\n                  assertMichelsonInstruction(ex.args[0], p);\n               }\n            } else {\n               throw new ValidationError(ex, path, \"1 or 2 arguments expected\");\n            }\n            break;\n\n         case \"PUSH\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonDataInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"EMPTY_SET\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"EMPTY_MAP\":\n         case \"EMPTY_BIG_MAP\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"LAMBDA\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 3, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n               const p2 = [...path, { index: 2, val: ex.args[2] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[2], p2)) {\n                  assertMichelsonInstruction(ex.args[2], p2);\n               }\n            }\n            break;\n\n         default:\n            throw new ValidationError(ex, path, \"instruction expected\");\n      }\n   }\n   return true;\n}\n\nconst simpleComparableTypeTable: Record<MichelsonSimpleComparableTypeId, boolean> = {\n   \"int\": true, \"nat\": true, \"string\": true, \"bytes\": true, \"mutez\": true,\n   \"bool\": true, \"key_hash\": true, \"timestamp\": true, \"address\": true,\n};\n\nfunction assertMichelsonSimpleComparableType(ex: Expr, path: PathElem[]): ex is MichelsonSimpleComparableType {\n   /* istanbul ignore else */\n   if (assertPrim(ex, path)) {\n      if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n         throw new ValidationError(ex, path, \"simple comparable type expected\");\n      }\n      assertArgs(ex, 0, path);\n   }\n   return true;\n}\n\nfunction assertMichelsonComparableType(ex: Expr, path: PathElem[]): ex is MichelsonComparableType {\n   /* istanbul ignore else */\n   if (assertPrim(ex, path)) {\n      if (Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n         assertArgs(ex, 0, path);\n      } else if (ex.prim === \"pair\") {\n         /* istanbul ignore else */\n         if (assertArgs(ex, 2, path)) {\n            assertMichelsonSimpleComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            assertMichelsonComparableType(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n         }\n      } else {\n         throw new ValidationError(ex, path, \"comparable type expected\");\n      }\n   }\n   return true;\n}\n\nfunction assertMichelsonTypeInternal(ex: Expr, path: PathElem[]): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrim(ex, path)) {\n      switch (ex.prim) {\n         case \"key\":\n         case \"unit\":\n         case \"signature\":\n         case \"operation\":\n         case \"chain_id\":\n            assertArgs(ex, 0, path);\n            break;\n\n         case \"option\":\n         case \"list\":\n         case \"contract\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"pair\":\n         case \"or\":\n         case \"lambda\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"set\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"map\":\n         case \"big_map\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         default:\n            assertMichelsonComparableType(ex, path);\n      }\n   }\n\n   return true;\n}\n\nfunction assertMichelsonDataInternal(ex: Expr, path: PathElem[]): ex is MichelsonData {\n   if ((\"int\" in ex) || (\"string\" in ex) || (\"bytes\" in ex)) {\n      return true;\n   }\n\n   if (Array.isArray(ex)) {\n      let mapElts = 0;\n      let i = 0;\n      for (const n of ex) {\n         const p = [...path, { index: i, val: n }];\n         if (isPrim(n) && n.prim === \"Elt\") {\n            /* istanbul ignore else */\n            if (assertArgs(n, 2, p)) {\n               assertMichelsonDataInternal(n.args[0], [...p, { index: 0, val: n.args[0] }]);\n               assertMichelsonDataInternal(n.args[1], [...p, { index: 1, val: n.args[1] }]);\n            }\n            mapElts++;\n         } else {\n            assertMichelsonDataInternal(n, p);\n         }\n         i++;\n      }\n\n      if (mapElts !== 0 && mapElts !== ex.length) {\n         throw new ValidationError(ex, path, \"data entries and map elements can't be intermixed\");\n      }\n      return true;\n   }\n\n   if (isPrim(ex)) {\n      switch (ex.prim) {\n         case \"Unit\":\n         case \"True\":\n         case \"False\":\n         case \"None\":\n            assertArgs(ex, 0, path);\n            break;\n\n         case \"Pair\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonDataInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonDataInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"Left\":\n         case \"Right\":\n         case \"Some\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonDataInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         default:\n            if (Object.prototype.hasOwnProperty.call(instructionTable, ex.prim)) {\n               assertMichelsonInstruction(ex, path);\n            } else {\n               throw new ValidationError(ex, path, \"data entry or instruction expected\");\n            }\n      }\n   } else {\n      throw new ValidationError(ex, path, \"data entry expected\");\n   }\n\n   return true;\n}\n\nfunction assertMichelsonScriptInternal(ex: Expr, path: PathElem[]): ex is MichelsonScript {\n   /* istanbul ignore else */\n   if (assertSeq(ex, path) && ex.length === 3 &&\n      assertPrim(ex[0], [...path, { index: 0, val: ex[0] }]) &&\n      assertPrim(ex[1], [...path, { index: 1, val: ex[1] }]) &&\n      assertPrim(ex[2], [...path, { index: 2, val: ex[2] }])) {\n\n      const p = [ex[0].prim, ex[1].prim, ex[2].prim].sort();\n      if (p[0] === \"code\" && p[1] === \"parameter\" && p[2] === \"storage\") {\n         let i = 0;\n         for (const n of ex as Prim[]) {\n            const p = [...path, { index: i, val: n }];\n\n            /* istanbul ignore else */\n            if (assertArgs(n, 1, p)) {\n               const pp = [...p, { index: 0, val: n.args[0] }];\n\n               switch (n.prim) {\n                  case \"code\":\n                     /* istanbul ignore else */\n                     if (assertSeq(n.args[0], pp)) {\n                        assertMichelsonInstruction(n.args[0], pp);\n                     }\n                     break;\n\n                  case \"parameter\":\n                  case \"storage\":\n                     assertMichelsonTypeInternal(n.args[0], pp);\n               }\n            }\n            i++;\n         }\n      } else {\n         throw new ValidationError(ex, path, \"valid Michelson script expected\");\n      }\n   }\n   return true;\n}\n\n/**\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonScript(ex: Expr): ex is MichelsonScript {\n   return assertMichelsonScriptInternal(ex, []);\n}\n\n/**\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonData(ex: Expr): ex is MichelsonData {\n   return assertMichelsonDataInternal(ex, []);\n}\n\n/**\n * Checks if the node is a valid Michelson code (sequence of instructions).\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonCode(ex: Expr[]): ex is MichelsonInstruction[] {\n   return assertMichelsonInstruction(ex, []);\n}\n\n/**\n * Checks if the node is a valid Michelson type expression.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonType(ex: Expr): ex is MichelsonType {\n   return assertMichelsonTypeInternal(ex, []);\n}"],"names":["assertArgs"],"mappings":"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"}