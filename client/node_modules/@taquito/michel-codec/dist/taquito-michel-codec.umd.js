(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.taquitoMichelCodec = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var ScanError = /** @class */ (function (_super) {
        __extends(ScanError, _super);
        function ScanError(src, idx, message) {
            var _this = _super.call(this, message) || this;
            _this.src = src;
            _this.idx = idx;
            return _this;
        }
        return ScanError;
    }(Error));
    var Literal;
    (function (Literal) {
        Literal[Literal["Comment"] = 0] = "Comment";
        Literal[Literal["Number"] = 1] = "Number";
        Literal[Literal["String"] = 2] = "String";
        Literal[Literal["Bytes"] = 3] = "Bytes";
        Literal[Literal["Ident"] = 4] = "Ident";
    })(Literal || (Literal = {}));
    var isSpace = new RegExp("\\s");
    var isIdentStart = new RegExp("[:@%_A-Za-z]");
    var isIdent = new RegExp("[@%_\\.A-Za-z0-9]");
    var isDigit = new RegExp("[0-9]");
    var isHex = new RegExp("[0-9a-fA-F]");
    function scan(src, scanComments) {
        var i, s, start, ii, esc;
        if (scanComments === void 0) { scanComments = false; }
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < src.length)) return [3 /*break*/, 16];
                    // Skip space
                    while (i < src.length && isSpace.test(src[i])) {
                        i++;
                    }
                    if (i === src.length) {
                        return [2 /*return*/];
                    }
                    s = src[i];
                    start = i;
                    if (!isIdentStart.test(s)) return [3 /*break*/, 3];
                    // Identifier
                    i++;
                    while (i < src.length && isIdent.test(src[i])) {
                        i++;
                    }
                    return [4 /*yield*/, { t: Literal.Ident, v: src.slice(start, i), offset: i }];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 15];
                case 3:
                    if (!(src.length - i > 1 && src.substr(i, 2) === "0x")) return [3 /*break*/, 5];
                    // Bytes
                    i += 2;
                    while (i < src.length && isHex.test(src[i])) {
                        i++;
                    }
                    if (i - start === 2) {
                        throw new ScanError(src, i, "Bytes literal is too short");
                    }
                    else if (((i - start) & 1) !== 0) {
                        throw new ScanError(src, i, "Bytes literal length is expected to be power of two");
                    }
                    return [4 /*yield*/, { t: Literal.Bytes, v: src.slice(start, i), offset: i }];
                case 4:
                    _a.sent();
                    return [3 /*break*/, 15];
                case 5:
                    if (!(isDigit.test(s) || s === "-")) return [3 /*break*/, 7];
                    // Number
                    if (s === "-") {
                        i++;
                    }
                    ii = i;
                    while (i < src.length && isDigit.test(src[i])) {
                        i++;
                    }
                    if (ii === i) {
                        throw new ScanError(src, i, "Number literal is too short");
                    }
                    return [4 /*yield*/, { t: Literal.Number, v: src.slice(start, i), offset: i }];
                case 6:
                    _a.sent();
                    return [3 /*break*/, 15];
                case 7:
                    if (!(s === "\"")) return [3 /*break*/, 9];
                    // String
                    i++;
                    esc = false;
                    for (; i < src.length && (esc || src[i] !== "\""); i++) {
                        if (!esc && src[i] === "\\") {
                            esc = true;
                        }
                        else {
                            esc = false;
                        }
                    }
                    if (i === src.length) {
                        throw new ScanError(src, i, "Unterminated string literal");
                    }
                    i++;
                    return [4 /*yield*/, { t: Literal.String, v: src.slice(start, i), offset: i }];
                case 8:
                    _a.sent();
                    return [3 /*break*/, 15];
                case 9:
                    if (!(s === "#")) return [3 /*break*/, 12];
                    // Comment
                    i++;
                    while (i < src.length && src[i] !== "\n") {
                        i++;
                    }
                    if (!scanComments) return [3 /*break*/, 11];
                    return [4 /*yield*/, { t: Literal.Comment, v: src.slice(start, i), offset: i }];
                case 10:
                    _a.sent();
                    _a.label = 11;
                case 11: return [3 /*break*/, 15];
                case 12:
                    if (!(s === "(" || s === ")" || s === "{" || s === "}" || s === ";")) return [3 /*break*/, 14];
                    i++;
                    return [4 /*yield*/, { t: s, v: s, offset: i }];
                case 13:
                    _a.sent();
                    return [3 /*break*/, 15];
                case 14: throw new ScanError(src, i, "Invalid character at offset " + i + ": `" + s + "'");
                case 15: return [3 /*break*/, 1];
                case 16: return [2 /*return*/];
            }
        });
    }

    var MacroError = /** @class */ (function (_super) {
        __extends(MacroError, _super);
        function MacroError(prim, message) {
            var _this = _super.call(this, message) || this;
            _this.prim = prim;
            return _this;
        }
        return MacroError;
    }(Error));
    function assertArgs(ex, n) {
        var _a, _b;
        if ((n === 0 && ex.args === undefined) || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {
            return true;
        }
        throw new MacroError(ex, "macro " + ex.prim + " expects " + n + " arguments, was given " + ((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length));
    }
    function assertNoAnnots(ex) {
        if (ex.annots === undefined) {
            return true;
        }
        throw new MacroError(ex, "unexpected annotation on macro " + ex.prim + ": " + ex.annots);
    }
    function assertIntArg(ex, arg) {
        if ("int" in arg) {
            return true;
        }
        throw new MacroError(ex, "macro " + ex.prim + " expects int argument");
    }
    function parsePairUnpairExpr(p, expr, annotations, agg) {
        var res = [];
        var i = 0;
        var ai = 0;
        var ann = [null, null];
        // Left expression
        if (i === expr.length) {
            throw new MacroError(p, "unexpected end: " + p.prim);
        }
        var c = expr[i++];
        switch (c) {
            case "P":
                var _a = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg), r = _a.r, n = _a.n, an = _a.an;
                res.push.apply(res, __spread(r));
                i += n;
                ai += an;
                break;
            case "A":
                if (ai !== annotations.length) {
                    ann[0] = annotations[ai++];
                }
                break;
            default:
                throw new MacroError(p, p.prim + ": unexpected character: " + c);
        }
        // Right expression
        if (i === expr.length) {
            throw new MacroError(p, "unexpected end: " + p.prim);
        }
        c = expr[i++];
        switch (c) {
            case "P":
                var _b = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg), r = _b.r, n = _b.n, an = _b.an;
                res.push.apply(res, __spread(r.map(function (_a) {
                    var _b = __read(_a, 2), v = _b[0], a = _b[1];
                    return [v + 1, a];
                })));
                i += n;
                ai += an;
                break;
            case "I":
                if (ai !== annotations.length) {
                    ann[1] = annotations[ai++];
                }
                break;
            default:
                throw new MacroError(p, p.prim + ": unexpected character: " + c);
        }
        return { r: agg(res, [0, ann]), n: i, an: ai };
    }
    function parseSetMapCadr(p, expr, vann, term) {
        var c = expr[0];
        switch (c) {
            case "A":
                return expr.length > 1 ?
                    [
                        { prim: "DUP" },
                        {
                            prim: "DIP",
                            args: [[
                                    { prim: "CAR", annots: ["@%%"] },
                                    parseSetMapCadr(p, expr.slice(1), [], term),
                                ]],
                        },
                        { prim: "CDR", annots: ["@%%"] },
                        { prim: "SWAP" },
                        { prim: "PAIR", annots: __spread(["%@", "%@"], vann) },
                    ] : term.a;
            case "D":
                return expr.length > 1 ?
                    [
                        { prim: "DUP" },
                        {
                            prim: "DIP",
                            args: [[
                                    { prim: "CDR", annots: ["@%%"] },
                                    parseSetMapCadr(p, expr.slice(1), [], term),
                                ]],
                        },
                        { prim: "CAR", annots: ["@%%"] },
                        { prim: "PAIR", annots: __spread(["%@", "%@"], vann) },
                    ] : term.d;
            default:
                throw new MacroError(p, p.prim + ": unexpected character: " + c);
        }
    }
    function trimLast(a, v) {
        var l = a.length;
        while (l > 0 && a[l - 1] === v) {
            l--;
        }
        return a.slice(0, l);
    }
    function filterAnnotations(a) {
        var e_1, _a;
        var fields = [];
        var rest = [];
        if (a !== undefined) {
            try {
                for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {
                    var v = a_1_1.value;
                    (v.length !== 0 && v[0] === "%" ? fields : rest).push(v);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return { fields: fields, rest: rest };
    }
    function mkPrim(_a) {
        var prim = _a.prim, annots = _a.annots, args = _a.args;
        return __assign(__assign({ prim: prim }, (annots && { annots: annots })), (args && { args: args }));
    }
    var pairRe = /^P[PAI]{3,}R$/;
    var unpairRe = /^UNP[PAI]{2,}R$/;
    var cadrRe = /^C[AD]{2,}R$/;
    var setCadrRe = /^SET_C[AD]+R$/;
    var mapCadrRe = /^MAP_C[AD]+R$/;
    var diipRe = /^DI{2,}P$/;
    var duupRe = /^DU+P$/;
    function expandMacros(ex) {
        function mayRename(annots) {
            return annots !== undefined ? [{ prim: "RENAME", annots: annots }] : [];
        }
        switch (ex.prim) {
            // Compare
            case "CMPEQ":
            case "CMPNEQ":
            case "CMPLT":
            case "CMPGT":
            case "CMPLE":
            case "CMPGE":
                if (assertArgs(ex, 0)) {
                    return [
                        { prim: "COMPARE" },
                        mkPrim({ prim: ex.prim.slice(3), annots: ex.annots }),
                    ];
                }
                break;
            case "IFEQ":
            case "IFNEQ":
            case "IFLT":
            case "IFGT":
            case "IFLE":
            case "IFGE":
                if (assertArgs(ex, 2)) {
                    return [
                        { prim: ex.prim.slice(2) },
                        mkPrim({ prim: "IF", annots: ex.annots, args: ex.args }),
                    ];
                }
                break;
            case "IFCMPEQ":
            case "IFCMPNEQ":
            case "IFCMPLT":
            case "IFCMPGT":
            case "IFCMPLE":
            case "IFCMPGE":
                if (assertArgs(ex, 2)) {
                    return [
                        { prim: "COMPARE" },
                        { prim: ex.prim.slice(5) },
                        mkPrim({ prim: "IF", annots: ex.annots, args: ex.args }),
                    ];
                }
                break;
            // Fail
            case "FAIL":
                if (assertArgs(ex, 0) && assertNoAnnots(ex)) {
                    return [
                        { prim: "UNIT" },
                        { prim: "FAILWITH" },
                    ];
                }
                break;
            // Assertion macros
            case "ASSERT":
                if (assertArgs(ex, 0) && assertNoAnnots(ex)) {
                    return [{
                            prim: "IF", args: [
                                [],
                                [[{ prim: "UNIT" }, { prim: "FAILWITH" }]],
                            ]
                        }];
                }
                break;
            case "ASSERT_EQ":
            case "ASSERT_NEQ":
            case "ASSERT_LT":
            case "ASSERT_GT":
            case "ASSERT_LE":
            case "ASSERT_GE":
                if (assertArgs(ex, 0) && assertNoAnnots(ex)) {
                    return [
                        { prim: ex.prim.slice(7) },
                        {
                            prim: "IF", args: [
                                [],
                                [[{ prim: "UNIT" }, { prim: "FAILWITH" }]],
                            ]
                        },
                    ];
                }
                break;
            case "ASSERT_CMPEQ":
            case "ASSERT_CMPNEQ":
            case "ASSERT_CMPLT":
            case "ASSERT_CMPGT":
            case "ASSERT_CMPLE":
            case "ASSERT_CMPGE":
                if (assertArgs(ex, 0) && assertNoAnnots(ex)) {
                    return [
                        [
                            { prim: "COMPARE" },
                            { prim: ex.prim.slice(10) },
                        ],
                        {
                            prim: "IF", args: [
                                [],
                                [[{ prim: "UNIT" }, { prim: "FAILWITH" }]],
                            ]
                        },
                    ];
                }
                break;
            case "ASSERT_NONE":
                if (assertArgs(ex, 0) && assertNoAnnots(ex)) {
                    return [{
                            prim: "IF_NONE", args: [
                                [],
                                [[{ prim: "UNIT" }, { prim: "FAILWITH" }]],
                            ]
                        }];
                }
                break;
            case "ASSERT_SOME":
                if (assertArgs(ex, 0)) {
                    return [{
                            prim: "IF_NONE", args: [
                                [[{ prim: "UNIT" }, { prim: "FAILWITH" }]],
                                mayRename(ex.annots),
                            ]
                        }];
                }
                break;
            case "ASSERT_LEFT":
                if (assertArgs(ex, 0)) {
                    return [{
                            prim: "IF_LEFT", args: [
                                mayRename(ex.annots),
                                [[{ prim: "UNIT" }, { prim: "FAILWITH" }]],
                            ]
                        }];
                }
                break;
            case "ASSERT_RIGHT":
                if (assertArgs(ex, 0)) {
                    return [{
                            prim: "IF_LEFT", args: [
                                [[{ prim: "UNIT" }, { prim: "FAILWITH" }]],
                                mayRename(ex.annots),
                            ]
                        }];
                }
                break;
            // Syntactic conveniences
            case "IF_SOME":
                if (assertArgs(ex, 2)) {
                    return [mkPrim({ prim: "IF_NONE", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];
                }
                break;
            case "IF_RIGHT":
                if (assertArgs(ex, 2)) {
                    return [mkPrim({ prim: "IF_LEFT", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];
                }
        }
        // More syntactic conveniences
        // PAPPAIIR macro
        if (pairRe.test(ex.prim)) {
            if (assertArgs(ex, 0)) {
                var _a = filterAnnotations(ex.annots), fields = _a.fields, rest_1 = _a.rest;
                var r_1 = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, function (a, v) { return __spread(a, [v]); }).r;
                return r_1.map(function (_a, i) {
                    var _b = __read(_a, 2), v = _b[0], a = _b[1];
                    var ann = __spread(trimLast(a, null).map(function (v) { return v === null ? "%" : v; }), ((v === 0 && i === r_1.length - 1) ? rest_1 : []));
                    var leaf = mkPrim({ prim: "PAIR", annots: ann.length !== 0 ? ann : undefined, });
                    return v === 0 ? leaf : {
                        prim: "DIP",
                        args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],
                    };
                });
            }
        }
        // UNPAPPAIIR macro
        if (unpairRe.test(ex.prim)) {
            if (assertArgs(ex, 0)) {
                var r = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], function (a, v) { return __spread([v], a); }).r;
                return r.map(function (_a) {
                    var _b = __read(_a, 2), v = _b[0], a = _b[1];
                    var leaf = [
                        { prim: "DUP" },
                        mkPrim({ prim: "CAR", annots: a[0] !== null ? [a[0]] : undefined }),
                        {
                            prim: "DIP",
                            args: [[mkPrim({ prim: "CDR", annots: a[1] !== null ? [a[1]] : undefined })]],
                        }
                    ];
                    return v === 0 ? leaf : {
                        prim: "DIP",
                        args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],
                    };
                });
            }
        }
        // C[AD]+R macro
        if (cadrRe.test(ex.prim)) {
            if (assertArgs(ex, 0)) {
                var ch_1 = __spread(ex.prim.slice(1, ex.prim.length - 1));
                return ch_1.map(function (c, i) {
                    var ann = i === ch_1.length - 1 ? ex.annots : undefined;
                    switch (c) {
                        case "A":
                            return mkPrim({ prim: "CAR", annots: ann });
                        case "D":
                            return mkPrim({ prim: "CDR", annots: ann });
                        default:
                            throw new MacroError(ex, "unexpected character: " + c);
                    }
                });
            }
        }
        // SET_C[AD]+R macro
        if (setCadrRe.test(ex.prim)) {
            if (assertArgs(ex, 0)) {
                var _b = filterAnnotations(ex.annots), fields = _b.fields, rest = _b.rest;
                if (fields.length > 1) {
                    throw new MacroError(ex, "unexpected annotation on macro " + ex.prim + ": " + fields);
                }
                var term = fields.length !== 0 ?
                    {
                        a: [
                            { prim: "DUP" },
                            { prim: "CAR", annots: fields },
                            { prim: "DROP" },
                            { prim: "CDR", annots: ["@%%"] },
                            { prim: "SWAP" },
                            { prim: "PAIR", annots: [fields[0], "%@"] },
                        ],
                        d: [
                            { prim: "DUP" },
                            { prim: "CDR", annots: fields },
                            { prim: "DROP" },
                            { prim: "CAR", annots: ["@%%"] },
                            { prim: "PAIR", annots: ["%@", fields[0]] },
                        ],
                    } :
                    {
                        a: [
                            { prim: "CDR", annots: ["@%%"] },
                            { prim: "SWAP" },
                            { prim: "PAIR", annots: ["%", "%@"] },
                        ],
                        d: [
                            { prim: "CAR", annots: ["@%%"] },
                            { prim: "PAIR", annots: ["%@", "%"] },
                        ],
                    };
                return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);
            }
        }
        // MAP_C[AD]+R macro
        if (mapCadrRe.test(ex.prim)) {
            if (assertArgs(ex, 1)) {
                var fields = filterAnnotations(ex.annots).fields;
                if (fields.length > 1) {
                    throw new MacroError(ex, "unexpected annotation on macro " + ex.prim + ": " + fields);
                }
                var term = {
                    a: [
                        { prim: "DUP" },
                        { prim: "CDR", annots: ["@%%"] },
                        {
                            prim: "DIP", args: [[
                                    mkPrim({ prim: "CAR", annots: fields.length !== 0 ? ["@" + fields[0].slice(1)] : undefined }),
                                    ex.args[0],
                                ]]
                        },
                        { prim: "SWAP" },
                        { prim: "PAIR", annots: [fields.length !== 0 ? fields[0] : "%", "%@"] },
                    ],
                    d: [
                        { prim: "DUP" },
                        mkPrim({ prim: "CDR", annots: fields.length !== 0 ? ["@" + fields[0].slice(1)] : undefined }),
                        ex.args[0],
                        { prim: "SWAP" },
                        { prim: "CAR", annots: ["@%%"] },
                        { prim: "PAIR", annots: ["%@", fields.length !== 0 ? fields[0] : "%"] },
                    ],
                };
                return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);
            }
        }
        // Expand deprecated DI...IP to [DIP n]
        if (diipRe.test(ex.prim)) {
            if (assertArgs(ex, 1)) {
                var n = 0;
                while (ex.prim[1 + n] === "I") {
                    n++;
                }
                return mkPrim({ prim: "DIP", args: [{ int: String(n) }, ex.args[0]] });
            }
        }
        // Expand modern DUP n or deprecated DU...UP
        if (duupRe.test(ex.prim)) {
            var n = 0;
            while (ex.prim[1 + n] === "U") {
                n++;
            }
            if (n === 1) {
                if (ex.args === undefined) {
                    return ex; // skip
                }
                if (assertArgs(ex, 1) && assertIntArg(ex, ex.args[0])) {
                    n = parseInt(ex.args[0].int, 10);
                }
            }
            else {
                assertArgs(ex, 0);
            }
            if (n === 1) {
                return [mkPrim({ prim: "DUP", annots: ex.annots })];
            }
            else if (n === 2) {
                return [
                    {
                        prim: "DIP",
                        args: [[mkPrim({ prim: "DUP", annots: ex.annots })]],
                    },
                    { prim: "SWAP" },
                ];
            }
            else {
                return [
                    {
                        prim: "DIP",
                        args: [
                            { int: String(n - 1) },
                            [mkPrim({ prim: "DUP", annots: ex.annots })],
                        ],
                    },
                    {
                        prim: "DIG",
                        args: [{ int: String(n) }],
                    },
                ];
            }
        }
        return ex;
    }

    var MichelineParseError = /** @class */ (function (_super) {
        __extends(MichelineParseError, _super);
        /**
         * @param token A token caused the error
         * @param message An error message
         */
        function MichelineParseError(token, message) {
            var _this = _super.call(this, message) || this;
            _this.token = token;
            return _this;
        }
        return MichelineParseError;
    }(Error));
    var JSONParseError = /** @class */ (function (_super) {
        __extends(JSONParseError, _super);
        /**
         * @param node A node caused the error
         * @param message An error message
         */
        function JSONParseError(node, message) {
            var _this = _super.call(this, message) || this;
            _this.node = node;
            return _this;
        }
        return JSONParseError;
    }(Error));
    var errEOF = new MichelineParseError(null, 'Unexpected EOF');
    function isAnnotation(tok) {
        return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');
    }
    var intRe = new RegExp('^-?[0-9]+$');
    var bytesRe = new RegExp('^([0-9a-fA-F]{2})+$');
    /**
     * Converts and validates Michelson expressions between JSON-based Michelson and Micheline
     *
     * Pretty Print a Michelson Smart Contract:
     * ```
     * const contract = await Tezos.contract.at("KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg");
     * const p = new Parser();
     *
     * const michelsonCode = p.parseJSON(contract.script.code);
     * const storage = p.parseJSON(contract.script.storage);
     *
     * console.log("Pretty print Michelson smart contract:");
     * console.log(emitMicheline(michelsonCode, {indent:"    ", newline: "\n",}));
     *
     * console.log("Pretty print Storage:");
     * console.log(emitMicheline(storage, {indent:"    ", newline: "\n",}));
     * ```
     *
     * Encode a Michelson expression for inital storage of a smart contract
     * ```
     * const src = `(Pair (Pair { Elt 1
     *                (Pair (Pair "tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")
     *                      0x0501000000026869) }
     *          10000000)
     *    (Pair 2 333))`;
     *
     * const p = new Parser();
     *
     * const exp = p.parseMichelineExpression(src);
     * console.log(JSON.stringify(exp));
     * ```
     */
    var Parser = /** @class */ (function () {
        function Parser(opt) {
            this.opt = opt;
        }
        Parser.prototype.expand = function (ex) {
            var _a;
            return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.expandMacros) ? expandMacros(ex) : ex;
        };
        Parser.prototype.parseList = function (scanner) {
            var tok = scanner.next();
            if (tok.done) {
                throw errEOF;
            }
            if (tok.value.t !== Literal.Ident) {
                throw new MichelineParseError(tok.value, "List: not an identifier: " + tok.value.v);
            }
            var ret = {
                prim: tok.value.v,
            };
            for (;;) {
                var tok_1 = scanner.next();
                if (tok_1.done) {
                    throw errEOF;
                }
                if (tok_1.value.t === ')') {
                    break;
                }
                if (isAnnotation(tok_1.value)) {
                    ret.annots = ret.annots || [];
                    ret.annots.push(tok_1.value.v);
                }
                else {
                    ret.args = ret.args || [];
                    ret.args.push(this.parseExpr(scanner, tok_1.value));
                }
            }
            return this.expand(ret);
        };
        Parser.prototype.parseArgs = function (scanner, prim, expectBracket) {
            // Identifier with arguments
            var p = { prim: prim };
            for (;;) {
                var t = scanner.next();
                if (t.done) {
                    if (expectBracket) {
                        throw errEOF;
                    }
                    else {
                        return [p, true];
                    }
                }
                else if (t.value.t === '}') {
                    if (!expectBracket) {
                        throw new MichelineParseError(t.value, "Seq: unexpected token: " + t.value.v);
                    }
                    else {
                        return [p, true];
                    }
                }
                else if (t.value.t === ';') {
                    return [p, false];
                }
                if (isAnnotation(t.value)) {
                    p.annots = p.annots || [];
                    p.annots.push(t.value.v);
                }
                else {
                    p.args = p.args || [];
                    p.args.push(this.parseExpr(scanner, t.value));
                }
            }
        };
        Parser.prototype.parseSequence = function (scanner, initialToken, expectBracket) {
            var seq = [];
            for (;;) {
                var tok = void 0;
                if (initialToken !== null) {
                    tok = initialToken;
                    initialToken = null;
                }
                else {
                    var t = scanner.next();
                    if (t.done) {
                        if (expectBracket) {
                            throw errEOF;
                        }
                        else {
                            return seq;
                        }
                    }
                    tok = t.value;
                }
                if (tok.t === '}') {
                    if (!expectBracket) {
                        throw new MichelineParseError(tok, "Seq: unexpected token: " + tok.v);
                    }
                    else {
                        return seq;
                    }
                }
                else if (tok.t === Literal.Ident) {
                    // Identifier with arguments
                    var _a = __read(this.parseArgs(scanner, tok.v, expectBracket), 2), itm = _a[0], done = _a[1];
                    seq.push(this.expand(itm));
                    if (done) {
                        return seq;
                    }
                }
                else {
                    // Other
                    seq.push(this.parseExpr(scanner, tok));
                    var t = scanner.next();
                    if (t.done) {
                        if (expectBracket) {
                            throw errEOF;
                        }
                        else {
                            return seq;
                        }
                    }
                    else if (t.value.t === '}') {
                        if (!expectBracket) {
                            throw new MichelineParseError(t.value, "Seq: unexpected token: " + t.value.v);
                        }
                        else {
                            return seq;
                        }
                    }
                    else if (t.value.t !== ';') {
                        throw new MichelineParseError(t.value, "Seq: unexpected token: " + t.value.v);
                    }
                }
            }
        };
        Parser.prototype.parseExpr = function (scanner, tok) {
            switch (tok.t) {
                case Literal.Ident:
                    return this.expand({ prim: tok.v });
                case Literal.Number:
                    return { int: tok.v };
                case Literal.String:
                    return { string: JSON.parse(tok.v) };
                case Literal.Bytes:
                    return { bytes: tok.v.substr(2) };
                case '(':
                    return this.parseList(scanner);
                case '{':
                    return this.parseSequence(scanner, null, true);
                default:
                    throw new MichelineParseError(tok, "Expr: unexpected token: " + tok.v);
            }
        };
        /**
         * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.
         * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`
         */
        Parser.prototype.parseScript = function (src) {
            // tslint:disable-next-line: strict-type-predicates
            if (typeof src !== "string") {
                throw new TypeError("string type was expected, got " + typeof src + " instead");
            }
            var scanner = scan(src);
            var tok = scanner.next();
            if (tok.done) {
                return null;
            }
            return tok.value.t === '{'
                ? this.parseSequence(scanner, null, true)
                : this.parseSequence(scanner, tok.value, false);
        };
        /**
         * Parse any Michelson expression
         * @param src A Michelson expression such as `(Pair {Elt "0" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`
         * @returns An AST node or null for empty document.
         */
        Parser.prototype.parseMichelineExpression = function (src) {
            // tslint:disable-next-line: strict-type-predicates
            if (typeof src !== "string") {
                throw new TypeError("string type was expected, got " + typeof src + " instead");
            }
            var scanner = scan(src);
            var tok = scanner.next();
            if (tok.done) {
                return null;
            }
            return this.parseExpr(scanner, tok.value);
        };
        /**
         * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).
         * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`
         */
        Parser.prototype.parseJSON = function (src) {
            var e_1, _a, e_2, _b, e_3, _c;
            // tslint:disable-next-line: strict-type-predicates
            if (typeof src !== "object") {
                throw new TypeError("object type was expected, got " + typeof src + " instead");
            }
            if (Array.isArray(src)) {
                var ret = [];
                try {
                    for (var src_1 = __values(src), src_1_1 = src_1.next(); !src_1_1.done; src_1_1 = src_1.next()) {
                        var n = src_1_1.value;
                        if (n === null || typeof n !== 'object') {
                            throw new JSONParseError(n, "unexpected sequence element: " + n);
                        }
                        ret.push(this.parseJSON(n));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (src_1_1 && !src_1_1.done && (_a = src_1.return)) _a.call(src_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return ret;
            }
            else if ('prim' in src) {
                var p = src;
                if (typeof p.prim === 'string' &&
                    (p.annots === undefined || Array.isArray(p.annots)) &&
                    (p.args === undefined || Array.isArray(p.args))) {
                    var ret = {
                        prim: p.prim,
                    };
                    if (p.annots !== undefined) {
                        try {
                            for (var _d = __values(p.annots), _e = _d.next(); !_e.done; _e = _d.next()) {
                                var a = _e.value;
                                if (typeof a !== 'string') {
                                    throw new JSONParseError(a, "string expected: " + a);
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        ret.annots = p.annots;
                    }
                    if (p.args !== undefined) {
                        ret.args = [];
                        try {
                            for (var _f = __values(p.args), _g = _f.next(); !_g.done; _g = _f.next()) {
                                var a = _g.value;
                                if (a === null || typeof a !== 'object') {
                                    throw new JSONParseError(a, "unexpected argument: " + a);
                                }
                                ret.args.push(this.parseJSON(a));
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                    return this.expand(ret);
                }
                throw new JSONParseError(src, "malformed prim expression: " + src);
            }
            else if ('string' in src) {
                if (typeof src.string === 'string') {
                    return { string: src.string };
                }
                throw new JSONParseError(src, "malformed string literal: " + src);
            }
            else if ('int' in src) {
                if (typeof src.int === 'string' && intRe.test(src.int)) {
                    return { int: src.int };
                }
                throw new JSONParseError(src, "malformed int literal: " + src);
            }
            else if ('bytes' in src) {
                if (typeof src.bytes === 'string' &&
                    bytesRe.test(src.bytes)) {
                    return { bytes: src.bytes };
                }
                throw new JSONParseError(src, "malformed bytes literal: " + src);
            }
            else {
                throw new JSONParseError(src, "unexpected object: " + src);
            }
        };
        return Parser;
    }());

    var Formatter = /** @class */ (function () {
        function Formatter(opt, lev) {
            if (lev === void 0) { lev = 0; }
            this.opt = opt;
            this.lev = lev;
        }
        Formatter.prototype.indent = function (n) {
            var _a;
            if (n === void 0) { n = 0; }
            var ret = "";
            if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.indent) !== undefined) {
                for (var i = this.lev + n; i > 0; i--) {
                    ret += this.opt.indent;
                }
            }
            return ret;
        };
        Object.defineProperty(Formatter.prototype, "lf", {
            get: function () {
                var _a;
                return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Formatter.prototype, "lfsp", {
            get: function () {
                var _a;
                return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || " ";
            },
            enumerable: false,
            configurable: true
        });
        Formatter.prototype.down = function (n) {
            return new Formatter(this.opt, this.lev + n);
        };
        return Formatter;
    }());
    function hasArgs(node) {
        return ("prim" in node) &&
            ((node.annots !== undefined && node.annots.length !== 0) ||
                (node.args !== undefined && node.args.length !== 0));
    }
    function isMultiline(node) {
        var e_1, _a;
        if (node.args !== undefined) {
            try {
                for (var _b = __values(node.args), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var a = _c.value;
                    if (Array.isArray(a) || hasArgs(a)) {
                        return true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return false;
    }
    function emitExpr(node, f) {
        var e_2, _a, e_3, _b;
        if (Array.isArray(node)) {
            return emitSeq(node, f);
        }
        else if ("string" in node) {
            return JSON.stringify(node.string);
        }
        else if ("int" in node) {
            return node.int;
        }
        else if ("bytes" in node) {
            return "0x" + node.bytes;
        }
        else {
            if ((node.annots === undefined || node.annots.length === 0) &&
                (node.args === undefined || node.args.length === 0)) {
                return node.prim;
            }
            var ret = "(" + node.prim;
            if (node.annots !== undefined) {
                try {
                    for (var _c = __values(node.annots), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var a = _d.value;
                        ret += " " + a;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (node.args !== undefined) {
                var multiline = isMultiline(node);
                try {
                    for (var _e = __values(node.args), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var a = _f.value;
                        if (multiline) {
                            ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1));
                        }
                        else {
                            ret += " " + emitExpr(a, f);
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            return ret + ")";
        }
    }
    function emitSeq(node, f) {
        var e_4, _a, e_5, _b, e_6, _c;
        var ret = "{" + f.lf;
        var i = node.length;
        try {
            for (var node_1 = __values(node), node_1_1 = node_1.next(); !node_1_1.done; node_1_1 = node_1.next()) {
                var el = node_1_1.value;
                ret += f.indent(1);
                if ("prim" in el) {
                    ret += el.prim;
                    if (el.annots !== undefined) {
                        try {
                            for (var _d = (e_5 = void 0, __values(el.annots)), _e = _d.next(); !_e.done; _e = _d.next()) {
                                var a = _e.value;
                                ret += " " + a;
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                    }
                    if (el.args !== undefined) {
                        var multiline = isMultiline(el);
                        try {
                            for (var _f = (e_6 = void 0, __values(el.args)), _g = _f.next(); !_g.done; _g = _f.next()) {
                                var a = _g.value;
                                if (multiline) {
                                    ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2));
                                }
                                else {
                                    ret += " " + emitExpr(a, f);
                                }
                            }
                        }
                        catch (e_6_1) { e_6 = { error: e_6_1 }; }
                        finally {
                            try {
                                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                            }
                            finally { if (e_6) throw e_6.error; }
                        }
                    }
                }
                else {
                    ret += emitExpr(el, f.down(1));
                }
                ret += (i > 1 ? ";" : "") + f.lf;
                i--;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (node_1_1 && !node_1_1.done && (_a = node_1.return)) _a.call(node_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return ret + f.indent() + "}";
    }
    /**
     * Formats Micheline expression
     * @param expr An AST node
     * @param opt Options
     */
    function emitMicheline(expr, opt) {
        // tslint:disable-next-line: strict-type-predicates
        if (typeof expr !== "object") {
            throw new TypeError("object type was expected, got " + typeof expr + " instead");
        }
        return emitExpr(expr, new Formatter(opt));
    }

    // Michelson types
    var ValidationError = /** @class */ (function (_super) {
        __extends(ValidationError, _super);
        /**
         * @param val Value of a node caused the error
         * @param path Path to a node caused the error in the AST tree
         * @param message An error message
         */
        function ValidationError(val, path, message) {
            var _this = _super.call(this, message) || this;
            _this.val = val;
            _this.path = path;
            return _this;
        }
        return ValidationError;
    }(Error));
    function isPrim(ex) {
        return "prim" in ex;
    }
    function assertPrim(ex, path) {
        if (isPrim(ex)) {
            return true;
        }
        throw new ValidationError(ex, path, "prim expression expected");
    }
    function assertSeq(ex, path) {
        if (Array.isArray(ex)) {
            return true;
        }
        throw new ValidationError(ex, path, "sequence expression expected");
    }
    function assertNatural(i, path) {
        if (i.int[0] === "-") {
            throw new ValidationError(i, path, "natural number expected");
        }
    }
    function assertIntLiteral(ex, path) {
        if ("int" in ex) {
            return true;
        }
        throw new ValidationError(ex, path, "int literal expected");
    }
    function assertArgs$1(ex, n, path) {
        var _a;
        if ((n === 0 && ex.args === undefined) || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {
            return true;
        }
        throw new ValidationError(ex, path, n + " arguments expected");
    }
    var unaryInstructionTable = {
        "DUP": true, "SWAP": true, "SOME": true, "UNIT": true, "PAIR": true, "CAR": true, "CDR": true,
        "CONS": true, "SIZE": true, "MEM": true, "GET": true, "UPDATE": true, "EXEC": true, "FAILWITH": true, "RENAME": true, "CONCAT": true, "SLICE": true,
        "PACK": true, "ADD": true, "SUB": true, "MUL": true, "EDIV": true, "ABS": true, "ISNAT": true, "INT": true, "NEG": true, "LSL": true, "LSR": true, "OR": true,
        "AND": true, "XOR": true, "NOT": true, "COMPARE": true, "EQ": true, "NEQ": true, "LT": true, "GT": true, "LE": true, "GE": true, "SELF": true,
        "TRANSFER_TOKENS": true, "SET_DELEGATE": true, "CREATE_ACCOUNT": true, "IMPLICIT_ACCOUNT": true, "NOW": true, "AMOUNT": true,
        "BALANCE": true, "CHECK_SIGNATURE": true, "BLAKE2B": true, "SHA256": true, "SHA512": true, "HASH_KEY": true, "STEPS_TO_QUOTA": true,
        "SOURCE": true, "SENDER": true, "ADDRESS": true, "CHAIN_ID": true,
    };
    var instructionTable = Object.assign({}, unaryInstructionTable, {
        "DROP": true, "DIG": true, "DUG": true, "NONE": true, "LEFT": true, "RIGHT": true, "NIL": true, "UNPACK": true, "CONTRACT": true, "CAST": true,
        "IF_NONE": true, "IF_LEFT": true, "IF_CONS": true, "IF": true, "MAP": true, "ITER": true, "LOOP": true, "LOOP_LEFT": true, "DIP": true,
        "CREATE_CONTRACT": true, "PUSH": true, "EMPTY_SET": true, "EMPTY_MAP": true, "EMPTY_BIG_MAP": true, "LAMBDA": true,
    });
    function assertMichelsonInstruction(ex, path) {
        var e_1, _a;
        var _b, _c;
        if (Array.isArray(ex)) {
            var i = 0;
            try {
                for (var ex_1 = __values(ex), ex_1_1 = ex_1.next(); !ex_1_1.done; ex_1_1 = ex_1.next()) {
                    var n = ex_1_1.value;
                    var p = __spread(path, [{ index: i, val: n }]);
                    if (!Array.isArray(n) && !isPrim(n)) {
                        throw new ValidationError(ex, p, "sequence or prim expected");
                    }
                    assertMichelsonInstruction(n, p);
                    i++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (ex_1_1 && !ex_1_1.done && (_a = ex_1.return)) _a.call(ex_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else if (Object.prototype.hasOwnProperty.call(unaryInstructionTable, ex.prim)) {
            assertArgs$1(ex, 0, path);
        }
        else {
            switch (ex.prim) {
                case "DROP":
                    if (ex.args !== undefined && assertArgs$1(ex, 1, path)) {
                        var p = __spread(path, [{ index: 0, val: ex.args[0] }]);
                        /* istanbul ignore else */
                        if (assertIntLiteral(ex.args[0], p)) {
                            assertNatural(ex.args[0], p);
                        }
                    }
                    break;
                case "DIG":
                case "DUG":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 1, path)) {
                        var p = __spread(path, [{ index: 0, val: ex.args[0] }]);
                        /* istanbul ignore else */
                        if (assertIntLiteral(ex.args[0], p)) {
                            assertNatural(ex.args[0], p);
                        }
                    }
                    break;
                case "NONE":
                case "LEFT":
                case "RIGHT":
                case "NIL":
                case "UNPACK":
                case "CONTRACT":
                case "CAST":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 1, path)) {
                        assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    }
                    break;
                case "IF_NONE":
                case "IF_LEFT":
                case "IF_CONS":
                case "IF":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 2, path)) {
                        var p0 = __spread(path, [{ index: 0, val: ex.args[0] }]);
                        /* istanbul ignore else */
                        if (assertSeq(ex.args[0], p0)) {
                            assertMichelsonInstruction(ex.args[0], p0);
                        }
                        var p1 = __spread(path, [{ index: 1, val: ex.args[1] }]);
                        /* istanbul ignore else */
                        if (assertSeq(ex.args[1], p1)) {
                            assertMichelsonInstruction(ex.args[1], p1);
                        }
                    }
                    break;
                case "MAP":
                case "ITER":
                case "LOOP":
                case "LOOP_LEFT":
                case "CREATE_CONTRACT":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 1, path)) {
                        var p = __spread(path, [{ index: 0, val: ex.args[0] }]);
                        /* istanbul ignore else */
                        if (assertSeq(ex.args[0], p)) {
                            assertMichelsonInstruction(ex.args[0], p);
                        }
                    }
                    break;
                case "DIP":
                    if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 2) {
                        var p0 = __spread(path, [{ index: 0, val: ex.args[0] }]);
                        /* istanbul ignore else */
                        if (assertIntLiteral(ex.args[0], p0)) {
                            assertNatural(ex.args[0], p0);
                        }
                        var p1 = __spread(path, [{ index: 1, val: ex.args[1] }]);
                        /* istanbul ignore else */
                        if (assertSeq(ex.args[1], p1)) {
                            assertMichelsonInstruction(ex.args[1], p1);
                        }
                    }
                    else if (((_c = ex.args) === null || _c === void 0 ? void 0 : _c.length) === 1) {
                        var p = __spread(path, [{ index: 0, val: ex.args[0] }]);
                        /* istanbul ignore else */
                        if (assertSeq(ex.args[0], p)) {
                            assertMichelsonInstruction(ex.args[0], p);
                        }
                    }
                    else {
                        throw new ValidationError(ex, path, "1 or 2 arguments expected");
                    }
                    break;
                case "PUSH":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 2, path)) {
                        assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                        assertMichelsonDataInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                    }
                    break;
                case "EMPTY_SET":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 1, path)) {
                        assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    }
                    break;
                case "EMPTY_MAP":
                case "EMPTY_BIG_MAP":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 2, path)) {
                        assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                        assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                    }
                    break;
                case "LAMBDA":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 3, path)) {
                        assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                        assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                        var p2 = __spread(path, [{ index: 2, val: ex.args[2] }]);
                        /* istanbul ignore else */
                        if (assertSeq(ex.args[2], p2)) {
                            assertMichelsonInstruction(ex.args[2], p2);
                        }
                    }
                    break;
                default:
                    throw new ValidationError(ex, path, "instruction expected");
            }
        }
        return true;
    }
    var simpleComparableTypeTable = {
        "int": true, "nat": true, "string": true, "bytes": true, "mutez": true,
        "bool": true, "key_hash": true, "timestamp": true, "address": true,
    };
    function assertMichelsonSimpleComparableType(ex, path) {
        /* istanbul ignore else */
        if (assertPrim(ex, path)) {
            if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {
                throw new ValidationError(ex, path, "simple comparable type expected");
            }
            assertArgs$1(ex, 0, path);
        }
        return true;
    }
    function assertMichelsonComparableType(ex, path) {
        /* istanbul ignore else */
        if (assertPrim(ex, path)) {
            if (Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {
                assertArgs$1(ex, 0, path);
            }
            else if (ex.prim === "pair") {
                /* istanbul ignore else */
                if (assertArgs$1(ex, 2, path)) {
                    assertMichelsonSimpleComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    assertMichelsonComparableType(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                }
            }
            else {
                throw new ValidationError(ex, path, "comparable type expected");
            }
        }
        return true;
    }
    function assertMichelsonTypeInternal(ex, path) {
        /* istanbul ignore else */
        if (assertPrim(ex, path)) {
            switch (ex.prim) {
                case "key":
                case "unit":
                case "signature":
                case "operation":
                case "chain_id":
                    assertArgs$1(ex, 0, path);
                    break;
                case "option":
                case "list":
                case "contract":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 1, path)) {
                        assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    }
                    break;
                case "pair":
                case "or":
                case "lambda":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 2, path)) {
                        assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                        assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                    }
                    break;
                case "set":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 1, path)) {
                        assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    }
                    break;
                case "map":
                case "big_map":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 2, path)) {
                        assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                        assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                    }
                    break;
                default:
                    assertMichelsonComparableType(ex, path);
            }
        }
        return true;
    }
    function assertMichelsonDataInternal(ex, path) {
        var e_2, _a;
        if (("int" in ex) || ("string" in ex) || ("bytes" in ex)) {
            return true;
        }
        if (Array.isArray(ex)) {
            var mapElts = 0;
            var i = 0;
            try {
                for (var ex_2 = __values(ex), ex_2_1 = ex_2.next(); !ex_2_1.done; ex_2_1 = ex_2.next()) {
                    var n = ex_2_1.value;
                    var p = __spread(path, [{ index: i, val: n }]);
                    if (isPrim(n) && n.prim === "Elt") {
                        /* istanbul ignore else */
                        if (assertArgs$1(n, 2, p)) {
                            assertMichelsonDataInternal(n.args[0], __spread(p, [{ index: 0, val: n.args[0] }]));
                            assertMichelsonDataInternal(n.args[1], __spread(p, [{ index: 1, val: n.args[1] }]));
                        }
                        mapElts++;
                    }
                    else {
                        assertMichelsonDataInternal(n, p);
                    }
                    i++;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (ex_2_1 && !ex_2_1.done && (_a = ex_2.return)) _a.call(ex_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (mapElts !== 0 && mapElts !== ex.length) {
                throw new ValidationError(ex, path, "data entries and map elements can't be intermixed");
            }
            return true;
        }
        if (isPrim(ex)) {
            switch (ex.prim) {
                case "Unit":
                case "True":
                case "False":
                case "None":
                    assertArgs$1(ex, 0, path);
                    break;
                case "Pair":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 2, path)) {
                        assertMichelsonDataInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                        assertMichelsonDataInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                    }
                    break;
                case "Left":
                case "Right":
                case "Some":
                    /* istanbul ignore else */
                    if (assertArgs$1(ex, 1, path)) {
                        assertMichelsonDataInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    }
                    break;
                default:
                    if (Object.prototype.hasOwnProperty.call(instructionTable, ex.prim)) {
                        assertMichelsonInstruction(ex, path);
                    }
                    else {
                        throw new ValidationError(ex, path, "data entry or instruction expected");
                    }
            }
        }
        else {
            throw new ValidationError(ex, path, "data entry expected");
        }
        return true;
    }
    function assertMichelsonScriptInternal(ex, path) {
        var e_3, _a;
        /* istanbul ignore else */
        if (assertSeq(ex, path) && ex.length === 3 &&
            assertPrim(ex[0], __spread(path, [{ index: 0, val: ex[0] }])) &&
            assertPrim(ex[1], __spread(path, [{ index: 1, val: ex[1] }])) &&
            assertPrim(ex[2], __spread(path, [{ index: 2, val: ex[2] }]))) {
            var p = [ex[0].prim, ex[1].prim, ex[2].prim].sort();
            if (p[0] === "code" && p[1] === "parameter" && p[2] === "storage") {
                var i = 0;
                try {
                    for (var _b = __values(ex), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var n = _c.value;
                        var p_1 = __spread(path, [{ index: i, val: n }]);
                        /* istanbul ignore else */
                        if (assertArgs$1(n, 1, p_1)) {
                            var pp = __spread(p_1, [{ index: 0, val: n.args[0] }]);
                            switch (n.prim) {
                                case "code":
                                    /* istanbul ignore else */
                                    if (assertSeq(n.args[0], pp)) {
                                        assertMichelsonInstruction(n.args[0], pp);
                                    }
                                    break;
                                case "parameter":
                                case "storage":
                                    assertMichelsonTypeInternal(n.args[0], pp);
                            }
                        }
                        i++;
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            else {
                throw new ValidationError(ex, path, "valid Michelson script expected");
            }
        }
        return true;
    }
    /**
     * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.
     * This is a type guard function which either returns true of throws an exception.
     * @param ex An AST node
     */
    function assertMichelsonScript(ex) {
        return assertMichelsonScriptInternal(ex, []);
    }
    /**
     * Checks if the node is a valid Michelson data literal such as `(Pair {Elt "0" 0} 0)`.
     * This is a type guard function which either returns true of throws an exception.
     * @param ex An AST node
     */
    function assertMichelsonData(ex) {
        return assertMichelsonDataInternal(ex, []);
    }
    /**
     * Checks if the node is a valid Michelson code (sequence of instructions).
     * This is a type guard function which either returns true of throws an exception.
     * @param ex An AST node
     */
    function assertMichelsonCode(ex) {
        return assertMichelsonInstruction(ex, []);
    }
    /**
     * Checks if the node is a valid Michelson type expression.
     * This is a type guard function which either returns true of throws an exception.
     * @param ex An AST node
     */
    function assertMichelsonType(ex) {
        return assertMichelsonTypeInternal(ex, []);
    }

    exports.JSONParseError = JSONParseError;
    exports.MacroError = MacroError;
    exports.MichelineParseError = MichelineParseError;
    exports.Parser = Parser;
    exports.ValidationError = ValidationError;
    exports.assertMichelsonCode = assertMichelsonCode;
    exports.assertMichelsonData = assertMichelsonData;
    exports.assertMichelsonScript = assertMichelsonScript;
    exports.assertMichelsonType = assertMichelsonType;
    exports.emitMicheline = emitMicheline;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=taquito-michel-codec.umd.js.map
