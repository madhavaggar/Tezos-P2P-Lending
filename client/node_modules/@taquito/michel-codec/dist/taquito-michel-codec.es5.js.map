{"version":3,"file":"taquito-michel-codec.es5.js","sources":["../src/scan.ts","../src/macros.ts","../src/micheline-parser.ts","../src/micheline-emitter.ts","../src/michelson-validator.ts"],"sourcesContent":["export class ScanError extends Error {\n    constructor(public src: string, public idx: number, message?: string) {\n        super(message);\n    }\n}\n\nexport enum Literal {\n    Comment,\n    Number,\n    String,\n    Bytes,\n    Ident,\n}\n\nexport type TokenType = \"(\" | \")\" | \"{\" | \"}\" | \";\" | Literal;\n\nconst isSpace = new RegExp(\"\\\\s\");\nconst isIdentStart = new RegExp(\"[:@%_A-Za-z]\");\nconst isIdent = new RegExp(\"[@%_\\\\.A-Za-z0-9]\");\nconst isDigit = new RegExp(\"[0-9]\");\nconst isHex = new RegExp(\"[0-9a-fA-F]\");\n\nexport interface Token {\n    t: TokenType;\n    v: string;\n    offset: number;\n}\n\nexport function* scan(src: string, scanComments = false): Generator<Token, void> {\n    let i = 0;\n    while (i < src.length) {\n        // Skip space\n        while (i < src.length && isSpace.test(src[i])) {\n            i++;\n        }\n        if (i === src.length) {\n            return;\n        }\n\n        const s = src[i];\n        const start = i;\n        if (isIdentStart.test(s)) {\n            // Identifier\n            i++;\n            while (i < src.length && isIdent.test(src[i])) {\n                i++;\n            }\n            yield { t: Literal.Ident, v: src.slice(start, i), offset: i };\n        } else if (src.length - i > 1 && src.substr(i, 2) === \"0x\") {\n            // Bytes\n            i += 2;\n            while (i < src.length && isHex.test(src[i])) {\n                i++;\n            }\n            if (i - start === 2) {\n                throw new ScanError(src, i, \"Bytes literal is too short\");\n            } else if (((i - start) & 1) !== 0) {\n                throw new ScanError(src, i, \"Bytes literal length is expected to be power of two\");\n            }\n            yield { t: Literal.Bytes, v: src.slice(start, i), offset: i };\n        } else if (isDigit.test(s) || s === \"-\") {\n            // Number\n            if (s === \"-\") {\n                i++;\n            }\n            const ii = i;\n            while (i < src.length && isDigit.test(src[i])) {\n                i++;\n            }\n            if (ii === i) {\n                throw new ScanError(src, i, \"Number literal is too short\");\n            }\n            yield { t: Literal.Number, v: src.slice(start, i), offset: i };\n        } else if (s === \"\\\"\") {\n            // String\n            i++;\n            let esc = false;\n            for (; i < src.length && (esc || src[i] !== \"\\\"\"); i++) {\n                if (!esc && src[i] === \"\\\\\") {\n                    esc = true;\n                } else {\n                    esc = false;\n                }\n            }\n            if (i === src.length) {\n                throw new ScanError(src, i, \"Unterminated string literal\");\n            }\n            i++;\n            yield { t: Literal.String, v: src.slice(start, i), offset: i };\n        } else if (s === \"#\") {\n            // Comment\n            i++;\n            while (i < src.length && src[i] !== \"\\n\") {\n                i++;\n            }\n            if (scanComments) {\n                yield { t: Literal.Comment, v: src.slice(start, i), offset: i };\n            }\n        } else if (s === \"(\" || s === \")\" || s === \"{\" || s === \"}\" || s === \";\") {\n            i++;\n            yield { t: s, v: s, offset: i };\n        } else {\n            throw new ScanError(src, i, `Invalid character at offset ${i}: \\`${s}'`);\n        }\n    }\n}","import { Prim, Expr, IntLiteral } from \"./micheline\";\nimport { Tuple, NoArgs, ReqArgs, NoAnnots } from \"./utils\";\n\nexport class MacroError extends Error {\n    constructor(public prim: Prim, message?: string) {\n        super(message);\n    }\n}\n\nfunction assertArgs<N extends number>(ex: Prim, n: N):\n    ex is N extends 0 ?\n    NoArgs<Prim<string>> :\n    ReqArgs<Prim<string, Tuple<Expr, N>>> {\n    if ((n === 0 && ex.args === undefined) || ex.args?.length === n) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects ${n} arguments, was given ${ex.args?.length}`);\n}\n\nfunction assertNoAnnots(ex: Prim): ex is NoAnnots<Prim> {\n    if (ex.annots === undefined) {\n        return true;\n    }\n    throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${ex.annots}`);\n}\n\nfunction assertIntArg(ex: Prim, arg: Expr): arg is IntLiteral {\n    if (\"int\" in arg) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects int argument`);\n}\n\ntype PT = [number, [string | null, string | null]];\n\nfunction parsePairUnpairExpr(p: Prim, expr: string, annotations: string[], agg: (a: PT[], v: PT) => PT[]): { r: PT[], n: number, an: number } {\n    const res: PT[] = [];\n    let i = 0;\n    let ai = 0;\n    const ann: [string | null, string | null] = [null, null];\n\n    // Left expression\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    let c = expr[i++];\n    switch (c) {\n        case \"P\":\n            const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n            res.push(...r);\n            i += n;\n            ai += an;\n            break;\n        case \"A\":\n            if (ai !== annotations.length) {\n                ann[0] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n\n    // Right expression\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    c = expr[i++];\n    switch (c) {\n        case \"P\":\n            const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n            res.push(...r.map<PT>(([v, a]) => [v + 1, a]));\n            i += n;\n            ai += an;\n            break;\n        case \"I\":\n            if (ai !== annotations.length) {\n                ann[1] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n\n    return { r: agg(res, [0, ann]), n: i, an: ai };\n}\n\nfunction parseSetMapCadr(p: Prim, expr: string, vann: string[], term: { a: Expr, d: Expr }): Expr {\n    const c = expr[0];\n    switch (c) {\n        case \"A\":\n            return expr.length > 1 ?\n                [\n                    { prim: \"DUP\" },\n                    {\n                        prim: \"DIP\",\n                        args: [[\n                            { prim: \"CAR\", annots: [\"@%%\"] },\n                            parseSetMapCadr(p, expr.slice(1), [], term),\n                        ]],\n                    },\n                    { prim: \"CDR\", annots: [\"@%%\"] },\n                    { prim: \"SWAP\" },\n                    { prim: \"PAIR\", annots: [\"%@\", \"%@\", ...vann] },\n                ] : term.a;\n\n        case \"D\":\n            return expr.length > 1 ?\n                [\n                    { prim: \"DUP\" },\n                    {\n                        prim: \"DIP\",\n                        args: [[\n                            { prim: \"CDR\", annots: [\"@%%\"] },\n                            parseSetMapCadr(p, expr.slice(1), [], term),\n                        ]],\n                    },\n                    { prim: \"CAR\", annots: [\"@%%\"] },\n                    { prim: \"PAIR\", annots: [\"%@\", \"%@\", ...vann] },\n                ] : term.d;\n\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n}\n\nfunction trimLast<T>(a: T[], v: T): T[] {\n    let l = a.length;\n    while (l > 0 && a[l - 1] === v) {\n        l--;\n    }\n    return a.slice(0, l);\n}\n\nfunction filterAnnotations(a?: string[]): {\n    fields: string[];\n    rest: string[];\n} {\n    const fields: string[] = [];\n    const rest: string[] = [];\n    if (a !== undefined) {\n        for (const v of a) {\n            (v.length !== 0 && v[0] === \"%\" ? fields : rest).push(v);\n        }\n    }\n    return { fields, rest };\n}\n\nfunction mkPrim({ prim, annots, args }: Prim): Prim {\n    return {\n        prim,\n        ...(annots && { annots }),\n        ...(args && { args }),\n    };\n}\n\nconst pairRe = /^P[PAI]{3,}R$/;\nconst unpairRe = /^UNP[PAI]{2,}R$/;\nconst cadrRe = /^C[AD]{2,}R$/;\nconst setCadrRe = /^SET_C[AD]+R$/;\nconst mapCadrRe = /^MAP_C[AD]+R$/;\nconst diipRe = /^DI{2,}P$/;\nconst duupRe = /^DU+P$/;\n\nexport function expandMacros(ex: Prim): Expr {\n    function mayRename(annots?: string[]): Prim[] {\n        return annots !== undefined ? [{ prim: \"RENAME\", annots }] : [];\n    }\n\n    switch (ex.prim) {\n        // Compare\n        case \"CMPEQ\":\n        case \"CMPNEQ\":\n        case \"CMPLT\":\n        case \"CMPGT\":\n        case \"CMPLE\":\n        case \"CMPGE\":\n            if (assertArgs(ex, 0)) {\n                return [\n                    { prim: \"COMPARE\" },\n                    mkPrim({ prim: ex.prim.slice(3), annots: ex.annots }),\n                ];\n            }\n            break;\n\n        case \"IFEQ\":\n        case \"IFNEQ\":\n        case \"IFLT\":\n        case \"IFGT\":\n        case \"IFLE\":\n        case \"IFGE\":\n            if (assertArgs(ex, 2)) {\n                return [\n                    { prim: ex.prim.slice(2) },\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\n                ];\n            }\n            break;\n\n        case \"IFCMPEQ\":\n        case \"IFCMPNEQ\":\n        case \"IFCMPLT\":\n        case \"IFCMPGT\":\n        case \"IFCMPLE\":\n        case \"IFCMPGE\":\n            if (assertArgs(ex, 2)) {\n                return [\n                    { prim: \"COMPARE\" },\n                    { prim: ex.prim.slice(5) },\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\n                ];\n            }\n            break;\n\n        // Fail\n        case \"FAIL\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    { prim: \"UNIT\" },\n                    { prim: \"FAILWITH\" },\n                ];\n            }\n            break;\n\n        // Assertion macros\n        case \"ASSERT\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [{\n                    prim: \"IF\", args: [\n                        [],\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_EQ\":\n        case \"ASSERT_NEQ\":\n        case \"ASSERT_LT\":\n        case \"ASSERT_GT\":\n        case \"ASSERT_LE\":\n        case \"ASSERT_GE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    { prim: ex.prim.slice(7) },\n                    {\n                        prim: \"IF\", args: [\n                            [],\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        ]\n                    },\n                ];\n            }\n            break;\n\n        case \"ASSERT_CMPEQ\":\n        case \"ASSERT_CMPNEQ\":\n        case \"ASSERT_CMPLT\":\n        case \"ASSERT_CMPGT\":\n        case \"ASSERT_CMPLE\":\n        case \"ASSERT_CMPGE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    [\n                        { prim: \"COMPARE\" },\n                        { prim: ex.prim.slice(10) },\n                    ],\n                    {\n                        prim: \"IF\", args: [\n                            [],\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        ]\n                    },\n                ];\n            }\n            break;\n\n        case \"ASSERT_NONE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [{\n                    prim: \"IF_NONE\", args: [\n                        [],\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_SOME\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_NONE\", args: [\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        mayRename(ex.annots),\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_LEFT\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_LEFT\", args: [\n                        mayRename(ex.annots),\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_RIGHT\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_LEFT\", args: [\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        mayRename(ex.annots),\n                    ]\n                }];\n            }\n            break;\n\n        // Syntactic conveniences\n\n        case \"IF_SOME\":\n            if (assertArgs(ex, 2)) {\n                return [mkPrim({ prim: \"IF_NONE\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\n            }\n            break;\n\n        case \"IF_RIGHT\":\n            if (assertArgs(ex, 2)) {\n                return [mkPrim({ prim: \"IF_LEFT\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\n            }\n    }\n\n    // More syntactic conveniences\n\n    // PAPPAIIR macro\n    if (pairRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, (a, v) => [...a, v]);\n\n            return r.map(([v, a], i) => {\n                const ann = [\n                    ...trimLast(a, null).map(v => v === null ? \"%\" : v),\n                    ...((v === 0 && i === r.length - 1) ? rest : [])];\n\n                const leaf = mkPrim({ prim: \"PAIR\", annots: ann.length !== 0 ? ann : undefined, });\n\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\n                };\n            });\n        }\n    }\n\n    // UNPAPPAIIR macro\n    if (unpairRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], (a, v) => [v, ...a]);\n\n            return r.map(([v, a]) => {\n                const leaf: Prim[] = [\n                    { prim: \"DUP\" },\n                    mkPrim({ prim: \"CAR\", annots: a[0] !== null ? [a[0]] : undefined }),\n                    {\n                        prim: \"DIP\",\n                        args: [[mkPrim({ prim: \"CDR\", annots: a[1] !== null ? [a[1]] : undefined })]],\n                    }\n                ];\n\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\n                };\n            });\n        }\n    }\n\n    // C[AD]+R macro\n    if (cadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const ch = [...ex.prim.slice(1, ex.prim.length - 1)];\n\n            return ch.map<Prim>((c, i) => {\n                const ann = i === ch.length - 1 ? ex.annots : undefined;\n                switch (c) {\n                    case \"A\":\n                        return mkPrim({ prim: \"CAR\", annots: ann });\n                    case \"D\":\n                        return mkPrim({ prim: \"CDR\", annots: ann });\n                    default:\n                        throw new MacroError(ex, `unexpected character: ${c}`);\n                }\n            });\n        }\n    }\n\n    // SET_C[AD]+R macro\n    if (setCadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n\n            const term = fields.length !== 0 ?\n                {\n                    a: [\n                        { prim: \"DUP\" },\n                        { prim: \"CAR\", annots: fields },\n                        { prim: \"DROP\" },\n                        { prim: \"CDR\", annots: [\"@%%\"] },\n                        { prim: \"SWAP\" },\n                        { prim: \"PAIR\", annots: [fields[0], \"%@\"] },\n                    ],\n                    d: [\n                        { prim: \"DUP\" },\n                        { prim: \"CDR\", annots: fields },\n                        { prim: \"DROP\" },\n                        { prim: \"CAR\", annots: [\"@%%\"] },\n                        { prim: \"PAIR\", annots: [\"%@\", fields[0]] },\n                    ],\n                } :\n                {\n                    a: [\n                        { prim: \"CDR\", annots: [\"@%%\"] },\n                        { prim: \"SWAP\" },\n                        { prim: \"PAIR\", annots: [\"%\", \"%@\"] },\n                    ],\n                    d: [\n                        { prim: \"CAR\", annots: [\"@%%\"] },\n                        { prim: \"PAIR\", annots: [\"%@\", \"%\"] },\n                    ],\n                };\n\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);\n        }\n    }\n\n    // MAP_C[AD]+R macro\n    if (mapCadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 1)) {\n            const { fields } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n\n            const term = {\n                a: [\n                    { prim: \"DUP\" },\n                    { prim: \"CDR\", annots: [\"@%%\"] },\n                    {\n                        prim: \"DIP\", args: [[\n                            mkPrim({ prim: \"CAR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\n                            ex.args[0],\n                        ]]\n                    },\n                    { prim: \"SWAP\" },\n                    { prim: \"PAIR\", annots: [fields.length !== 0 ? fields[0] : \"%\", \"%@\"] },\n                ],\n                d: [\n                    { prim: \"DUP\" },\n                    mkPrim({ prim: \"CDR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\n                    ex.args[0],\n                    { prim: \"SWAP\" },\n                    { prim: \"CAR\", annots: [\"@%%\"] },\n                    { prim: \"PAIR\", annots: [\"%@\", fields.length !== 0 ? fields[0] : \"%\"] },\n                ],\n            };\n\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);\n        }\n    }\n\n    // Expand deprecated DI...IP to [DIP n]\n    if (diipRe.test(ex.prim)) {\n        if (assertArgs(ex, 1)) {\n            let n = 0;\n            while (ex.prim[1 + n] === \"I\") { n++ }\n            return mkPrim({ prim: \"DIP\", args: [{ int: String(n) }, ex.args[0]] });\n        }\n    }\n\n    // Expand modern DUP n or deprecated DU...UP\n    if (duupRe.test(ex.prim)) {\n        let n = 0;\n        while (ex.prim[1 + n] === \"U\") { n++ }\n\n        if (n === 1) {\n            if (ex.args === undefined) {\n                return ex; // skip\n            }\n            if (assertArgs(ex, 1) && assertIntArg(ex, ex.args[0])) {\n                n = parseInt(ex.args[0].int, 10);\n            }\n        } else {\n            assertArgs(ex, 0);\n        }\n\n        if (n === 1) {\n            return [mkPrim({ prim: \"DUP\", annots: ex.annots })];\n\n        } else if (n === 2) {\n            return [\n                {\n                    prim: \"DIP\",\n                    args: [[mkPrim({ prim: \"DUP\", annots: ex.annots })]],\n                },\n                { prim: \"SWAP\" },\n            ];\n\n        } else {\n            return [\n                {\n                    prim: \"DIP\",\n                    args: [\n                        { int: String(n - 1) },\n                        [mkPrim({ prim: \"DUP\", annots: ex.annots })],\n                    ],\n                },\n                {\n                    prim: \"DIG\",\n                    args: [{ int: String(n) }],\n                },\n            ];\n        }\n\n    }\n\n    return ex;\n}","import { scan, Token, Literal } from './scan';\nimport { Expr, Prim, StringLiteral, IntLiteral, BytesLiteral } from './micheline';\nimport { expandMacros } from './macros';\n\nexport class MichelineParseError extends Error {\n    /**\n     * @param token A token caused the error\n     * @param message An error message\n     */\n    constructor(public token: Token | null, message?: string) {\n        super(message);\n    }\n}\n\nexport class JSONParseError extends Error {\n    /**\n     * @param node A node caused the error\n     * @param message An error message\n     */\n    constructor(public node: any, message?: string) {\n        super(message);\n    }\n}\n\nconst errEOF = new MichelineParseError(null, 'Unexpected EOF');\n\nfunction isAnnotation(tok: Token): boolean {\n    return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');\n}\n\nconst intRe = new RegExp('^-?[0-9]+$');\nconst bytesRe = new RegExp('^([0-9a-fA-F]{2})+$');\n\nexport interface ParserOptions {\n    /**\n     * Expand [Michelson macros](https://tezos.gitlab.io/whitedoc/michelson.html#macros) during parsing.\n     */\n    expandMacros: boolean;\n}\n\n/**\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\n *\n * Pretty Print a Michelson Smart Contract:\n * ```\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\n * const p = new Parser();\n *\n * const michelsonCode = p.parseJSON(contract.script.code);\n * const storage = p.parseJSON(contract.script.storage);\n *\n * console.log(\"Pretty print Michelson smart contract:\");\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\n *\n * console.log(\"Pretty print Storage:\");\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\n * ```\n *\n * Encode a Michelson expression for inital storage of a smart contract\n * ```\n * const src = `(Pair (Pair { Elt 1\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\n *                      0x0501000000026869) }\n *          10000000)\n *    (Pair 2 333))`;\n *\n * const p = new Parser();\n *\n * const exp = p.parseMichelineExpression(src);\n * console.log(JSON.stringify(exp));\n * ```\n */\nexport class Parser {\n    constructor(private opt?: ParserOptions) { }\n\n    private expand(ex: Prim): Expr {\n        return this.opt?.expandMacros ? expandMacros(ex) : ex;\n    }\n\n    private parseList(scanner: Iterator<Token>): Expr {\n        const tok = scanner.next();\n        if (tok.done) {\n            throw errEOF;\n        }\n\n        if (tok.value.t !== Literal.Ident) {\n            throw new MichelineParseError(tok.value, `List: not an identifier: ${tok.value.v}`);\n        }\n\n        const ret: Prim = {\n            prim: tok.value.v,\n        };\n\n        for (; ;) {\n            const tok = scanner.next();\n            if (tok.done) {\n                throw errEOF;\n            }\n            if (tok.value.t === ')') {\n                break;\n            }\n            if (isAnnotation(tok.value)) {\n                ret.annots = ret.annots || [];\n                ret.annots.push(tok.value.v);\n            } else {\n                ret.args = ret.args || [];\n                ret.args.push(this.parseExpr(scanner, tok.value));\n            }\n        }\n        return this.expand(ret);\n    }\n\n    private parseArgs(\n        scanner: Iterator<Token>,\n        prim: string,\n        expectBracket: boolean\n    ): [Prim, boolean] {\n        // Identifier with arguments\n        const p: Prim = { prim };\n\n        for (; ;) {\n            const t = scanner.next();\n            if (t.done) {\n                if (expectBracket) {\n                    throw errEOF;\n                } else {\n                    return [p, true];\n                }\n            } else if (t.value.t === '}') {\n                if (!expectBracket) {\n                    throw new MichelineParseError(t.value, `Seq: unexpected token: ${t.value.v}`);\n                } else {\n                    return [p, true];\n                }\n            } else if (t.value.t === ';') {\n                return [p, false];\n            }\n\n            if (isAnnotation(t.value)) {\n                p.annots = p.annots || [];\n                p.annots.push(t.value.v);\n            } else {\n                p.args = p.args || [];\n                p.args.push(this.parseExpr(scanner, t.value));\n            }\n        }\n    }\n\n    private parseSequence(\n        scanner: Iterator<Token>,\n        initialToken: Token | null,\n        expectBracket: boolean\n    ): Expr[] {\n        const seq: Expr[] = [];\n        for (; ;) {\n            let tok: Token;\n            if (initialToken !== null) {\n                tok = initialToken;\n                initialToken = null;\n            } else {\n                const t = scanner.next();\n                if (t.done) {\n                    if (expectBracket) {\n                        throw errEOF;\n                    } else {\n                        return seq;\n                    }\n                }\n                tok = t.value;\n            }\n\n            if (tok.t === '}') {\n                if (!expectBracket) {\n                    throw new MichelineParseError(tok, `Seq: unexpected token: ${tok.v}`);\n                } else {\n                    return seq;\n                }\n            } else if (tok.t === Literal.Ident) {\n                // Identifier with arguments\n                const [itm, done] = this.parseArgs(scanner, tok.v, expectBracket);\n                seq.push(this.expand(itm));\n                if (done) {\n                    return seq;\n                }\n            } else {\n                // Other\n                seq.push(this.parseExpr(scanner, tok));\n\n                const t = scanner.next();\n                if (t.done) {\n                    if (expectBracket) {\n                        throw errEOF;\n                    } else {\n                        return seq;\n                    }\n                } else if (t.value.t === '}') {\n                    if (!expectBracket) {\n                        throw new MichelineParseError(t.value, `Seq: unexpected token: ${t.value.v}`);\n                    } else {\n                        return seq;\n                    }\n                } else if (t.value.t !== ';') {\n                    throw new MichelineParseError(t.value, `Seq: unexpected token: ${t.value.v}`);\n                }\n            }\n        }\n    }\n\n    private parseExpr(scanner: Iterator<Token>, tok: Token): Expr {\n        switch (tok.t) {\n            case Literal.Ident:\n                return this.expand({ prim: tok.v });\n\n            case Literal.Number:\n                return { int: tok.v };\n\n            case Literal.String:\n                return { string: JSON.parse(tok.v) as string };\n\n            case Literal.Bytes:\n                return { bytes: tok.v.substr(2) };\n\n            case '(':\n                return this.parseList(scanner);\n\n            case '{':\n                return this.parseSequence(scanner, null, true);\n\n            default:\n                throw new MichelineParseError(tok, `Expr: unexpected token: ${tok.v}`);\n        }\n    }\n\n    /**\n     * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\n     */\n    parseScript(src: string): Expr[] | null {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n\n        return tok.value.t === '{'\n            ? this.parseSequence(scanner, null, true)\n            : this.parseSequence(scanner, tok.value, false);\n    }\n\n    /**\n     * Parse any Michelson expression\n     * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\n     * @returns An AST node or null for empty document.\n     */\n    parseMichelineExpression(src: string): Expr | null {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n        return this.parseExpr(scanner, tok.value);\n    }\n\n    /**\n     * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\n     * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\n     */\n    parseJSON(src: object): Expr {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"object\") {\n            throw new TypeError(`object type was expected, got ${typeof src} instead`);\n        }\n\n        if (Array.isArray(src)) {\n            const ret: Expr[] = [];\n            for (const n of src) {\n                if (n === null || typeof n !== 'object') {\n                    throw new JSONParseError(n, `unexpected sequence element: ${n}`);\n                }\n                ret.push(this.parseJSON(n));\n            }\n            return ret;\n\n        } else if ('prim' in src) {\n            const p = src as { prim: any, annots?: any[], args?: any[] };\n            if (\n                typeof p.prim === 'string' &&\n                (p.annots === undefined || Array.isArray(p.annots)) &&\n                (p.args === undefined || Array.isArray(p.args))\n            ) {\n                const ret: Prim = {\n                    prim: p.prim,\n                };\n\n                if (p.annots !== undefined) {\n                    for (const a of p.annots) {\n                        if (typeof a !== 'string') {\n                            throw new JSONParseError(a, `string expected: ${a}`);\n                        }\n                    }\n                    ret.annots = p.annots;\n                }\n\n                if (p.args !== undefined) {\n                    ret.args = [];\n                    for (const a of p.args) {\n                        if (a === null || typeof a !== 'object') {\n                            throw new JSONParseError(a, `unexpected argument: ${a}`);\n                        }\n                        ret.args.push(this.parseJSON(a));\n                    }\n                }\n\n                return this.expand(ret);\n            }\n\n            throw new JSONParseError(src, `malformed prim expression: ${src}`);\n        } else if ('string' in src) {\n            if (typeof (src as any).string === 'string') {\n                return { string: (src as StringLiteral).string };\n            }\n\n            throw new JSONParseError(src, `malformed string literal: ${src}`);\n        } else if ('int' in src) {\n            if (typeof (src as any).int === 'string' && intRe.test((src as IntLiteral).int)) {\n                return { int: (src as IntLiteral).int };\n            }\n\n            throw new JSONParseError(src, `malformed int literal: ${src}`);\n        } else if ('bytes' in src) {\n            if (\n                typeof (src as any).bytes === 'string' &&\n                bytesRe.test((src as BytesLiteral).bytes)\n            ) {\n                return { bytes: (src as BytesLiteral).bytes };\n            }\n\n            throw new JSONParseError(src, `malformed bytes literal: ${src}`);\n        } else {\n            throw new JSONParseError(src, `unexpected object: ${src}`);\n        }\n    }\n}\n","import { Expr, Prim } from \"./micheline\";\n\nexport interface FormatOptions {\n    /**\n     * A string used for code indentation if desired. Usually a tab character or a number of spaces.\n     */\n    indent?: string;\n    /**\n     * A string used for line separation. Usually a newline character (\"\\n\");\n     */\n    newline?: string;\n}\n\nclass Formatter {\n    constructor(private opt?: FormatOptions, private lev: number = 0) {\n    }\n\n    indent(n = 0): string {\n        let ret = \"\";\n        if (this.opt?.indent !== undefined) {\n            for (let i = this.lev + n; i > 0; i--) {\n                ret += this.opt.indent;\n            }\n        }\n        return ret;\n    }\n\n    get lf(): string {\n        return this.opt?.newline || \"\";\n    }\n\n    get lfsp(): string {\n        return this.opt?.newline || \" \";\n    }\n\n    down(n: number): Formatter {\n        return new Formatter(this.opt, this.lev + n);\n    }\n}\n\nfunction hasArgs(node: Expr): node is Prim {\n    return (\"prim\" in node) &&\n        ((node.annots !== undefined && node.annots.length !== 0) ||\n            (node.args !== undefined && node.args.length !== 0));\n}\n\nfunction isMultiline(node: Prim): boolean {\n    if (node.args !== undefined) {\n        for (const a of node.args) {\n            if (Array.isArray(a) || hasArgs(a)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction emitExpr(node: Expr, f: Formatter): string {\n    if (Array.isArray(node)) {\n        return emitSeq(node, f);\n\n    } else if (\"string\" in node) {\n        return JSON.stringify(node.string);\n\n    } else if (\"int\" in node) {\n        return node.int;\n\n    } else if (\"bytes\" in node) {\n        return \"0x\" + node.bytes;\n\n    } else {\n        if ((node.annots === undefined || node.annots.length === 0) &&\n            (node.args === undefined || node.args.length === 0)) {\n            return node.prim;\n        }\n\n        let ret = \"(\" + node.prim;\n        if (node.annots !== undefined) {\n            for (const a of node.annots) {\n                ret += \" \" + a;\n            }\n        }\n        if (node.args !== undefined) {\n            const multiline = isMultiline(node);\n            for (const a of node.args) {\n                if (multiline) {\n                    ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1));\n                } else {\n                    ret += \" \" + emitExpr(a, f);\n                }\n            }\n        }\n        return ret + \")\";\n    }\n}\n\nfunction emitSeq(node: Expr[], f: Formatter): string {\n    let ret = \"{\" + f.lf;\n    let i = node.length;\n    for (const el of node) {\n        ret += f.indent(1);\n\n        if (\"prim\" in el) {\n            ret += el.prim;\n\n            if (el.annots !== undefined) {\n                for (const a of el.annots) {\n                    ret += \" \" + a;\n                }\n            }\n            if (el.args !== undefined) {\n                const multiline = isMultiline(el);\n                for (const a of el.args) {\n                    if (multiline) {\n                        ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2));\n                    } else {\n                        ret += \" \" + emitExpr(a, f);\n                    }\n                }\n            }\n        } else {\n            ret += emitExpr(el, f.down(1));\n        }\n\n        ret += (i > 1 ? \";\" : \"\") + f.lf;\n        i--;\n    }\n    return ret + f.indent() + \"}\";\n}\n\n/**\n * Formats Micheline expression\n * @param expr An AST node\n * @param opt Options\n */\nexport function emitMicheline(expr: Expr, opt?: FormatOptions): string {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof expr !== \"object\") {\n        throw new TypeError(`object type was expected, got ${typeof expr} instead`);\n    }\n\n    return emitExpr(expr, new Formatter(opt));\n}","// Michelson types\n\nimport { Prim, Expr, IntLiteral, StringLiteral, BytesLiteral } from \"./micheline\";\nimport { Tuple, NoArgs, ReqArgs } from \"./utils\";\n\n// Instructions\n\nexport type MichelsonUnaryInstructionId = \"DUP\" | \"SWAP\" | \"SOME\" | \"UNIT\" | \"PAIR\" | \"CAR\" | \"CDR\" |\n   \"CONS\" | \"SIZE\" | \"MEM\" | \"GET\" | \"UPDATE\" | \"EXEC\" | \"FAILWITH\" | \"RENAME\" | \"CONCAT\" | \"SLICE\" |\n   \"PACK\" | \"ADD\" | \"SUB\" | \"MUL\" | \"EDIV\" | \"ABS\" | \"ISNAT\" | \"INT\" | \"NEG\" | \"LSL\" | \"LSR\" | \"OR\" |\n   \"AND\" | \"XOR\" | \"NOT\" | \"COMPARE\" | \"EQ\" | \"NEQ\" | \"LT\" | \"GT\" | \"LE\" | \"GE\" | \"SELF\" |\n   \"TRANSFER_TOKENS\" | \"SET_DELEGATE\" | \"CREATE_ACCOUNT\" | \"IMPLICIT_ACCOUNT\" | \"NOW\" | \"AMOUNT\" |\n   \"BALANCE\" | \"CHECK_SIGNATURE\" | \"BLAKE2B\" | \"SHA256\" | \"SHA512\" | \"HASH_KEY\" | \"STEPS_TO_QUOTA\" |\n   \"SOURCE\" | \"SENDER\" | \"ADDRESS\" | \"CHAIN_ID\";\n\nexport type MichelsonInstructionId = MichelsonUnaryInstructionId |\n   \"DROP\" | \"DIG\" | \"DUG\" | \"NONE\" | \"LEFT\" | \"RIGHT\" | \"NIL\" | \"UNPACK\" | \"CONTRACT\" | \"CAST\" |\n   \"IF_NONE\" | \"IF_LEFT\" | \"IF_CONS\" | \"IF\" | \"MAP\" | \"ITER\" | \"LOOP\" | \"LOOP_LEFT\" | \"DIP\" |\n   \"CREATE_CONTRACT\" | \"PUSH\" | \"EMPTY_SET\" | \"EMPTY_MAP\" | \"EMPTY_BIG_MAP\" | \"LAMBDA\";\n\ntype InstrPrim<PT extends MichelsonInstructionId, AT extends Expr[] = never> = Prim<PT, AT>;\n\nexport type MichelsonInstruction = MichelsonInstruction[] |\n   NoArgs<InstrPrim<MichelsonUnaryInstructionId>> |\n   ReqArgs<InstrPrim<\"DIG\" | \"DUG\", [IntLiteral]>> |\n   InstrPrim<\"DROP\", [IntLiteral]> | // Keep optional argument\n   ReqArgs<InstrPrim<\"NONE\" | \"LEFT\" | \"RIGHT\" | \"NIL\" | \"UNPACK\" | \"CONTRACT\" | \"CAST\", [MichelsonType]>> |\n   ReqArgs<InstrPrim<\"IF_NONE\" | \"IF_LEFT\" | \"IF_CONS\" | \"IF\", [MichelsonInstruction[], MichelsonInstruction[]]>> |\n   ReqArgs<InstrPrim<\"MAP\" | \"ITER\" | \"LOOP\" | \"LOOP_LEFT\" | \"DIP\" | \"CREATE_CONTRACT\", [MichelsonInstruction[]]>> |\n   ReqArgs<InstrPrim<\"PUSH\", [MichelsonType, MichelsonData]>> |\n   ReqArgs<InstrPrim<\"EMPTY_SET\", [MichelsonComparableType]>> |\n   ReqArgs<InstrPrim<\"EMPTY_MAP\" | \"EMPTY_BIG_MAP\", [MichelsonComparableType, MichelsonType]>> |\n   ReqArgs<InstrPrim<\"LAMBDA\", [MichelsonType, MichelsonType, MichelsonInstruction[]]>> |\n   ReqArgs<InstrPrim<\"DIP\", [IntLiteral, MichelsonInstruction[]] | [MichelsonInstruction[]]>>;\n\n// Types\n\nexport type MichelsonSimpleComparableTypeId = \"int\" | \"nat\" | \"string\" | \"bytes\" | \"mutez\" | \"bool\" |\n   \"key_hash\" | \"timestamp\" | \"address\";\n\nexport type MichelsonTypeId = MichelsonSimpleComparableTypeId |\n   \"key\" | \"unit\" | \"signature\" | \"operation\" | \"chain_id\" | \"option\" | \"list\" | \"contract\" | \"pair\" |\n   \"or\" | \"lambda\" | \"set\" | \"map\" | \"big_map\";\n\ntype TypePrim<PT extends MichelsonTypeId, AT extends MichelsonType[] = never> = Prim<PT, AT>;\n\nexport type MichelsonSimpleComparableType = NoArgs<TypePrim<MichelsonSimpleComparableTypeId>>;\nexport type MichelsonComparableType = MichelsonSimpleComparableType |\n   ReqArgs<TypePrim<\"pair\", [MichelsonSimpleComparableType, MichelsonComparableType]>>;\n\nexport type MichelsonType = MichelsonComparableType |\n   NoArgs<TypePrim<\"key\" | \"unit\" | \"signature\" | \"operation\" | \"chain_id\">> |\n   ReqArgs<TypePrim<\"option\" | \"list\" | \"contract\", [MichelsonType]>> |\n   ReqArgs<TypePrim<\"pair\" | \"or\" | \"lambda\", [MichelsonType, MichelsonType]>> |\n   ReqArgs<TypePrim<\"set\", [MichelsonComparableType]>> |\n   ReqArgs<TypePrim<\"map\" | \"big_map\", [MichelsonComparableType, MichelsonType]>>;\n\n// Data\n\nexport type MichelsonMapElt = ReqArgs<Prim<\"Elt\", [MichelsonData, MichelsonData]>>;\nexport type MichelsonDataId = \"Unit\" | \"True\" | \"False\" | \"None\" | \"Pair\" | \"Left\" | \"Right\" | \"Some\";\ntype DataPrim<PT extends MichelsonDataId, AT extends MichelsonData[] = never> = Prim<PT, AT>;\n\nexport type MichelsonData = IntLiteral |\n   StringLiteral |\n   BytesLiteral |\n   NoArgs<DataPrim<\"Unit\" | \"True\" | \"False\" | \"None\">> |\n   ReqArgs<DataPrim<\"Pair\", [MichelsonData, MichelsonData]>> |\n   ReqArgs<DataPrim<\"Left\" | \"Right\" | \"Some\", [MichelsonData]>> |\n   MichelsonData[] |\n   MichelsonMapElt[] |\n   MichelsonInstruction;\n\n// Top level script sections\n\ntype MichelsonSectionId = \"parameter\" | \"storage\" | \"code\";\ntype SectionPrim<PT extends MichelsonSectionId, AT extends Expr[]> = ReqArgs<Prim<PT, AT>>;\n\nexport type MichelsonParameter = SectionPrim<\"parameter\", [MichelsonType]>;\nexport type MichelsonStorage = SectionPrim<\"storage\", [MichelsonType]>;\nexport type MichelsonCode = SectionPrim<\"code\", [MichelsonInstruction[]]>;\n\nexport type MichelsonScript = [MichelsonParameter, MichelsonStorage, MichelsonCode] |\n   [MichelsonStorage, MichelsonCode, MichelsonParameter] |\n   [MichelsonCode, MichelsonParameter, MichelsonStorage];\n\n// Michelson validator\n\ninterface PathElem {\n   /**\n    * Node's index. Either argument index or sequence index.\n    */\n   index: number;\n   /**\n    * Node's value.\n    */\n   val: Expr;\n}\n\nexport class ValidationError extends Error {\n   /**\n    * @param val Value of a node caused the error\n    * @param path Path to a node caused the error in the AST tree\n    * @param message An error message\n    */\n   constructor(public val: Expr, public path?: PathElem[], message?: string) {\n      super(message);\n   }\n}\n\nfunction isPrim(ex: Expr): ex is Prim {\n   return \"prim\" in ex;\n}\n\nfunction assertPrim(ex: Expr, path: PathElem[]): ex is Prim {\n   if (isPrim(ex)) {\n      return true;\n   }\n   throw new ValidationError(ex, path, \"prim expression expected\");\n}\n\nfunction assertSeq(ex: Expr, path: PathElem[]): ex is Expr[] {\n   if (Array.isArray(ex)) {\n      return true;\n   }\n   throw new ValidationError(ex, path, \"sequence expression expected\");\n}\n\nfunction assertNatural(i: IntLiteral, path: PathElem[]) {\n   if (i.int[0] === \"-\") {\n      throw new ValidationError(i, path, \"natural number expected\");\n   }\n}\n\nfunction assertIntLiteral(ex: Expr, path: PathElem[]): ex is IntLiteral {\n   if (\"int\" in ex) {\n      return true;\n   }\n   throw new ValidationError(ex, path, \"int literal expected\");\n}\n\nfunction assertArgs<N extends number>(ex: Prim, n: N, path: PathElem[]):\n   ex is N extends 0 ?\n   NoArgs<Prim<string>> :\n   ReqArgs<Prim<string, Tuple<Expr, N>>> {\n   if ((n === 0 && ex.args === undefined) || ex.args?.length === n) {\n      return true;\n   }\n   throw new ValidationError(ex, path, `${n} arguments expected`);\n}\n\nconst unaryInstructionTable: Record<MichelsonUnaryInstructionId, boolean> = {\n   \"DUP\": true, \"SWAP\": true, \"SOME\": true, \"UNIT\": true, \"PAIR\": true, \"CAR\": true, \"CDR\": true,\n   \"CONS\": true, \"SIZE\": true, \"MEM\": true, \"GET\": true, \"UPDATE\": true, \"EXEC\": true, \"FAILWITH\": true, \"RENAME\": true, \"CONCAT\": true, \"SLICE\": true,\n   \"PACK\": true, \"ADD\": true, \"SUB\": true, \"MUL\": true, \"EDIV\": true, \"ABS\": true, \"ISNAT\": true, \"INT\": true, \"NEG\": true, \"LSL\": true, \"LSR\": true, \"OR\": true,\n   \"AND\": true, \"XOR\": true, \"NOT\": true, \"COMPARE\": true, \"EQ\": true, \"NEQ\": true, \"LT\": true, \"GT\": true, \"LE\": true, \"GE\": true, \"SELF\": true,\n   \"TRANSFER_TOKENS\": true, \"SET_DELEGATE\": true, \"CREATE_ACCOUNT\": true, \"IMPLICIT_ACCOUNT\": true, \"NOW\": true, \"AMOUNT\": true,\n   \"BALANCE\": true, \"CHECK_SIGNATURE\": true, \"BLAKE2B\": true, \"SHA256\": true, \"SHA512\": true, \"HASH_KEY\": true, \"STEPS_TO_QUOTA\": true,\n   \"SOURCE\": true, \"SENDER\": true, \"ADDRESS\": true, \"CHAIN_ID\": true,\n};\n\nconst instructionTable: Record<MichelsonInstructionId, boolean> = Object.assign({}, unaryInstructionTable, {\n   \"DROP\": true, \"DIG\": true, \"DUG\": true, \"NONE\": true, \"LEFT\": true, \"RIGHT\": true, \"NIL\": true, \"UNPACK\": true, \"CONTRACT\": true, \"CAST\": true,\n   \"IF_NONE\": true, \"IF_LEFT\": true, \"IF_CONS\": true, \"IF\": true, \"MAP\": true, \"ITER\": true, \"LOOP\": true, \"LOOP_LEFT\": true, \"DIP\": true,\n   \"CREATE_CONTRACT\": true, \"PUSH\": true, \"EMPTY_SET\": true, \"EMPTY_MAP\": true, \"EMPTY_BIG_MAP\": true, \"LAMBDA\": true,\n});\n\nfunction assertMichelsonInstruction(ex: Expr[] | Prim, path: PathElem[]): ex is MichelsonInstruction {\n   if (Array.isArray(ex)) {\n      let i = 0;\n      for (const n of ex) {\n         const p = [...path, { index: i, val: n }];\n         if (!Array.isArray(n) && !isPrim(n)) {\n            throw new ValidationError(ex, p, \"sequence or prim expected\");\n         }\n         assertMichelsonInstruction(n, p);\n         i++;\n      }\n   } else if (Object.prototype.hasOwnProperty.call(unaryInstructionTable, ex.prim)) {\n      assertArgs(ex, 0, path);\n   } else {\n      switch (ex.prim) {\n         case \"DROP\":\n            if (ex.args !== undefined && assertArgs(ex, 1, path)) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0], p)) {\n                  assertNatural(ex.args[0], p);\n               }\n            }\n            break;\n\n         case \"DIG\":\n         case \"DUG\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0], p)) {\n                  assertNatural(ex.args[0], p);\n               }\n            }\n            break;\n\n         case \"NONE\":\n         case \"LEFT\":\n         case \"RIGHT\":\n         case \"NIL\":\n         case \"UNPACK\":\n         case \"CONTRACT\":\n         case \"CAST\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"IF_NONE\":\n         case \"IF_LEFT\":\n         case \"IF_CONS\":\n         case \"IF\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               const p0 = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0], p0)) {\n                  assertMichelsonInstruction(ex.args[0], p0);\n               }\n               const p1 = [...path, { index: 1, val: ex.args[1] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[1], p1)) {\n                  assertMichelsonInstruction(ex.args[1], p1);\n               }\n            }\n            break;\n\n         case \"MAP\":\n         case \"ITER\":\n         case \"LOOP\":\n         case \"LOOP_LEFT\":\n         case \"CREATE_CONTRACT\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0], p)) {\n                  assertMichelsonInstruction(ex.args[0], p);\n               }\n            }\n            break;\n\n         case \"DIP\":\n            if (ex.args?.length === 2) {\n               const p0 = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0], p0)) {\n                  assertNatural(ex.args[0], p0);\n               }\n               const p1 = [...path, { index: 1, val: ex.args[1] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[1], p1)) {\n                  assertMichelsonInstruction(ex.args[1], p1);\n               }\n            } else if (ex.args?.length === 1) {\n               const p = [...path, { index: 0, val: ex.args[0] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0], p)) {\n                  assertMichelsonInstruction(ex.args[0], p);\n               }\n            } else {\n               throw new ValidationError(ex, path, \"1 or 2 arguments expected\");\n            }\n            break;\n\n         case \"PUSH\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonDataInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"EMPTY_SET\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"EMPTY_MAP\":\n         case \"EMPTY_BIG_MAP\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"LAMBDA\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 3, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n               const p2 = [...path, { index: 2, val: ex.args[2] }];\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[2], p2)) {\n                  assertMichelsonInstruction(ex.args[2], p2);\n               }\n            }\n            break;\n\n         default:\n            throw new ValidationError(ex, path, \"instruction expected\");\n      }\n   }\n   return true;\n}\n\nconst simpleComparableTypeTable: Record<MichelsonSimpleComparableTypeId, boolean> = {\n   \"int\": true, \"nat\": true, \"string\": true, \"bytes\": true, \"mutez\": true,\n   \"bool\": true, \"key_hash\": true, \"timestamp\": true, \"address\": true,\n};\n\nfunction assertMichelsonSimpleComparableType(ex: Expr, path: PathElem[]): ex is MichelsonSimpleComparableType {\n   /* istanbul ignore else */\n   if (assertPrim(ex, path)) {\n      if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n         throw new ValidationError(ex, path, \"simple comparable type expected\");\n      }\n      assertArgs(ex, 0, path);\n   }\n   return true;\n}\n\nfunction assertMichelsonComparableType(ex: Expr, path: PathElem[]): ex is MichelsonComparableType {\n   /* istanbul ignore else */\n   if (assertPrim(ex, path)) {\n      if (Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n         assertArgs(ex, 0, path);\n      } else if (ex.prim === \"pair\") {\n         /* istanbul ignore else */\n         if (assertArgs(ex, 2, path)) {\n            assertMichelsonSimpleComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            assertMichelsonComparableType(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n         }\n      } else {\n         throw new ValidationError(ex, path, \"comparable type expected\");\n      }\n   }\n   return true;\n}\n\nfunction assertMichelsonTypeInternal(ex: Expr, path: PathElem[]): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrim(ex, path)) {\n      switch (ex.prim) {\n         case \"key\":\n         case \"unit\":\n         case \"signature\":\n         case \"operation\":\n         case \"chain_id\":\n            assertArgs(ex, 0, path);\n            break;\n\n         case \"option\":\n         case \"list\":\n         case \"contract\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"pair\":\n         case \"or\":\n         case \"lambda\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonTypeInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"set\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         case \"map\":\n         case \"big_map\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonComparableType(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonTypeInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         default:\n            assertMichelsonComparableType(ex, path);\n      }\n   }\n\n   return true;\n}\n\nfunction assertMichelsonDataInternal(ex: Expr, path: PathElem[]): ex is MichelsonData {\n   if ((\"int\" in ex) || (\"string\" in ex) || (\"bytes\" in ex)) {\n      return true;\n   }\n\n   if (Array.isArray(ex)) {\n      let mapElts = 0;\n      let i = 0;\n      for (const n of ex) {\n         const p = [...path, { index: i, val: n }];\n         if (isPrim(n) && n.prim === \"Elt\") {\n            /* istanbul ignore else */\n            if (assertArgs(n, 2, p)) {\n               assertMichelsonDataInternal(n.args[0], [...p, { index: 0, val: n.args[0] }]);\n               assertMichelsonDataInternal(n.args[1], [...p, { index: 1, val: n.args[1] }]);\n            }\n            mapElts++;\n         } else {\n            assertMichelsonDataInternal(n, p);\n         }\n         i++;\n      }\n\n      if (mapElts !== 0 && mapElts !== ex.length) {\n         throw new ValidationError(ex, path, \"data entries and map elements can't be intermixed\");\n      }\n      return true;\n   }\n\n   if (isPrim(ex)) {\n      switch (ex.prim) {\n         case \"Unit\":\n         case \"True\":\n         case \"False\":\n         case \"None\":\n            assertArgs(ex, 0, path);\n            break;\n\n         case \"Pair\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2, path)) {\n               assertMichelsonDataInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n               assertMichelsonDataInternal(ex.args[1], [...path, { index: 1, val: ex.args[1] }]);\n            }\n            break;\n\n         case \"Left\":\n         case \"Right\":\n         case \"Some\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1, path)) {\n               assertMichelsonDataInternal(ex.args[0], [...path, { index: 0, val: ex.args[0] }]);\n            }\n            break;\n\n         default:\n            if (Object.prototype.hasOwnProperty.call(instructionTable, ex.prim)) {\n               assertMichelsonInstruction(ex, path);\n            } else {\n               throw new ValidationError(ex, path, \"data entry or instruction expected\");\n            }\n      }\n   } else {\n      throw new ValidationError(ex, path, \"data entry expected\");\n   }\n\n   return true;\n}\n\nfunction assertMichelsonScriptInternal(ex: Expr, path: PathElem[]): ex is MichelsonScript {\n   /* istanbul ignore else */\n   if (assertSeq(ex, path) && ex.length === 3 &&\n      assertPrim(ex[0], [...path, { index: 0, val: ex[0] }]) &&\n      assertPrim(ex[1], [...path, { index: 1, val: ex[1] }]) &&\n      assertPrim(ex[2], [...path, { index: 2, val: ex[2] }])) {\n\n      const p = [ex[0].prim, ex[1].prim, ex[2].prim].sort();\n      if (p[0] === \"code\" && p[1] === \"parameter\" && p[2] === \"storage\") {\n         let i = 0;\n         for (const n of ex as Prim[]) {\n            const p = [...path, { index: i, val: n }];\n\n            /* istanbul ignore else */\n            if (assertArgs(n, 1, p)) {\n               const pp = [...p, { index: 0, val: n.args[0] }];\n\n               switch (n.prim) {\n                  case \"code\":\n                     /* istanbul ignore else */\n                     if (assertSeq(n.args[0], pp)) {\n                        assertMichelsonInstruction(n.args[0], pp);\n                     }\n                     break;\n\n                  case \"parameter\":\n                  case \"storage\":\n                     assertMichelsonTypeInternal(n.args[0], pp);\n               }\n            }\n            i++;\n         }\n      } else {\n         throw new ValidationError(ex, path, \"valid Michelson script expected\");\n      }\n   }\n   return true;\n}\n\n/**\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonScript(ex: Expr): ex is MichelsonScript {\n   return assertMichelsonScriptInternal(ex, []);\n}\n\n/**\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonData(ex: Expr): ex is MichelsonData {\n   return assertMichelsonDataInternal(ex, []);\n}\n\n/**\n * Checks if the node is a valid Michelson code (sequence of instructions).\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonCode(ex: Expr[]): ex is MichelsonInstruction[] {\n   return assertMichelsonInstruction(ex, []);\n}\n\n/**\n * Checks if the node is a valid Michelson type expression.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonType(ex: Expr): ex is MichelsonType {\n   return assertMichelsonTypeInternal(ex, []);\n}"],"names":["assertArgs"],"mappings":"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"}