import { Prim, Expr, IntLiteral, StringLiteral, BytesLiteral } from "./micheline";
import { NoArgs, ReqArgs } from "./utils";
export declare type MichelsonUnaryInstructionId = "DUP" | "SWAP" | "SOME" | "UNIT" | "PAIR" | "CAR" | "CDR" | "CONS" | "SIZE" | "MEM" | "GET" | "UPDATE" | "EXEC" | "FAILWITH" | "RENAME" | "CONCAT" | "SLICE" | "PACK" | "ADD" | "SUB" | "MUL" | "EDIV" | "ABS" | "ISNAT" | "INT" | "NEG" | "LSL" | "LSR" | "OR" | "AND" | "XOR" | "NOT" | "COMPARE" | "EQ" | "NEQ" | "LT" | "GT" | "LE" | "GE" | "SELF" | "TRANSFER_TOKENS" | "SET_DELEGATE" | "CREATE_ACCOUNT" | "IMPLICIT_ACCOUNT" | "NOW" | "AMOUNT" | "BALANCE" | "CHECK_SIGNATURE" | "BLAKE2B" | "SHA256" | "SHA512" | "HASH_KEY" | "STEPS_TO_QUOTA" | "SOURCE" | "SENDER" | "ADDRESS" | "CHAIN_ID";
export declare type MichelsonInstructionId = MichelsonUnaryInstructionId | "DROP" | "DIG" | "DUG" | "NONE" | "LEFT" | "RIGHT" | "NIL" | "UNPACK" | "CONTRACT" | "CAST" | "IF_NONE" | "IF_LEFT" | "IF_CONS" | "IF" | "MAP" | "ITER" | "LOOP" | "LOOP_LEFT" | "DIP" | "CREATE_CONTRACT" | "PUSH" | "EMPTY_SET" | "EMPTY_MAP" | "EMPTY_BIG_MAP" | "LAMBDA";
declare type InstrPrim<PT extends MichelsonInstructionId, AT extends Expr[] = never> = Prim<PT, AT>;
export declare type MichelsonInstruction = MichelsonInstruction[] | NoArgs<InstrPrim<MichelsonUnaryInstructionId>> | ReqArgs<InstrPrim<"DIG" | "DUG", [IntLiteral]>> | InstrPrim<"DROP", [IntLiteral]> | // Keep optional argument
ReqArgs<InstrPrim<"NONE" | "LEFT" | "RIGHT" | "NIL" | "UNPACK" | "CONTRACT" | "CAST", [MichelsonType]>> | ReqArgs<InstrPrim<"IF_NONE" | "IF_LEFT" | "IF_CONS" | "IF", [MichelsonInstruction[], MichelsonInstruction[]]>> | ReqArgs<InstrPrim<"MAP" | "ITER" | "LOOP" | "LOOP_LEFT" | "DIP" | "CREATE_CONTRACT", [MichelsonInstruction[]]>> | ReqArgs<InstrPrim<"PUSH", [MichelsonType, MichelsonData]>> | ReqArgs<InstrPrim<"EMPTY_SET", [MichelsonComparableType]>> | ReqArgs<InstrPrim<"EMPTY_MAP" | "EMPTY_BIG_MAP", [MichelsonComparableType, MichelsonType]>> | ReqArgs<InstrPrim<"LAMBDA", [MichelsonType, MichelsonType, MichelsonInstruction[]]>> | ReqArgs<InstrPrim<"DIP", [IntLiteral, MichelsonInstruction[]] | [MichelsonInstruction[]]>>;
export declare type MichelsonSimpleComparableTypeId = "int" | "nat" | "string" | "bytes" | "mutez" | "bool" | "key_hash" | "timestamp" | "address";
export declare type MichelsonTypeId = MichelsonSimpleComparableTypeId | "key" | "unit" | "signature" | "operation" | "chain_id" | "option" | "list" | "contract" | "pair" | "or" | "lambda" | "set" | "map" | "big_map";
declare type TypePrim<PT extends MichelsonTypeId, AT extends MichelsonType[] = never> = Prim<PT, AT>;
export declare type MichelsonSimpleComparableType = NoArgs<TypePrim<MichelsonSimpleComparableTypeId>>;
export declare type MichelsonComparableType = MichelsonSimpleComparableType | ReqArgs<TypePrim<"pair", [MichelsonSimpleComparableType, MichelsonComparableType]>>;
export declare type MichelsonType = MichelsonComparableType | NoArgs<TypePrim<"key" | "unit" | "signature" | "operation" | "chain_id">> | ReqArgs<TypePrim<"option" | "list" | "contract", [MichelsonType]>> | ReqArgs<TypePrim<"pair" | "or" | "lambda", [MichelsonType, MichelsonType]>> | ReqArgs<TypePrim<"set", [MichelsonComparableType]>> | ReqArgs<TypePrim<"map" | "big_map", [MichelsonComparableType, MichelsonType]>>;
export declare type MichelsonMapElt = ReqArgs<Prim<"Elt", [MichelsonData, MichelsonData]>>;
export declare type MichelsonDataId = "Unit" | "True" | "False" | "None" | "Pair" | "Left" | "Right" | "Some";
declare type DataPrim<PT extends MichelsonDataId, AT extends MichelsonData[] = never> = Prim<PT, AT>;
export declare type MichelsonData = IntLiteral | StringLiteral | BytesLiteral | NoArgs<DataPrim<"Unit" | "True" | "False" | "None">> | ReqArgs<DataPrim<"Pair", [MichelsonData, MichelsonData]>> | ReqArgs<DataPrim<"Left" | "Right" | "Some", [MichelsonData]>> | MichelsonData[] | MichelsonMapElt[] | MichelsonInstruction;
declare type MichelsonSectionId = "parameter" | "storage" | "code";
declare type SectionPrim<PT extends MichelsonSectionId, AT extends Expr[]> = ReqArgs<Prim<PT, AT>>;
export declare type MichelsonParameter = SectionPrim<"parameter", [MichelsonType]>;
export declare type MichelsonStorage = SectionPrim<"storage", [MichelsonType]>;
export declare type MichelsonCode = SectionPrim<"code", [MichelsonInstruction[]]>;
export declare type MichelsonScript = [MichelsonParameter, MichelsonStorage, MichelsonCode] | [MichelsonStorage, MichelsonCode, MichelsonParameter] | [MichelsonCode, MichelsonParameter, MichelsonStorage];
interface PathElem {
    /**
     * Node's index. Either argument index or sequence index.
     */
    index: number;
    /**
     * Node's value.
     */
    val: Expr;
}
export declare class ValidationError extends Error {
    val: Expr;
    path?: PathElem[] | undefined;
    /**
     * @param val Value of a node caused the error
     * @param path Path to a node caused the error in the AST tree
     * @param message An error message
     */
    constructor(val: Expr, path?: PathElem[] | undefined, message?: string);
}
/**
 * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
export declare function assertMichelsonScript(ex: Expr): ex is MichelsonScript;
/**
 * Checks if the node is a valid Michelson data literal such as `(Pair {Elt "0" 0} 0)`.
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
export declare function assertMichelsonData(ex: Expr): ex is MichelsonData;
/**
 * Checks if the node is a valid Michelson code (sequence of instructions).
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
export declare function assertMichelsonCode(ex: Expr[]): ex is MichelsonInstruction[];
/**
 * Checks if the node is a valid Michelson type expression.
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
export declare function assertMichelsonType(ex: Expr): ex is MichelsonType;
export {};
