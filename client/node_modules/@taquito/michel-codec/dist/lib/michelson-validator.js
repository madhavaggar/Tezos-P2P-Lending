"use strict";
// Michelson types
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertMichelsonType = exports.assertMichelsonCode = exports.assertMichelsonData = exports.assertMichelsonScript = exports.ValidationError = void 0;
var ValidationError = /** @class */ (function (_super) {
    __extends(ValidationError, _super);
    /**
     * @param val Value of a node caused the error
     * @param path Path to a node caused the error in the AST tree
     * @param message An error message
     */
    function ValidationError(val, path, message) {
        var _this = _super.call(this, message) || this;
        _this.val = val;
        _this.path = path;
        return _this;
    }
    return ValidationError;
}(Error));
exports.ValidationError = ValidationError;
function isPrim(ex) {
    return "prim" in ex;
}
function assertPrim(ex, path) {
    if (isPrim(ex)) {
        return true;
    }
    throw new ValidationError(ex, path, "prim expression expected");
}
function assertSeq(ex, path) {
    if (Array.isArray(ex)) {
        return true;
    }
    throw new ValidationError(ex, path, "sequence expression expected");
}
function assertNatural(i, path) {
    if (i.int[0] === "-") {
        throw new ValidationError(i, path, "natural number expected");
    }
}
function assertIntLiteral(ex, path) {
    if ("int" in ex) {
        return true;
    }
    throw new ValidationError(ex, path, "int literal expected");
}
function assertArgs(ex, n, path) {
    var _a;
    if ((n === 0 && ex.args === undefined) || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {
        return true;
    }
    throw new ValidationError(ex, path, n + " arguments expected");
}
var unaryInstructionTable = {
    "DUP": true, "SWAP": true, "SOME": true, "UNIT": true, "PAIR": true, "CAR": true, "CDR": true,
    "CONS": true, "SIZE": true, "MEM": true, "GET": true, "UPDATE": true, "EXEC": true, "FAILWITH": true, "RENAME": true, "CONCAT": true, "SLICE": true,
    "PACK": true, "ADD": true, "SUB": true, "MUL": true, "EDIV": true, "ABS": true, "ISNAT": true, "INT": true, "NEG": true, "LSL": true, "LSR": true, "OR": true,
    "AND": true, "XOR": true, "NOT": true, "COMPARE": true, "EQ": true, "NEQ": true, "LT": true, "GT": true, "LE": true, "GE": true, "SELF": true,
    "TRANSFER_TOKENS": true, "SET_DELEGATE": true, "CREATE_ACCOUNT": true, "IMPLICIT_ACCOUNT": true, "NOW": true, "AMOUNT": true,
    "BALANCE": true, "CHECK_SIGNATURE": true, "BLAKE2B": true, "SHA256": true, "SHA512": true, "HASH_KEY": true, "STEPS_TO_QUOTA": true,
    "SOURCE": true, "SENDER": true, "ADDRESS": true, "CHAIN_ID": true,
};
var instructionTable = Object.assign({}, unaryInstructionTable, {
    "DROP": true, "DIG": true, "DUG": true, "NONE": true, "LEFT": true, "RIGHT": true, "NIL": true, "UNPACK": true, "CONTRACT": true, "CAST": true,
    "IF_NONE": true, "IF_LEFT": true, "IF_CONS": true, "IF": true, "MAP": true, "ITER": true, "LOOP": true, "LOOP_LEFT": true, "DIP": true,
    "CREATE_CONTRACT": true, "PUSH": true, "EMPTY_SET": true, "EMPTY_MAP": true, "EMPTY_BIG_MAP": true, "LAMBDA": true,
});
function assertMichelsonInstruction(ex, path) {
    var e_1, _a;
    var _b, _c;
    if (Array.isArray(ex)) {
        var i = 0;
        try {
            for (var ex_1 = __values(ex), ex_1_1 = ex_1.next(); !ex_1_1.done; ex_1_1 = ex_1.next()) {
                var n = ex_1_1.value;
                var p = __spread(path, [{ index: i, val: n }]);
                if (!Array.isArray(n) && !isPrim(n)) {
                    throw new ValidationError(ex, p, "sequence or prim expected");
                }
                assertMichelsonInstruction(n, p);
                i++;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ex_1_1 && !ex_1_1.done && (_a = ex_1.return)) _a.call(ex_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else if (Object.prototype.hasOwnProperty.call(unaryInstructionTable, ex.prim)) {
        assertArgs(ex, 0, path);
    }
    else {
        switch (ex.prim) {
            case "DROP":
                if (ex.args !== undefined && assertArgs(ex, 1, path)) {
                    var p = __spread(path, [{ index: 0, val: ex.args[0] }]);
                    /* istanbul ignore else */
                    if (assertIntLiteral(ex.args[0], p)) {
                        assertNatural(ex.args[0], p);
                    }
                }
                break;
            case "DIG":
            case "DUG":
                /* istanbul ignore else */
                if (assertArgs(ex, 1, path)) {
                    var p = __spread(path, [{ index: 0, val: ex.args[0] }]);
                    /* istanbul ignore else */
                    if (assertIntLiteral(ex.args[0], p)) {
                        assertNatural(ex.args[0], p);
                    }
                }
                break;
            case "NONE":
            case "LEFT":
            case "RIGHT":
            case "NIL":
            case "UNPACK":
            case "CONTRACT":
            case "CAST":
                /* istanbul ignore else */
                if (assertArgs(ex, 1, path)) {
                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                }
                break;
            case "IF_NONE":
            case "IF_LEFT":
            case "IF_CONS":
            case "IF":
                /* istanbul ignore else */
                if (assertArgs(ex, 2, path)) {
                    var p0 = __spread(path, [{ index: 0, val: ex.args[0] }]);
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[0], p0)) {
                        assertMichelsonInstruction(ex.args[0], p0);
                    }
                    var p1 = __spread(path, [{ index: 1, val: ex.args[1] }]);
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[1], p1)) {
                        assertMichelsonInstruction(ex.args[1], p1);
                    }
                }
                break;
            case "MAP":
            case "ITER":
            case "LOOP":
            case "LOOP_LEFT":
            case "CREATE_CONTRACT":
                /* istanbul ignore else */
                if (assertArgs(ex, 1, path)) {
                    var p = __spread(path, [{ index: 0, val: ex.args[0] }]);
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[0], p)) {
                        assertMichelsonInstruction(ex.args[0], p);
                    }
                }
                break;
            case "DIP":
                if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 2) {
                    var p0 = __spread(path, [{ index: 0, val: ex.args[0] }]);
                    /* istanbul ignore else */
                    if (assertIntLiteral(ex.args[0], p0)) {
                        assertNatural(ex.args[0], p0);
                    }
                    var p1 = __spread(path, [{ index: 1, val: ex.args[1] }]);
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[1], p1)) {
                        assertMichelsonInstruction(ex.args[1], p1);
                    }
                }
                else if (((_c = ex.args) === null || _c === void 0 ? void 0 : _c.length) === 1) {
                    var p = __spread(path, [{ index: 0, val: ex.args[0] }]);
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[0], p)) {
                        assertMichelsonInstruction(ex.args[0], p);
                    }
                }
                else {
                    throw new ValidationError(ex, path, "1 or 2 arguments expected");
                }
                break;
            case "PUSH":
                /* istanbul ignore else */
                if (assertArgs(ex, 2, path)) {
                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    assertMichelsonDataInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                }
                break;
            case "EMPTY_SET":
                /* istanbul ignore else */
                if (assertArgs(ex, 1, path)) {
                    assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                }
                break;
            case "EMPTY_MAP":
            case "EMPTY_BIG_MAP":
                /* istanbul ignore else */
                if (assertArgs(ex, 2, path)) {
                    assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                }
                break;
            case "LAMBDA":
                /* istanbul ignore else */
                if (assertArgs(ex, 3, path)) {
                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                    var p2 = __spread(path, [{ index: 2, val: ex.args[2] }]);
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[2], p2)) {
                        assertMichelsonInstruction(ex.args[2], p2);
                    }
                }
                break;
            default:
                throw new ValidationError(ex, path, "instruction expected");
        }
    }
    return true;
}
var simpleComparableTypeTable = {
    "int": true, "nat": true, "string": true, "bytes": true, "mutez": true,
    "bool": true, "key_hash": true, "timestamp": true, "address": true,
};
function assertMichelsonSimpleComparableType(ex, path) {
    /* istanbul ignore else */
    if (assertPrim(ex, path)) {
        if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {
            throw new ValidationError(ex, path, "simple comparable type expected");
        }
        assertArgs(ex, 0, path);
    }
    return true;
}
function assertMichelsonComparableType(ex, path) {
    /* istanbul ignore else */
    if (assertPrim(ex, path)) {
        if (Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {
            assertArgs(ex, 0, path);
        }
        else if (ex.prim === "pair") {
            /* istanbul ignore else */
            if (assertArgs(ex, 2, path)) {
                assertMichelsonSimpleComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                assertMichelsonComparableType(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
            }
        }
        else {
            throw new ValidationError(ex, path, "comparable type expected");
        }
    }
    return true;
}
function assertMichelsonTypeInternal(ex, path) {
    /* istanbul ignore else */
    if (assertPrim(ex, path)) {
        switch (ex.prim) {
            case "key":
            case "unit":
            case "signature":
            case "operation":
            case "chain_id":
                assertArgs(ex, 0, path);
                break;
            case "option":
            case "list":
            case "contract":
                /* istanbul ignore else */
                if (assertArgs(ex, 1, path)) {
                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                }
                break;
            case "pair":
            case "or":
            case "lambda":
                /* istanbul ignore else */
                if (assertArgs(ex, 2, path)) {
                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                }
                break;
            case "set":
                /* istanbul ignore else */
                if (assertArgs(ex, 1, path)) {
                    assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                }
                break;
            case "map":
            case "big_map":
                /* istanbul ignore else */
                if (assertArgs(ex, 2, path)) {
                    assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                }
                break;
            default:
                assertMichelsonComparableType(ex, path);
        }
    }
    return true;
}
function assertMichelsonDataInternal(ex, path) {
    var e_2, _a;
    if (("int" in ex) || ("string" in ex) || ("bytes" in ex)) {
        return true;
    }
    if (Array.isArray(ex)) {
        var mapElts = 0;
        var i = 0;
        try {
            for (var ex_2 = __values(ex), ex_2_1 = ex_2.next(); !ex_2_1.done; ex_2_1 = ex_2.next()) {
                var n = ex_2_1.value;
                var p = __spread(path, [{ index: i, val: n }]);
                if (isPrim(n) && n.prim === "Elt") {
                    /* istanbul ignore else */
                    if (assertArgs(n, 2, p)) {
                        assertMichelsonDataInternal(n.args[0], __spread(p, [{ index: 0, val: n.args[0] }]));
                        assertMichelsonDataInternal(n.args[1], __spread(p, [{ index: 1, val: n.args[1] }]));
                    }
                    mapElts++;
                }
                else {
                    assertMichelsonDataInternal(n, p);
                }
                i++;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (ex_2_1 && !ex_2_1.done && (_a = ex_2.return)) _a.call(ex_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (mapElts !== 0 && mapElts !== ex.length) {
            throw new ValidationError(ex, path, "data entries and map elements can't be intermixed");
        }
        return true;
    }
    if (isPrim(ex)) {
        switch (ex.prim) {
            case "Unit":
            case "True":
            case "False":
            case "None":
                assertArgs(ex, 0, path);
                break;
            case "Pair":
                /* istanbul ignore else */
                if (assertArgs(ex, 2, path)) {
                    assertMichelsonDataInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                    assertMichelsonDataInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));
                }
                break;
            case "Left":
            case "Right":
            case "Some":
                /* istanbul ignore else */
                if (assertArgs(ex, 1, path)) {
                    assertMichelsonDataInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));
                }
                break;
            default:
                if (Object.prototype.hasOwnProperty.call(instructionTable, ex.prim)) {
                    assertMichelsonInstruction(ex, path);
                }
                else {
                    throw new ValidationError(ex, path, "data entry or instruction expected");
                }
        }
    }
    else {
        throw new ValidationError(ex, path, "data entry expected");
    }
    return true;
}
function assertMichelsonScriptInternal(ex, path) {
    var e_3, _a;
    /* istanbul ignore else */
    if (assertSeq(ex, path) && ex.length === 3 &&
        assertPrim(ex[0], __spread(path, [{ index: 0, val: ex[0] }])) &&
        assertPrim(ex[1], __spread(path, [{ index: 1, val: ex[1] }])) &&
        assertPrim(ex[2], __spread(path, [{ index: 2, val: ex[2] }]))) {
        var p = [ex[0].prim, ex[1].prim, ex[2].prim].sort();
        if (p[0] === "code" && p[1] === "parameter" && p[2] === "storage") {
            var i = 0;
            try {
                for (var _b = __values(ex), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var n = _c.value;
                    var p_1 = __spread(path, [{ index: i, val: n }]);
                    /* istanbul ignore else */
                    if (assertArgs(n, 1, p_1)) {
                        var pp = __spread(p_1, [{ index: 0, val: n.args[0] }]);
                        switch (n.prim) {
                            case "code":
                                /* istanbul ignore else */
                                if (assertSeq(n.args[0], pp)) {
                                    assertMichelsonInstruction(n.args[0], pp);
                                }
                                break;
                            case "parameter":
                            case "storage":
                                assertMichelsonTypeInternal(n.args[0], pp);
                        }
                    }
                    i++;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else {
            throw new ValidationError(ex, path, "valid Michelson script expected");
        }
    }
    return true;
}
/**
 * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
function assertMichelsonScript(ex) {
    return assertMichelsonScriptInternal(ex, []);
}
exports.assertMichelsonScript = assertMichelsonScript;
/**
 * Checks if the node is a valid Michelson data literal such as `(Pair {Elt "0" 0} 0)`.
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
function assertMichelsonData(ex) {
    return assertMichelsonDataInternal(ex, []);
}
exports.assertMichelsonData = assertMichelsonData;
/**
 * Checks if the node is a valid Michelson code (sequence of instructions).
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
function assertMichelsonCode(ex) {
    return assertMichelsonInstruction(ex, []);
}
exports.assertMichelsonCode = assertMichelsonCode;
/**
 * Checks if the node is a valid Michelson type expression.
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
function assertMichelsonType(ex) {
    return assertMichelsonTypeInternal(ex, []);
}
exports.assertMichelsonType = assertMichelsonType;
//# sourceMappingURL=michelson-validator.js.map